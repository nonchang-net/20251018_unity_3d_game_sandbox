# キャラクター動作仕様

このドキュメントは、プレイヤーキャラクターの動作制御システムの実装仕様を説明します。

## 概要

キャラクター動作システムは、プレイヤー入力に基づくキャラクターの移動・アニメーション・ゲーム要素との相互作用を実装しており、以下の3つのコンポーネントで構成されています。

- **GameInputManager**: Input Systemからの入力を受け取り、各コンポーネントに配信
- **GameCharacterManager**: キャラクターの移動・アニメーション・状態管理を担当
- **GameCharacterCollisionTrigger**: トリガーベースのゲーム要素（コイン、ダメージソース等）との衝突を検出

## コンポーネントの役割

### GameInputManager

Input Systemの入力を受け取り、適切なコンポーネントに配信する中央ハブです。

**主な責務:**
- Input System（IPlayerActionsインターフェース）の実装
- 移動入力（WASD/ゲームパッド左スティック）の受付とGameCharacterManagerへの配信
- 視点入力（マウス/ゲームパッド右スティック）の受付とCharacterTrackerへの配信
- ジャンプ・スプリント入力の受付とGameCharacterManagerへの配信
- カメラ操作（ズーム切り替え、リセット）の入力受付
- ポーズ入力の受付とGameTimeManagerへの配信
- **DisableVerticalInputの適用**（カメラロック時に上下移動を無効化）

**重要な処理:**
- `OnMove()`: 移動入力を受け取り、CharacterTrackerのDisableVerticalInputフラグに応じてY軸入力を無効化
- `OnLook()`: 視点入力をCharacterTrackerに配信
- `OnJump()` / `OnSprint()`: ジャンプ・スプリント入力をGameCharacterManagerに配信
- `OnToggleZoomMode()`: カメラビュー切り替えをGameStateManagerに通知
- `OnTogglePause()`: ポーズ状態をトグルし、カーソル表示を制御

### GameCharacterManager

キャラクターの移動・アニメーション・状態を管理するコンポーネントです。

**主な責務:**
- CharacterControllerまたはRigidbody+Colliderベースのキャラクター移動処理
- カメラ相対の移動方向計算
- キャラクターの回転制御（即座 or 徐々に）
- ジャンプ処理（重力適用）
- アニメーション制御（Speed、inAir、isCrouched、isDeadなど）
- ダメージ受けた時のノックバック処理
- MovingPlatform追従処理
- R3を使用したイベント駆動型の処理（ダメージ、死亡、ハイジャンプ）
- キャラクターテレポート機能

**重要な処理:**
- `InitializeCharacter()`: キャラクターの実装タイプを自動検出（CharacterController or Rigidbody+Collider）
- `HandlePlayerMovement()`: 実装タイプに応じた移動処理の振り分け
- `HandleMovementCharacterController()` / `HandleMovementRigidbody()`: 各実装タイプの移動処理
- `OnDamageReceived()`: ダメージ受けた時のノックバックアニメーション開始
- `HandleKnockbackMovement()`: ノックバック移動処理（Lerp補間）
- `HandlePlatformMovement()`: MovingPlatformの移動量をキャラクターに適用
- `TeleportTo()`: キャラクターを指定位置にテレポート（物理状態リセット含む）

### GameCharacterCollisionTrigger

プレイヤーキャラクターにアタッチして、トリガーベースのゲーム要素との衝突を検出します。

**主な責務:**
- コイン取得の検出と処理
- ダメージソースとの衝突検出とダメージ処理
- DeadZone（落下死亡判定）の検出
- StaticMessage表示エリアの進入・退出検出
- CheckPointのアクティブ化
- HighJumperの発動
- CameraLockAreaの進入・退出検出

**重要な処理:**
- `OnTriggerEnter()`: 各種タグ（Coin, DamageSource, DeadZone, StaticMessage, CheckPoint, HighJumper, CameraLockArea）を検出して適切な処理に振り分け
- `OnTriggerExit()`: StaticMessage、CameraLockAreaの退出を検出
- `CollectCoin()`: コインの取得アニメーション開始とHP回復
- `TakeDamageFromSource()`: GameStateManagerのダメージ処理を呼び出し
- `EnterCameraLockArea()` / `ExitCameraLockArea()`: CameraLockerコンポーネントからTrackingSetting配列を取得してGameStateManagerに通知

## データフロー

### 移動入力のフロー

```
プレイヤー入力（WASD/ゲームパッド左スティック）
  ↓
GameInputManager.OnMove()
  ↓
CharacterTracker.DisableVerticalInputフラグを確認
  ↓
（有効な場合）Y軸入力を0に
  ↓
GameCharacterManager.SetMovementInput()
  ↓
GameCharacterManager.HandlePlayerMovement()
  ↓
CharacterTracker.GetCameraForward/Right()でカメラ方向を取得
  ↓
カメラ相対の移動方向を計算
  ↓
キャラクターを移動方向に回転
  ↓
CharacterController.Move() or Rigidbody.linearVelocity設定
```

### ダメージ処理のフロー

```
GameCharacterCollisionTrigger.OnTriggerEnter()
  ↓
DamageSourceタグを検出
  ↓
GameStateManager.TakeDamage()
  ↓
GameCharacterManager（R3購読）
  ↓
OnDamageReceived()
  ↓
ノックバックアニメーション開始
  ↓
（enableKnockbackMovementが有効な場合）
  ↓
HandleKnockbackMovement()
  ↓
ノックバック方向に移動（Lerp補間）
```

### コイン取得のフロー

```
GameCharacterCollisionTrigger.OnTriggerEnter()
  ↓
Coinタグを検出
  ↓
Coin.Collect()（取得アニメーション開始）
  ↓
GameStateManager.HealHp(1)
```

## キャラクター実装要件

GameCharacterManagerは、以下の2種類のキャラクター実装をサポートしています。

### パターン1: CharacterController

- CharacterControllerコンポーネントを持つキャラクター
- `CharacterController.Move()`で移動
- `CharacterController.isGrounded`で地面判定
- 重力は手動で計算して適用（`velocity.y += gravity * Time.deltaTime`）

### パターン2: Rigidbody + Collider

- RigidbodyとCollider（BoxCollider、CapsuleCollider、SphereColliderなど）を持つキャラクター
- `Rigidbody.linearVelocity`を設定して移動
- Raycastで地面判定（`CheckGroundRigidbody()`）
- 重力はUnityの物理エンジンが自動で適用
- Rigidbodyの設定: `freezeRotation = true`, `collisionDetectionMode = ContinuousDynamic`, `interpolation = Interpolate`

**自動検出:**
- `InitializeCharacter()`で実装タイプを自動検出
- Animatorも自動検出（子オブジェクトも検索）

## 主要機能

### 1. カメラ相対移動

プレイヤーの入力方向（WASD）をカメラの向きに応じて変換し、カメラから見て直感的な方向に移動します。

**実装:**
```csharp
Vector3 cameraForward = gameManager.CharacterTracker.GetCameraForward();
Vector3 cameraRight = gameManager.CharacterTracker.GetCameraRight();
moveDirection = (cameraForward * inputDirection.z + cameraRight * inputDirection.x).normalized;
```

- `GetCameraForward()`と`GetCameraRight()`は、カメラのYaw角から三角関数で直接計算
- カメラ回転のスムージング遅延の影響を受けない正確な移動方向を提供

### 2. キャラクター回転制御

移動方向にキャラクターを回転させる処理です。

**回転速度の設定:**
- `rotationSpeed <= 0`: 即座に回転（**推奨、カニ歩き防止**）
- `rotationSpeed > 0`: `Quaternion.RotateTowards()`で徐々に回転

**実装:**
```csharp
float targetAngle = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg;
Quaternion targetRotation = Quaternion.Euler(0f, targetAngle, 0f);

if (rotationSpeed <= 0f)
{
    // 即座に回転
    targetCharacter.transform.rotation = targetRotation;
}
else
{
    // 徐々に回転
    targetCharacter.transform.rotation = Quaternion.RotateTowards(
        targetCharacter.transform.rotation,
        targetRotation,
        rotationSpeed * Time.deltaTime
    );
}
```

**カニ歩き問題:**
- `rotationSpeed > 0`の場合、回転が完了するまで時間がかかるため、キャラクターが移動方向とは異なる方向を向いたまま移動する「カニ歩き」が発生
- 例: 360°/sで90°回転するのに約0.25秒かかる
- **解決策**: `rotationSpeed = 0`で即座に回転させる（デフォルト値）

### 3. ジャンプ処理

**CharacterController実装:**
```csharp
if (requestJump && characterController.isGrounded && !isCrouched)
{
    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
}
```

**Rigidbody実装:**
```csharp
if (requestJump && isGroundedRigidbody && !isCrouched)
{
    characterRigidbody.AddForce(Vector3.up * Mathf.Sqrt(jumpHeight * -2f * Physics.gravity.y), ForceMode.VelocityChange);
}
```

- `jumpHeight`で最大到達高さを指定
- 物理計算式（`v = sqrt(2 * h * g)`）で初速度を計算
- しゃがみ中はジャンプ不可

### 4. ノックバック処理

ダメージを受けた時にキャラクターを弾け飛ばす機能です。

**処理の流れ:**
1. `OnDamageReceived()`でノックバックアニメーション開始（`isKnockback = true`）
2. ダメージソースからキャラクターへの方向を計算
3. ノックバック開始位置と目標位置を設定（`knockbackDistance`分移動）
4. `HandleKnockbackMovement()`で毎フレーム`Lerp()`補間して移動
5. 0.5秒後に`ResetKnockbackAfterDelay()`でノックバック状態を解除

**CharacterController vs Rigidbody:**
- CharacterController: `CharacterController.Move()`で移動
- Rigidbody: `Rigidbody.MovePosition()`で移動

**設定:**
- `enableKnockbackMovement`: ノックバック移動を有効にするか（falseの場合はアニメーションのみ）
- `knockbackDistance`: ノックバック時の移動距離
- `knockbackSpeed`: ノックバック移動の速度（Lerpの進行速度）

### 5. MovingPlatform追従

MovingPlatformタグの動く床に乗った時、プラットフォームの移動量をキャラクターに適用する機能です。

**実装:**
- CharacterController: `OnControllerColliderHit()`でMovingPlatformタグを検出
- Rigidbody: `CheckGroundRigidbody()`のRaycastでMovingPlatformタグを検出
- `FixedUpdate()`で`HandlePlatformMovement()`を実行（物理演算と同期）
- プラットフォームの移動量（`currentPlatform.position - previousPlatformPosition`）を計算してキャラクターに適用

### 6. アニメーション制御

Animatorパラメータを更新してキャラクターのアニメーションを制御します。

**更新されるパラメータ:**
- `animatorSpeedKey` (float): キャラクターの移動速度（歩き・走りアニメーションの切り替え）
- `animatorInAirKey` (bool): 空中にいるか（ジャンプアニメーション）
- `animatorIsCrouchedKey` (bool): しゃがんでいるか
- `animatorIsDeadKey` (bool): 死亡しているか
- `animatorIsKnockbackKey` (bool): ノックバック中か

**実装:**
- `UpdateAnimator()`で毎フレーム更新
- `playerSpeed`は移動速度に応じてLerpで滑らかに変化

### 7. テレポート機能

キャラクターを指定位置に瞬間移動させる機能です。

**CharacterController実装:**
```csharp
characterController.enabled = false;
targetCharacter.transform.position = position;
targetCharacter.transform.rotation = rotation;
characterController.enabled = true;
```

**Rigidbody実装:**
```csharp
characterRigidbody.position = position;
characterRigidbody.rotation = rotation;
ResetPhysicsState(); // 速度をゼロにリセット
```

- リスポーンやCheckPoint機能で使用
- Rigidbodyの場合は物理状態（速度、角速度）もリセット

### 8. トリガー検出機能

GameCharacterCollisionTriggerは、以下のゲーム要素との衝突を検出します。

#### 8.1 コイン取得

- **タグ**: Coin
- **処理**: `Coin.Collect()`で取得アニメーション、`GameStateManager.HealHp(1)`でHP回復
- **条件**: 既に取得済みの場合は処理しない

#### 8.2 ダメージソース

- **タグ**: DamageSource
- **処理**: `GameStateManager.TakeDamage(damageAmount, damageSource)`
- **設定**: `damageAmount`でダメージ量を指定（デフォルト1）

#### 8.3 DeadZone（落下死亡判定）

- **タグ**: DeadZone
- **処理**: 即座に死亡またはMaxHP分のダメージ
- **設定**: `instantDeathOnDeadZone`（true: 即死、false: MaxHPのダメージ）

#### 8.4 StaticMessage

- **タグ**: StaticMessage
- **処理**: エリア進入時に`GameUIManager.ShowStaticMessage()`でメッセージ表示、退出時に非表示
- **コンポーネント**: StaticMessengerからメッセージテキストを取得

#### 8.5 CheckPoint

- **タグ**: CheckPoint
- **処理**: `GameStateManager.ActivateCheckPoint(checkPoint)`
- **条件**: 既にアクティブ化済みの場合は処理しない

#### 8.6 HighJumper

- **タグ**: HighJumper
- **処理**: `GameStateManager.TriggerHighJump(jumpHeight, jumpSpeed, highJumperObject)`
- **コンポーネント**: HighJumperからジャンプ高さと速度を取得
- **実装**: GameCharacterManagerで垂直方向の速度を設定

#### 8.7 CameraLockArea

- **タグ**: CameraLockArea
- **処理**: エリア進入時に`GameStateManager.EnterCameraLockArea()`、退出時に`ExitCameraLockArea()`
- **コンポーネント**: CameraLockerからTrackingSetting配列を取得
- **連携**: GameCameraManagerが一時的なトラッキング設定を適用

## 処理の流れ

### 初期化フロー

1. `GameInputManager.Awake()`: Input Systemの初期化
2. `GameInputManager.OnEnable()`: Input Actionを有効化
3. `GameCharacterManager.Start()`: targetCharacterの初期化、R3イベント購読
4. `GameCharacterManager.InitializeCharacter()`: 実装タイプの自動検出

### 毎フレームの処理フロー（GameCharacterManager）

1. `Update()`:
   - ノックバック移動処理（`HandleKnockbackMovement()`）またはプレイヤー移動処理（`HandlePlayerMovement()`）
   - アニメーター更新（`UpdateAnimator()`）
   - ポストプロセッシング更新（移動速度に応じたエフェクト）

2. `FixedUpdate()`:
   - MovingPlatform追従処理（`HandlePlatformMovement()`）
   - Rigidbody実装の地面判定更新（`CheckGroundRigidbody()`）

### イベント駆動の処理フロー（R3）

1. `OnDamageReceived`: ダメージ受けた時にノックバック処理
2. `IsDead`: 死亡時にアニメーション遷移と入力無効化、リスポーン時に復帰
3. `OnHighJump`: ハイジャンプ時に垂直方向の速度設定

## 関連ファイル

- `Assets/Scripts/GameManager/GameInputManager.cs`
- `Assets/Scripts/GameManager/GameCharacterManager.cs`
- `Assets/Scripts/Character/GameCharacterCollisionTrigger.cs`
- `Assets/Scripts/Camera/CharacterTracker.cs`（カメラ方向ベクトル提供）
- `Assets/Scripts/GameManager/GameStateManager.cs`（状態管理、R3イベント）
