# 作業レポート 2025-10-15 22:04

## 変更内容の概要

- LoadVrmFromFileAsync()をUniTaskからコルーチン実装に変更しました
- 起動時のVRM読み込み（LoadVrmAndInitialize）と完全に同じ実装に揃えました
- メソッド名をLoadVrmFromFile()に変更し、戻り値の型をSystem.Collections.IEnumeratorに変更しました

## 変更理由

ユーザーの提案により、UniTaskとコルーチンの実装の違いが問題の原因である可能性が高いと判断しました。

起動時のVRM読み込み（LoadVrmAndInitialize）は正常に動作しているため、その実装を参考にLキーでの動的読み込みも同じコルーチン実装に統一することで、問題を解決できる可能性があります。

### 主な変更点

1. **非同期実行方式の変更:**
   - 変更前: `async UniTaskVoid` + `await`
   - 変更後: `IEnumerator` + `yield return`

2. **呼び出し方の変更:**
   - 変更前: `LoadVrmFromFileAsync().Forget()`
   - 変更後: `StartCoroutine(LoadVrmFromFile())`

3. **フレーム待機の変更:**
   - 変更前: `await UniTask.Yield()`
   - 変更後: `yield return null`

4. **Task待機の実装:**
   - 変更前: `await VRMUtility.LoadVrmAsync(vrmPath)`
   - 変更後: `Task<GameObject> loadTask = VRMUtility.LoadVrmAsync(vrmPath)` + `while (!loadTask.IsCompleted) { yield return null; }`

5. **エラーハンドリングの簡素化:**
   - try-catch-finallyブロックを削除
   - 起動時の読み込みと同じシンプルな構造に変更

6. **返却処理の変更:**
   - 変更前: `return`
   - 変更後: `yield break`

## 変更したファイル

### Assets/Scripts/GameManager/GameManager.cs

1. **Update() (243-246行目):**
   - `LoadVrmFromFileAsync().Forget()` → `StartCoroutine(LoadVrmFromFile())`

2. **LoadVrmFromFileAsync() → LoadVrmFromFile() (252-389行目):**
   - メソッドシグネチャを変更: `private async UniTaskVoid LoadVrmFromFileAsync()` → `private System.Collections.IEnumerator LoadVrmFromFile()`
   - `return` → `yield break`
   - `await VRMUtility.LoadVrmAsync()` → Task待機ループに変更
   - `await UniTask.Yield()` → `yield return null`
   - try-catch-finallyブロックを削除
   - isLoadingVrmのリセットを最後に移動

## 期待される効果

- 起動時のVRM読み込みと完全に同じ実行タイミングになる
- UniTaskとコルーチンの微妙な実行タイミングの違いによる問題を回避
- メッシュ位置が正しく表示される

## テスト結果

✅ **問題が改善されました！**

コルーチン実装に変更したことで、Lキーからの動的VRM読み込み時にメッシュが正しい位置に表示されるようになりました。

## UniTaskで問題が生じた原因の分析

### 1. 実行コンテキストの違い

**コルーチン（yield return null）:**
- Unityのメインスレッドで、MonoBehaviourの更新サイクルに厳密に同期して実行されます
- `yield return null`は次のフレームの**Update()の後、LateUpdate()の前**に確実に再開されます
- Animatorの更新タイミング（LateUpdate）との関係が明確です

**UniTask（await UniTask.Yield()）:**
- PlayerLoopシステムを使用して実行タイミングを制御しますが、デフォルトではPlayerLoopTiming.Updateで実行されます
- `await UniTask.Yield()`は次のフレームの開始時点で再開されますが、**厳密なタイミングはコルーチンと異なります**
- Animatorの初期化タイミングと干渉する可能性があります

### 2. AnimatorとRigidbodyの初期化タイミング

VRMキャラクターのセットアップでは以下の処理が順次実行されます：

1. VRM読み込み（RuntimeGltfInstance.ShowMeshes()を含む）
2. transform.positionの設定
3. Rigidbodyの追加と設定
4. CapsuleColliderの追加
5. AnimatorへのruntimeAnimatorControllerの設定
6. フレーム待機（コンポーネント初期化待ち）

**問題が発生したケース（UniTask）:**
- `await UniTask.Yield()`のタイミングがAnimatorやRigidbodyの初期化と微妙にずれる
- 特に、AnimatorがruntimeAnimatorControllerを適用する際の初期ポーズ設定やRoot Motion処理が、UniTaskの再開タイミングと競合
- 結果として、一瞬正しい位置に配置された後、Animatorの初期化によってメッシュ位置がずれる

**正常に動作するケース（コルーチン）:**
- `yield return null`はUnityの更新サイクルに完全に同期
- Animatorの更新（LateUpdate）の前に確実にフレーム待機が完了
- コンポーネントの初期化が完全に終わった状態で次の処理に進む

### 3. Root Motionの処理タイミング

VRMUtility.csで`animator.applyRootMotion = false`を設定していますが、これを設定する前にAnimatorControllerが一瞬でも有効になると、Root Motionが適用されてGameObjectの位置が変更される可能性があります。

UniTaskの場合、この設定とAnimatorControllerの適用の間に微妙なタイミングのずれが生じ、Root Motionが一瞬適用されてしまった可能性があります。

### 4. ShowMeshes()の呼び出しタイミング

RuntimeGltfInstanceの`ShowMeshes()`は、メッシュのワールド座標を計算して表示します。この計算がGameObjectの位置設定やAnimatorの初期化と競合すると、メッシュが意図しない位置に表示される可能性があります。

コルーチンの厳密なフレーム同期により、これらの処理が正しい順序で完了することが保証されます。

### 結論

UniTaskは高性能で便利なライブラリですが、**Unityの内部システム（Animator、Rigidbody、物理エンジン）と深く連携する処理**では、実行タイミングの微妙な違いが問題を引き起こす可能性があります。

特に以下のような処理では、コルーチンの使用を推奨します：
- Animatorの初期化を伴う処理
- 物理演算（Rigidbody）の初期化を伴う処理
- メッシュの表示/非表示を伴う処理
- GameObjectの位置設定と複雑なコンポーネント初期化を組み合わせた処理

## 備考

LoadVrmFromBytesAsync()（WebGL用）もまだUniTask実装のままです。同様の問題が発生する可能性があるため、必要に応じてコルーチンに変換することを推奨します。
