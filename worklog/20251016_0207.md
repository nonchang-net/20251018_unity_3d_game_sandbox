# 作業レポート 2025-10-16 02:07

## 変更内容の概要

- PlayableCharacterRepositoryに起動時VRM読み込み機能を追加しました
- VRMLoadManagerから起動時VRM読み込み設定を削除し、責務を明確化しました
- GameManagerの初期化処理を修正し、PlayableCharacterRepositoryの初期化完了を待つようにしました

## 変更理由

ユーザーからの報告「VrmLoadManagerの起動時VRM読み込み設定が機能しない」を受け、処理フローを整理しました。

従来の設計では、VRMLoadManagerが起動時VRM読み込みを担当していましたが、以下の問題がありました：

1. **責務の不明確性**: VRMLoadManagerは「ランタイムでのVRM読み込み」が主な責務のはずなのに、「起動時の初期キャラクター読み込み」も担当していた
2. **処理フローの複雑さ**: 起動時VRM読み込みとPlayableCharacterRepositoryの初期キャラクター登録が分離されており、どちらが先に実行されるか不明確だった
3. **機能の重複**: VRMLoadManagerとPlayableCharacterRepositoryの両方がVRM読み込み完了時にGameManager.SetActiveCharacter()を呼び出す可能性があった

ユーザーの提案「初期状態で操作用キャラクターを読み込む責務はPlayableCharacterRepositoryに持たせる」に従い、起動時VRM読み込み機能をPlayableCharacterRepositoryに移動することで、以下のメリットが得られます：

1. **責務の明確化**:
   - PlayableCharacterRepository: 「プレイ可能なキャラクターの管理」という責務の一環として、初期キャラクター（VRM含む）の読み込みと登録を担当
   - VRMLoadManager: 「ランタイムでのVRM読み込み」のみに特化

2. **処理フローの簡潔化**:
   - PlayableCharacterRepository.Start()で起動時VRM読み込み
   - VRMを読み込んだらリストの先頭に登録し、即座にGameManager.SetActiveCharacter()を呼び出す
   - GameManager.InitializeCharacter()はPlayableCharacterRepositoryの初期化完了を待ってから、必要に応じて最初のキャラクターを設定

3. **データの一貫性**:
   - 起動時VRMは常にリストの先頭（インデックス0）に配置される
   - GameManagerは「リストの先頭のキャラクター = デフォルトのアクティブキャラクター」という明確なルールで動作

## 変更したファイル

### 変更: Assets/Scripts/Character/PlayableCharacterRepository.cs

起動時VRM読み込み機能を追加しました。

**追加したusingディレクティブ:**
```csharp
using System.Collections;  // コルーチン用
using System.IO;           // ファイル操作用
```

**追加したフィールド:**
```csharp
[Header("起動時VRM読み込み設定")]
[Tooltip("起動時にデフォルトのVRMキャラクターを読み込む")]
[SerializeField] private bool loadStartupVrmCharacter = false;

[Tooltip("StreamingAssets内のVRMファイル名")]
[SerializeField] private string startupVrmFileName = "AliciaSolid.vrm";

[Header("VRM設定")]
[Tooltip("VRMキャラクターのデフォルトスポーン地点")]
[SerializeField] private Transform defaultSpawnPoint;

[Tooltip("VRMキャラクターに適用するアニメーションコントローラー")]
[SerializeField] private RuntimeAnimatorController vrmAnimatorController;

[Tooltip("コイン獲得時の効果音")]
[SerializeField] private AudioClip coinCollectSound;

[Header("デバッグ設定")]
[Tooltip("詳細ログを表示する")]
[SerializeField] private bool enableVerboseLog = false;

private GameManager gameManager;
private bool isInitialized = false;
```

**追加したメソッド:**

1. **Start() (77-89行目):**
   ```csharp
   void Start()
   {
       // 起動時VRM読み込みが有効な場合
       if (loadStartupVrmCharacter)
       {
           StartCoroutine(LoadStartupVrmCharacter());
       }
       else
       {
           // 起動時VRM読み込みがない場合は即座に初期化完了
           isInitialized = true;
       }
   }
   ```

2. **LoadStartupVrmCharacter() (91-147行目):**
   ```csharp
   private IEnumerator LoadStartupVrmCharacter()
   {
       // VRMUtilityの詳細ログを設定
       VRMUtility.EnableVerboseLog = enableVerboseLog;

       // StreamingAssetsからVRMファイルのパスを構築
       string vrmPath = Path.Combine(Application.streamingAssetsPath, startupVrmFileName);

       if (!File.Exists(vrmPath))
       {
           Debug.LogError($"PlayableCharacterRepository: VRMファイルが見つかりません: {vrmPath}");
           isInitialized = true;
           yield break;
       }

       // スポーン位置を決定
       Vector3 spawnPosition = defaultSpawnPoint != null ? defaultSpawnPoint.position : Vector3.zero;

       // VRMを読み込んでセットアップ
       yield return VRMUtility.LoadAndSetupVrmFromPath(
           vrmPath,
           spawnPosition,
           vrmAnimatorController,
           coinCollectSound,
           onComplete: (vrmCharacter) =>
           {
               // リストの先頭に登録
               RegisterCharacterAtFront(vrmCharacter);

               // GameManagerのアクティブキャラクターに設定
               if (gameManager != null)
               {
                   gameManager.SetActiveCharacter(vrmCharacter);
               }

               isInitialized = true;
           },
           onError: (errorMessage) =>
           {
               Debug.LogError($"PlayableCharacterRepository: 起動時VRM読み込みエラー: {errorMessage}");
               isInitialized = true;
           }
       );
   }
   ```

3. **IsInitialized() (149-155行目):**
   ```csharp
   public bool IsInitialized()
   {
       return isInitialized;
   }
   ```

4. **RegisterCharacterAtFront() (181-203行目):**
   ```csharp
   public bool RegisterCharacterAtFront(GameObject character)
   {
       if (character == null)
       {
           Debug.LogWarning("PlayableCharacterRepository: 登録しようとしたキャラクターがnullです。");
           return false;
       }

       if (registeredCharacters.Contains(character))
       {
           Debug.LogWarning($"PlayableCharacterRepository: キャラクター '{character.name}' は既に登録されています。");
           return false;
       }

       registeredCharacters.Insert(0, character);
       Debug.Log($"PlayableCharacterRepository: キャラクター '{character.name}' をリストの先頭に登録しました。（現在の登録数: {registeredCharacters.Count}）");
       return true;
   }
   ```

**更新したAwake():**
- GameManagerの自動検出を追加（起動時VRM読み込み完了時にアクティブキャラクターを設定するため）

### 変更: Assets/Scripts/Utilities/VRMLoadManager.cs

起動時VRM読み込み設定を削除し、ランタイムVRM読み込みのみに特化しました。

**削除したフィールド:**
```csharp
// 削除
[Header("起動時VRM読み込み設定")]
[Tooltip("起動時にVRMファイルを読み込んでテストする")]
[SerializeField] private bool enableVrmLoadTest;

[Tooltip("StreamingAssets内のVRMファイル名")]
[SerializeField] private string vrmFileName = "AliciaSolid.vrm";
```

**削除したメソッド:**
```csharp
// 削除
void Start()
{
    if (enableVrmLoadTest)
    {
        StartCoroutine(LoadVrmFromStreamingAssets());
    }
}

public IEnumerator LoadVrmFromStreamingAssets()
{
    // ... VRM読み込み処理
}
```

**責務の変化:**
- **変更前**: 起動時VRM読み込み + ランタイムVRM読み込み
- **変更後**: ランタイムVRM読み込みのみ（Lキーでのファイル選択、WebGLダウンロードなど）

### 変更: Assets/Scripts/GameManager/GameManager.cs

PlayableCharacterRepositoryの初期化完了を待つように修正しました。

**更新したInitializeCharacter() (87-111行目):**
```csharp
private System.Collections.IEnumerator InitializeCharacter()
{
    // 1フレーム待機してキャラクターの初期化を確実に完了させる
    yield return null;

    // PlayableCharacterRepositoryの初期化完了を待つ
    if (characterRepository != null)
    {
        while (!characterRepository.IsInitialized())
        {
            yield return null;
        }

        // リポジトリから最初のキャラクターを取得してアクティブに設定
        // （起動時VRM読み込みがある場合は既にSetActiveCharacterされているが、ない場合はここで設定）
        if (characterRepository.GetCharacterCount() > 0)
        {
            GameObject firstCharacter = characterRepository.GetCharacterAt(0);
            if (firstCharacter != null && GetActiveCharacter() == null)
            {
                SetActiveCharacter(firstCharacter);
            }
        }
    }
}
```

**重要な変更点:**

1. **初期化完了待機ループ:**
   ```csharp
   while (!characterRepository.IsInitialized())
   {
       yield return null;
   }
   ```
   PlayableCharacterRepositoryの起動時VRM読み込みが完了するまで待機します。

2. **二重設定の防止:**
   ```csharp
   if (firstCharacter != null && GetActiveCharacter() == null)
   {
       SetActiveCharacter(firstCharacter);
   }
   ```
   起動時VRM読み込みが有効な場合、PlayableCharacterRepositoryが既にSetActiveCharacter()を呼び出しているため、GetActiveCharacter() == nullの場合のみ設定します。

## 処理フローの整理

### 起動時VRM読み込みが有効な場合

```
1. PlayableCharacterRepository.Awake()
   - initialCharactersを登録（もしあれば）
   - GameManagerの自動検出

2. PlayableCharacterRepository.Start()
   - LoadStartupVrmCharacter()を開始

3. GameManager.Start()
   - InitializeCharacter()を開始

4. GameManager.InitializeCharacter()
   - PlayableCharacterRepository.IsInitialized()がtrueになるまで待機

5. PlayableCharacterRepository.LoadStartupVrmCharacter()
   - VRMUtility.LoadAndSetupVrmFromPath()でVRM読み込み
   - 成功時:
     - RegisterCharacterAtFront(vrmCharacter)でリストの先頭に登録
     - gameManager.SetActiveCharacter(vrmCharacter)でアクティブに設定
     - isInitialized = trueに設定

6. GameManager.InitializeCharacter()（再開）
   - characterRepository.IsInitialized()がtrueになったので続行
   - GetActiveCharacter() != nullなので、SetActiveCharacter()はスキップ
   - 初期化完了
```

### 起動時VRM読み込みが無効な場合

```
1. PlayableCharacterRepository.Awake()
   - initialCharactersを登録

2. PlayableCharacterRepository.Start()
   - loadStartupVrmCharacter == falseなので即座にisInitialized = true

3. GameManager.Start()
   - InitializeCharacter()を開始

4. GameManager.InitializeCharacter()
   - PlayableCharacterRepository.IsInitialized()が既にtrueなので即座に続行
   - GetActiveCharacter() == nullなので、リストの先頭キャラクターを設定
   - 初期化完了
```

## 設計の利点

### 1. 責務の明確化

**PlayableCharacterRepository:**
- 「プレイ可能なキャラクターの管理」という単一の責務に集中
- 初期キャラクター（ヒエラルキー上のGameObject）も起動時VRMも、どちらも「初期状態で利用可能なキャラクター」として統一的に管理

**VRMLoadManager:**
- 「ランタイムでのVRM読み込み」のみに特化
- ユーザー操作（Lキー、ファイル選択、WebGLダウンロード）に応じたVRM読み込みのみを担当

### 2. データの一貫性

**起動時VRMは常にリストの先頭:**
- `RegisterCharacterAtFront()`により、起動時VRMはインデックス0に配置される
- GameManagerは「リストの先頭 = デフォルトのアクティブキャラクター」という明確なルールで動作

**初期化フラグによる同期:**
- `isInitialized`フラグにより、PlayableCharacterRepositoryの初期化完了を他のコンポーネントが確実に待機できる

### 3. 拡張性の向上

**複数の初期化方法に対応可能:**
- initialCharacters（ヒエラルキー上のGameObject）
- loadStartupVrmCharacter（StreamingAssetsからのVRM）
- 将来的には: LoadFromAssetBundle、LoadFromAddressablesなど

**設定の柔軟性:**
- `loadStartupVrmCharacter`をfalseにすれば、起動時VRM読み込みをスキップ
- `initialCharacters`が空で`loadStartupVrmCharacter`がtrueなら、VRMのみを使用
- 両方を組み合わせることも可能

## 使用方法

### PlayableCharacterRepositoryの設定

ヒエラルキーのPlayableCharacterRepositoryコンポーネントで以下を設定します：

```
PlayableCharacterRepository:
  - Initial Characters: (ヒエラルキー上のキャラクターを配列で指定)

  起動時VRM読み込み設定:
  - Load Startup Vrm Character: true/false
  - Startup Vrm File Name: "AliciaSolid.vrm"

  VRM設定:
  - Default Spawn Point: (Transform参照)
  - Vrm Animator Controller: (RuntimeAnimatorController参照)
  - Coin Collect Sound: (AudioClip参照)

  デバッグ設定:
  - Enable Verbose Log: false
```

### 典型的な使用例

**ケース1: 起動時にVRMキャラクターを読み込む**
```
Load Startup Vrm Character: true
Startup Vrm File Name: "AliciaSolid.vrm"
Initial Characters: (空)
```
→ 起動時にVRMを読み込み、リストの先頭に登録され、自動的にアクティブキャラクターになる

**ケース2: ヒエラルキー上のキャラクターのみを使用**
```
Load Startup Vrm Character: false
Initial Characters: [Character1, Character2, Character3]
```
→ Character1が自動的にアクティブキャラクターになる

**ケース3: VRMとヒエラルキーキャラクターを混在**
```
Load Startup Vrm Character: true
Startup Vrm File Name: "AliciaSolid.vrm"
Initial Characters: [Character1, Character2]
```
→ VRMがリストの先頭（インデックス0）、Character1がインデックス1、Character2がインデックス2になる

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- PlayableCharacterRepositoryが「キャラクター管理」の責務を完全に担うようになりました
- VRMLoadManagerはランタイムVRM読み込みのみに特化し、シンプルになりました
- GameManagerは初期化処理がより明確になり、PlayableCharacterRepositoryの初期化完了を確実に待つようになりました
- 起動時VRMはリストの先頭に配置されるため、キャラクター切り替え時の順序が明確です
- すべての処理はコルーチンベースで実装されており、Animator/Rigidbody初期化との正確なタイミング同期を実現しています
