# 作業レポート 2025-10-16 12:20

## 変更内容の概要

- R3のReactive PropertyとSubjectを使用したダメージシステムを実装しました
- UserDataManagerにダメージ処理とDamageInfoを通知するSubjectを追加しました
- GameCharacterCollisionTriggerにDamageSourceタグとの衝突検知を追加しました
- GameUIManagerでダメージイベントを購読し、デバッグログ出力を実装しました

## 変更理由

フィールドにダメージを受けるオブジェクト（Spike）を配置し、DamageSourceタグを持つオブジェクトとの衝突でダメージシステムを動作させる必要がありました。

ダメージ処理は複数のコンポーネントにまたがる処理（HP管理、UI表示、効果音、アニメーションなど）が予見されるため、R3のReactive Propertyを使用したイベント駆動アーキテクチャで実装しました。

これにより、以下のメリットが得られます：

1. **疎結合**: UserDataManagerとGameUIManagerが直接依存しない
2. **拡張性**: 新しい購読者（例: ダメージ効果音、画面エフェクト、アニメーション）を容易に追加可能
3. **データフローの明確化**: HP変動とダメージイベントを分離し、それぞれ独立して購読可能
4. **責務の明確化**: UserDataManagerはデータ管理、GameCharacterCollisionTriggerは衝突検知、GameUIManagerはUI表示のみを担当

## 変更したファイル

### 新規追加: DamageInfo構造体

**Assets/Scripts/UserData/UserDataManager.cs (5-25行目):**

```csharp
/// <summary>
/// ダメージ情報
/// </summary>
public readonly struct DamageInfo
{
    /// <summary>ダメージ量</summary>
    public readonly int Damage;

    /// <summary>ダメージソース（どのオブジェクトから受けたか）</summary>
    public readonly GameObject Source;

    /// <summary>ダメージ後の現在HP</summary>
    public readonly int CurrentHp;

    public DamageInfo(int damage, GameObject source, int currentHp)
    {
        Damage = damage;
        Source = source;
        CurrentHp = currentHp;
    }
}
```

**設計の特徴:**
- **readonly struct**: 不変な値型として実装し、パフォーマンスとスレッドセーフティを確保
- **ダメージ量**: どれだけダメージを受けたか
- **ダメージソース**: どのGameObjectから受けたか（Spike、敵、罠など）
- **ダメージ後HP**: ダメージ処理後の現在HP（購読者が即座に状態を把握できる）

### 変更: Assets/Scripts/UserData/UserDataManager.cs

**追加したメソッド (46-70行目):**

```csharp
/// <summary>
/// ダメージを受ける処理
/// </summary>
/// <param name="damage">ダメージ量</param>
/// <param name="damageSource">ダメージソース（GameObject）</param>
public static void TakeDamage(int damage, GameObject damageSource)
{
    if (userData.IsDead.CurrentValue)
    {
        // 既に死亡している場合は何もしない
        return;
    }

    // HPを減らす
    int newHp = Mathf.Max(0, userData.CurrentHp.CurrentValue - damage);
    userData.CurrentHp.Value = newHp;

    // ダメージイベントを発火
    userData.OnDamageReceived.OnNext(new DamageInfo(damage, damageSource, newHp));

    if (userData.IsDead.CurrentValue)
    {
        Debug.Log("UserDataManager: キャラクターが死亡しました。");
    }
}
```

**処理の流れ:**
1. **死亡チェック**: 既に死亡している場合は何もしない（連続ダメージ防止）
2. **HP減少**: CurrentHpを減らす（最小値0）
3. **イベント発火**: OnDamageReceived.OnNext()でダメージ情報を通知
4. **死亡判定**: HP <= 0になった場合、死亡ログを出力

**UserDataクラスへの追加 (84-96行目):**

```csharp
/// <summary>
/// ダメージを受けたときに発火するSubject
/// ダメージ量、ダメージソース、ダメージ後のHPを通知
/// </summary>
public Subject<DamageInfo> OnDamageReceived { get; private set; }

public UserData(int initialHp)
{
    CurrentCoin = new ReactiveProperty<int>(0);
    CurrentHp = new ReactiveProperty<int>(initialHp);
    MaxHp = new ReactiveProperty<int>(initialHp);
    IsDead = CurrentHp.Select(x => x <= 0).ToReadOnlyReactiveProperty();
    OnDamageReceived = new Subject<DamageInfo>();
}
```

**設計のポイント:**
- **Subject<DamageInfo>**: ダメージイベント専用のSubject
- **CurrentHpとの分離**: HP変動（CurrentHp.Subscribe）とダメージイベント（OnDamageReceived.Subscribe）を独立して購読可能
  - 例: HP回復時はCurrentHpのみ変動、OnDamageReceivedは発火しない
  - 例: ダメージ効果音はOnDamageReceivedのみ購読すればよい

### 変更: Assets/Scripts/Character/GameCharacterCollisionTrigger.cs

**追加した設定項目 (15-17行目):**

```csharp
[Header("ダメージ設定")]
[Tooltip("DamageSourceタグのオブジェクトから受けるダメージ量")]
[SerializeField] private int damageAmount = 1;
```

**更新したOnTriggerEnter() (35-49行目):**

```csharp
void OnTriggerEnter(Collider other)
{
    // コインタグのオブジェクトに触れたかチェック
    if (other.CompareTag("Coin"))
    {
        CollectCoin(other.gameObject);
    }
    // ダメージソースタグのオブジェクトに触れたかチェック
    else if (other.CompareTag("DamageSource"))
    {
        TakeDamageFromSource(other.gameObject);
    }
}
```

**追加したTakeDamageFromSource() (84-92行目):**

```csharp
/// <summary>
/// ダメージソースからダメージを受ける処理
/// </summary>
/// <param name="damageSource">ダメージソースのGameObject</param>
void TakeDamageFromSource(GameObject damageSource)
{
    // UserDataManagerのダメージ処理を呼び出す
    UserDataManager.TakeDamage(damageAmount, damageSource);
}
```

**責務の明確化:**
- **GameCharacterCollisionTrigger**: 衝突検知のみを担当
- **UserDataManager**: データ管理とイベント発火を担当

### 変更: Assets/Scripts/GameManager/GameUIManager.cs

**追加したダメージイベント購読 (44-51行目):**

```csharp
// ダメージイベント購読
var damageSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    Debug.Log($"GameUIManager: ダメージを受けました！ " +
              $"ダメージ量: {damageInfo.Damage}, " +
              $"ソース: {damageInfo.Source.name}, " +
              $"残りHP: {damageInfo.CurrentHp}");
});

disposable = Disposable.Combine(coinSubscriber, damageSubscriber);
```

**購読の管理:**
- **Disposable.Combine()**: 複数の購読を一括管理
- **OnDestroy()**: コンポーネント破棄時に自動的にDispose()され、メモリリーク防止

**出力例:**
```
GameUIManager: ダメージを受けました！ ダメージ量: 1, ソース: Spike, 残りHP: 2
GameUIManager: ダメージを受けました！ ダメージ量: 1, ソース: Spike, 残りHP: 1
GameUIManager: ダメージを受けました！ ダメージ量: 1, ソース: Spike, 残りHP: 0
UserDataManager: キャラクターが死亡しました。
```

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがDamageSourceタグのオブジェクト（Spike）に衝突
   ↓
2. GameCharacterCollisionTrigger.OnTriggerEnter()
   - DamageSourceタグを検知
   ↓
3. GameCharacterCollisionTrigger.TakeDamageFromSource()
   - UserDataManager.TakeDamage()を呼び出す
   ↓
4. UserDataManager.TakeDamage()
   - CurrentHp.Valueを減らす
   - OnDamageReceived.OnNext(DamageInfo)を発火
   ↓
5. 購読者（GameUIManager等）がイベントを受信
   - ダメージ量、ダメージソース、残りHPを取得
   - UI表示、効果音、アニメーションなどを実行
```

### R3 Reactive Propertyの使い分け

**CurrentHp (ReactiveProperty<int>):**
- 用途: HP値の変動を監視
- 購読例: HP表示UI、HPバー
- HP回復時も発火する

**OnDamageReceived (Subject<DamageInfo>):**
- 用途: ダメージを受けたイベントのみを監視
- 購読例: ダメージ効果音、画面フラッシュ、ダメージアニメーション
- HP回復時は発火しない

**IsDead (ReadOnlyReactiveProperty<bool>):**
- 用途: 死亡状態を監視
- 購読例: ゲームオーバー画面、リスポーン処理
- CurrentHpから自動的に導出される

### 拡張性の高い設計

この設計により、以下の機能を容易に追加できます：

**購読者の追加例:**

```csharp
// ダメージ効果音を再生する購読者
var damageSoundSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    audioSource.PlayOneShot(damageSound);
});

// 画面フラッシュエフェクトを表示する購読者
var damageFlashSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    StartCoroutine(FlashScreen(Color.red, 0.1f));
});

// ダメージアニメーションを再生する購読者
var damageAnimationSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    animator.SetTrigger("Damage");
});

// ダメージソースに応じて異なる処理
var damageTypeSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    if (damageInfo.Source.CompareTag("Fire"))
    {
        ApplyBurnEffect();
    }
    else if (damageInfo.Source.CompareTag("Poison"))
    {
        ApplyPoisonEffect();
    }
});
```

**ダメージソースの拡張例:**

DamageSourceタグを持つオブジェクトを配置するだけで、自動的にダメージシステムが動作します：

- **Spike**: 棘による物理ダメージ
- **Fire**: 炎による継続ダメージ
- **Poison**: 毒による継続ダメージ
- **Enemy**: 敵キャラクターからの攻撃

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- R3のReactive PropertyとSubjectを初めて本格的に使用しました
- DamageInfoをreadonly structとして実装し、不変性を確保しました
- HP変動とダメージイベントを分離することで、柔軟な購読が可能になりました
- GameCharacterCollisionTriggerは衝突検知のみを担当し、データ処理はUserDataManagerに委譲しました
- GameUIManagerは購読のみを行い、UserDataManagerの実装詳細を知る必要がありません
- すべての購読はDisposable.Combine()で一括管理され、OnDestroy()で自動的に解放されます
- ダメージソースの種類を増やす際は、DamageSourceタグを持つオブジェクトを配置するだけで動作します
- 将来的には、DamageInfoにダメージタイプ（物理、炎、毒など）を追加することで、さらに詳細な処理が可能になります
