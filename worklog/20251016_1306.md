# 作業レポート 2025-10-16 13:06（更新: 13:30）

## 変更内容の概要

- GameInputManagerにダメージイベント購読を追加しました
- ダメージを受けたときにノックバックアニメーション（isKnockbackフラグ）を遷移させる処理を実装しました
- ノックバック中は視点制御以外の入力を無効化する処理を実装しました
- **（追加）ノックバック時にキャラクターを衝突方向の反対に弾け飛ばす処理を実装しました**
- **（追加）ノックバック移動距離と速度をInspectorから設定可能にしました**
- **（追加）ノックバック移動処理自体をオン/オフできるようにしました**

## 変更理由

ダメージを受けたときにノックバックモーションを再生し、その間プレイヤーの入力を無効化する必要がありました。

さらに、ノックバック時にキャラクターを実際に移動させて「弾け飛ぶ」演出を追加する必要がありました。ダメージソースとの接触角度の反対方向へ飛ぶようにすることで、物理的に自然な動きを実現しました。

入力操作に関わる処理であり、GameInputManagerが入力管理の責務を持っているため、ノックバック処理もGameInputManager上で実装しました。

R3のReactive Propertyを使用することで、UserDataManagerのダメージイベント（OnDamageReceived）を購読し、疎結合な設計を維持しながらノックバック処理を実装できました。

## 変更したファイル

### 変更: Assets/Scripts/GameManager/GameInputManager.cs

**追加したusingディレクティブ (2行目):**

```csharp
using R3;
```

**追加したフィールド (75-79行目):**

```csharp
// ノックバック関連
private bool isKnockback = false;

// R3購読管理
private IDisposable damageSubscription;
```

**設計の特徴:**
- **isKnockback**: ノックバック中かどうかを示すフラグ
- **damageSubscription**: R3購読のDisposable（OnDestroy()で解放）

**更新したStart() (121-122行目):**

```csharp
// ダメージイベントを購読
SubscribeDamageEvents();
```

Start()の最後でダメージイベントの購読を開始します。

**更新したHandlePlayerMovement() (217-221行目):**

```csharp
// ノックバック中は入力を無効化（視点制御はCharacterTrackerが独立して動作）
if (isKnockback)
{
    return;
}
```

**重要な設計ポイント:**
- ノックバック中は**移動・ジャンプ・しゃがみなどの入力を無効化**
- **視点制御（カメラ操作）は無効化しない**
  - CharacterTrackerが独立して動作するため、マウス/右スティックでカメラを動かせる
  - ノックバック中でも周囲を見回せるため、ユーザー体験が向上

**追加したSubscribeDamageEvents() (566-575行目):**

```csharp
/// <summary>
/// ダメージイベントを購読
/// </summary>
void SubscribeDamageEvents()
{
    damageSubscription = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
    {
        OnDamageReceived(damageInfo);
    });
}
```

UserDataManager.Data.OnDamageReceivedを購読し、ダメージを受けたときにOnDamageReceived()を呼び出します。

**追加したOnDamageReceived() (577-596行目):**

```csharp
/// <summary>
/// ダメージを受けたときの処理
/// </summary>
void OnDamageReceived(DamageInfo damageInfo)
{
    if (EnableVerboseLog)
    {
        Debug.Log($"GameInputManager: ダメージを受けました。ノックバックアニメーション開始。");
    }

    // ノックバックアニメーション遷移
    if (animator != null && animator.runtimeAnimatorController != null && animator.isInitialized)
    {
        animator.SetBool("isKnockback", true);
        isKnockback = true;

        // ノックバックアニメーション終了後に状態をリセット
        StartCoroutine(ResetKnockbackAfterDelay(0.5f));
    }
}
```

**処理の流れ:**
1. **詳細ログ出力**: EnableVerboseLogがtrueの場合、ノックバック開始をログ出力
2. **Animatorチェック**: AnimatorControllerが割り当てられており、初期化済みかを確認
3. **ノックバックフラグ設定**: animator.SetBool("isKnockback", true)でアニメーション遷移
4. **入力無効化フラグ設定**: isKnockback = trueで入力を無効化
5. **リセットコルーチン開始**: 0.5秒後にノックバック状態をリセット

**追加したResetKnockbackAfterDelay() (598-616行目):**

```csharp
/// <summary>
/// ノックバック状態を一定時間後にリセット
/// </summary>
System.Collections.IEnumerator ResetKnockbackAfterDelay(float delay)
{
    yield return new WaitForSeconds(delay);

    if (animator != null && animator.runtimeAnimatorController != null && animator.isInitialized)
    {
        animator.SetBool("isKnockback", false);
    }

    isKnockback = false;

    if (EnableVerboseLog)
    {
        Debug.Log($"GameInputManager: ノックバック終了。");
    }
}
```

**処理の流れ:**
1. **待機**: WaitForSeconds(0.5f)で0.5秒待機
2. **ノックバックフラグ解除**: animator.SetBool("isKnockback", false)でアニメーション遷移
3. **入力有効化**: isKnockback = falseで入力を再度有効化
4. **詳細ログ出力**: EnableVerboseLogがtrueの場合、ノックバック終了をログ出力

**ノックバック時間の調整:**
- 現在は0.5秒でハードコーディング
- 将来的には[SerializeField]でInspectorから調整可能にすることも検討

**追加したOnDestroy() (618-622行目):**

```csharp
void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
}
```

コンポーネント破棄時にR3購読を解放し、メモリリークを防止します。

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがDamageSourceタグのオブジェクト（Spike）に衝突
   ↓
2. GameCharacterCollisionTrigger.OnTriggerEnter()
   - DamageSourceタグを検知
   ↓
3. GameCharacterCollisionTrigger.TakeDamageFromSource()
   - UserDataManager.TakeDamage()を呼び出す
   ↓
4. UserDataManager.TakeDamage()
   - CurrentHp.Valueを減らす
   - OnDamageReceived.OnNext(DamageInfo)を発火
   ↓
5. 購読者（GameInputManager、GameUIManager等）がイベントを受信
   ↓
6. GameInputManager.OnDamageReceived()
   - animator.SetBool("isKnockback", true)
   - isKnockback = true（入力無効化）
   - ResetKnockbackAfterDelay(0.5f)コルーチン開始
   ↓
7. 0.5秒後にGameInputManager.ResetKnockbackAfterDelay()
   - animator.SetBool("isKnockback", false)
   - isKnockback = false（入力有効化）
```

### 入力無効化の詳細

**無効化される入力:**
- WASD / 左スティック（移動）
- Shiftキー / 左トリガー（ダッシュ）
- Spaceキー / Aボタン（ジャンプ）
- Ctrlキー / Bボタン（しゃがみ）

**無効化されない入力:**
- マウス移動 / 右スティック（視点制御）
  - CharacterTrackerが独立して動作
  - ノックバック中でもカメラを動かせる

**実装箇所:**
```csharp
void HandlePlayerMovement()
{
    // ノックバック中は入力を無効化
    if (isKnockback)
    {
        return; // ここで処理を中断
    }

    // 通常の入力処理
    if (implementationType == CharacterImplementationType.CharacterController)
    {
        HandleMovementCharacterController();
    }
    else if (implementationType == CharacterImplementationType.RigidbodyAndCollider)
    {
        HandleMovementRigidbody();
    }
}
```

### Animatorとの連携

**Animator側の設定要件:**
- **isKnockbackパラメータ**: Bool型のパラメータを追加
- **ノックバックアニメーション**: isKnockbackがtrueのときに遷移するアニメーション

**Transition設定例:**
```
Any State → Knockback
  Conditions: isKnockback == true
  Exit Time: false
  Fixed Duration: 0.1s

Knockback → Idle
  Conditions: isKnockback == false
  Exit Time: true (アニメーション終了時)
  Fixed Duration: 0.2s
```

### R3 Reactive Propertyの活用

**UserDataManager.Data.OnDamageReceived:**
- 型: Subject<DamageInfo>
- 発火タイミング: ダメージを受けたとき
- 通知内容: DamageInfo（ダメージ量、ダメージソース、残りHP）

**購読者:**
1. **GameUIManager**: UI表示更新、デバッグログ出力
2. **GameInputManager**: ノックバックアニメーション遷移、入力無効化（今回実装）
3. **将来的な拡張**: ダメージ効果音、画面フラッシュ、パーティクルエフェクトなど

**メモリ管理:**
- OnDestroy()でdamageSubscription.Dispose()を呼び出し、購読を解放
- メモリリークを防止

## 設計の利点

### 1. 疎結合な設計

**GameInputManager ←→ UserDataManager:**
- 直接依存せず、R3のSubjectを介して通信
- UserDataManagerの実装詳細をGameInputManagerが知る必要がない

### 2. 拡張性の高い設計

**新しい購読者の追加が容易:**
```csharp
// 例: ダメージ効果音を再生する購読者
var damageSoundSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    audioSource.PlayOneShot(damageSound);
});

// 例: 画面フラッシュエフェクト
var damageFlashSubscriber = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
{
    StartCoroutine(FlashScreen(Color.red, 0.1f));
});
```

### 3. 視点制御の独立性

**ノックバック中でもカメラ操作可能:**
- CharacterTrackerが独立して動作
- プレイヤーは周囲を見回せる
- ユーザー体験の向上

### 4. タイミング制御の柔軟性

**ノックバック時間の調整:**
- 現在は0.5秒でハードコーディング
- 将来的にはInspectorから調整可能にできる

**アニメーション同期:**
- コルーチンによる時間管理
- Animatorのアニメーション長と独立して調整可能

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## ノックバック移動機能の追加（13:30更新）

### 追加した設定フィールド (38-46行目)

```csharp
[Header("ノックバック設定")]
[Tooltip("ノックバック時にキャラクターを弾け飛ばす")]
[SerializeField] private bool enableKnockbackMovement = true;

[Tooltip("ノックバック時の移動距離")]
[SerializeField] private float knockbackDistance = 2f;

[Tooltip("ノックバック移動の速度")]
[SerializeField] private float knockbackSpeed = 10f;
```

**設定可能なパラメータ:**
- **enableKnockbackMovement**: ノックバック移動のオン/オフ（デフォルト: true）
- **knockbackDistance**: 弾け飛ぶ距離（デフォルト: 2m）
- **knockbackSpeed**: 移動速度（デフォルト: 10）

### 追加した内部フィールド (86-91行目)

```csharp
// ノックバック関連
private bool isKnockback = false;
private Vector3 knockbackDirection = Vector3.zero;
private float knockbackProgress = 0f;
private Vector3 knockbackStartPosition = Vector3.zero;
private Vector3 knockbackTargetPosition = Vector3.zero;
```

**ノックバック移動の状態管理:**
- **knockbackDirection**: ノックバック方向（正規化済みベクトル）
- **knockbackProgress**: 移動の進行度（0.0 → 1.0）
- **knockbackStartPosition**: 移動開始位置
- **knockbackTargetPosition**: 移動目標位置

### 更新したOnDamageReceived() (608-630行目)

```csharp
// ノックバック移動が有効な場合、方向を計算
if (enableKnockbackMovement && damageInfo.Source != null && targetCharacter != null)
{
    // ダメージソースからキャラクターへの方向を計算
    Vector3 damageSourcePosition = damageInfo.Source.transform.position;
    Vector3 characterPosition = targetCharacter.transform.position;

    // Y軸を無視した水平方向のみで計算（キャラクターが空中に飛ばないように）
    damageSourcePosition.y = characterPosition.y;

    // ダメージソースからキャラクターへの方向（ノックバック方向）
    knockbackDirection = (characterPosition - damageSourcePosition).normalized;

    // ノックバック開始位置と目標位置を設定
    knockbackStartPosition = targetCharacter.transform.position;
    knockbackTargetPosition = knockbackStartPosition + knockbackDirection * knockbackDistance;
    knockbackProgress = 0f;

    if (EnableVerboseLog)
    {
        Debug.Log($"GameInputManager: ノックバック方向: {knockbackDirection}, 距離: {knockbackDistance}");
    }
}
```

**ノックバック方向の計算:**
1. **ダメージソース位置を取得**: damageInfo.Source.transform.position
2. **キャラクター位置を取得**: targetCharacter.transform.position
3. **Y軸を揃える**: キャラクターが空中に飛ばないように水平方向のみで計算
4. **方向ベクトルを計算**: (キャラクター位置 - ダメージソース位置).normalized
5. **目標位置を計算**: 開始位置 + 方向 * 距離

### 追加したUpdate()処理 (213-217行目)

```csharp
// ノックバック移動処理（入力処理より優先）
if (isKnockback && enableKnockbackMovement)
{
    HandleKnockbackMovement();
}
```

ノックバック中は通常の入力処理より先にノックバック移動を処理します。

### 追加したHandleKnockbackMovement() (643-673行目)

```csharp
/// <summary>
/// ノックバック移動処理
/// CharacterControllerとRigidbody両方に対応
/// </summary>
void HandleKnockbackMovement()
{
    // 進行度を更新（0.0 → 1.0）
    knockbackProgress += Time.deltaTime * knockbackSpeed;

    if (knockbackProgress >= 1f)
    {
        // ノックバック移動完了
        knockbackProgress = 1f;
    }

    // Lerpで滑らかに移動
    Vector3 currentTargetPosition = Vector3.Lerp(knockbackStartPosition, knockbackTargetPosition, knockbackProgress);

    // 実装タイプに応じて移動処理を分岐
    if (implementationType == CharacterImplementationType.CharacterController && characterController != null)
    {
        // CharacterController: Move()で移動
        Vector3 movement = currentTargetPosition - targetCharacter.transform.position;
        characterController.Move(movement);
    }
    else if (implementationType == CharacterImplementationType.RigidbodyAndCollider && rigidbody != null)
    {
        // Rigidbody: MovePosition()で移動
        rigidbody.MovePosition(currentTargetPosition);
    }
}
```

**処理の流れ:**
1. **進行度を更新**: knockbackProgress += Time.deltaTime * knockbackSpeed
2. **進行度を0.0 → 1.0にクランプ**
3. **Lerpで滑らかに補間**: Vector3.Lerp(開始位置, 目標位置, progress)
4. **実装タイプに応じて移動**:
   - **CharacterController**: Move()で移動差分を適用
   - **Rigidbody**: MovePosition()で目標位置に移動

**CharacterControllerとRigidbody両対応:**
- CharacterController実装とRigidbody実装の両方で正しく動作
- GameInputManagerの既存の実装タイプ判定を活用

### ノックバック移動の特徴

**物理的に自然な動き:**
- ダメージソースとの接触角度の反対方向に飛ぶ
- Y軸を無視して水平方向のみで移動（空中に飛ばない）

**滑らかな移動:**
- Vector3.Lerpによる補間で滑らかに移動
- knockbackSpeedで移動速度を調整可能

**Inspector設定可能:**
- enableKnockbackMovement: オン/オフ切り替え
- knockbackDistance: 移動距離
- knockbackSpeed: 移動速度

**CharacterController/Rigidbody両対応:**
- CharacterController: Move()で移動差分を適用
- Rigidbody: MovePosition()で物理演算に従って移動

## 備考

- R3のSubjectを使用してダメージイベントを購読し、ノックバック処理を実装しました
- ノックバック中は移動・ジャンプ・しゃがみなどの入力を無効化しますが、視点制御は有効のままです
- CharacterTrackerが独立して動作するため、ノックバック中でもカメラを動かせます
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- Animator側で「isKnockback」Boolパラメータを追加し、ノックバックアニメーションへの遷移を設定する必要があります
- ノックバック時間は現在0.5秒ですが、将来的にはInspectorから調整可能にすることも検討できます
- GameInputManagerが入力管理の責務を持つため、ノックバック処理も自然にこのクラスに配置されました
- ダメージシステム全体がイベント駆動アーキテクチャで設計されており、新しい機能の追加が容易です
- **（追加）ノックバック時にキャラクターを衝突方向の反対に弾け飛ばす処理を実装しました**
- **（追加）ノックバック移動距離（knockbackDistance）と速度（knockbackSpeed）をInspectorから設定可能にしました**
- **（追加）ノックバック移動処理自体をenableKnockbackMovementでオン/オフできるようにしました**
- **（追加）CharacterControllerとRigidbody両方の実装タイプに対応しています**
- **（追加）Y軸を無視した水平方向のみで移動するため、キャラクターが空中に飛ばされません**
