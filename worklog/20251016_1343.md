# 作業レポート 2025-10-16 13:43

## 変更内容の概要

- GameSoundManagerにダメージイベント購読を追加しました
- ダメージを受けたときにdamagedSoundを再生する処理を実装しました
- SFX専用のAudioSourceを追加し、BGMとSFXを分離しました

## 変更理由

ダメージを受けたときに効果音を再生する必要がありました。

R3のReactive Propertyを使用してUserDataManagerのダメージイベント（OnDamageReceived）を購読することで、ダメージシステム全体のイベント駆動アーキテクチャに統一しました。

GameSoundManagerは既にBGM再生用のAudioSourceを持っていましたが、SFX再生用のAudioSourceを追加することで、BGMとSFXを独立して管理できるようにしました。

## 変更したファイル

### 変更: Assets/Sounds/GameSoundManager.cs

**追加したusingディレクティブ (19-20行目):**

```csharp
using R3;
using System;
```

**追加したフィールド (32-35行目):**

```csharp
private AudioSource sfxAudioSource;

// R3購読管理
private IDisposable damageSubscription;
```

**設計の特徴:**
- **sfxAudioSource**: SFX専用のAudioSource（BGMと分離）
- **damageSubscription**: R3購読のDisposable（OnDestroy()で解放）

**更新したAwake() (37-58行目):**

```csharp
private void Awake()
{
    // BGM用AudioSource
    bgmAudioSource = this.AddComponent<AudioSource>();
    bgmAudioSource.loop = true;
    bgmAudioSource.volume = musicVolume * masterVolume;

    if (bgms != null && bgms.Length > 0)
    {
        bgmAudioSource.clip = bgms[0];
        bgmAudioSource.Play();
    }
    else
    {
        Debug.LogWarning("BGMが登録されていません。");
    }

    // SFX用AudioSource
    sfxAudioSource = this.AddComponent<AudioSource>();
    sfxAudioSource.loop = false;
    sfxAudioSource.volume = sfxVolume * masterVolume;
}
```

**変更点:**
- **BGM用AudioSource**: loop = true、BGM再生専用
- **SFX用AudioSource**: loop = false、効果音再生専用
- 両方のAudioSourceを同じGameObjectにAddComponent()で追加
- 音量設定を分離（musicVolume と sfxVolume）

**追加したStart() (60-67行目):**

```csharp
private void Start()
{
    // ダメージイベントを購読
    damageSubscription = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
    {
        PlayDamagedSound();
    });
}
```

UserDataManager.Data.OnDamageReceivedを購読し、ダメージを受けたときにPlayDamagedSound()を呼び出します。

**追加したPlayDamagedSound() (69-78行目):**

```csharp
/// <summary>
/// ダメージサウンドを再生
/// </summary>
private void PlayDamagedSound()
{
    if (damagedSound != null && sfxAudioSource != null)
    {
        sfxAudioSource.PlayOneShot(damagedSound, sfxVolume * masterVolume);
    }
}
```

**処理の流れ:**
1. **damagedSoundとsfxAudioSourceの存在確認**
2. **PlayOneShot()で効果音を再生**
   - BGMを止めずに効果音を重ねて再生
   - 音量: sfxVolume * masterVolume

**PlayOneShot()を使用する理由:**
- BGMを止めずに効果音を再生できる
- 複数の効果音を同時に再生可能
- ループ設定に影響されない

**追加したOnDestroy() (80-84行目):**

```csharp
private void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
}
```

コンポーネント破棄時にR3購読を解放し、メモリリークを防止します。

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがDamageSourceタグのオブジェクト（Spike）に衝突
   ↓
2. GameCharacterCollisionTrigger.OnTriggerEnter()
   - DamageSourceタグを検知
   ↓
3. GameCharacterCollisionTrigger.TakeDamageFromSource()
   - UserDataManager.TakeDamage()を呼び出す
   ↓
4. UserDataManager.TakeDamage()
   - CurrentHp.Valueを減らす
   - OnDamageReceived.OnNext(DamageInfo)を発火
   ↓
5. 購読者（GameInputManager、GameUIManager、GameSoundManager）がイベントを受信
   ↓
6. GameSoundManager.PlayDamagedSound()
   - sfxAudioSource.PlayOneShot(damagedSound)でサウンド再生
```

### ダメージイベントの購読者（現在3つ）

**1. GameInputManager:**
- ノックバックアニメーション遷移
- ノックバック移動
- 入力無効化

**2. GameUIManager:**
- HP表示更新
- デバッグログ出力

**3. GameSoundManager（今回追加）:**
- ダメージサウンド再生

### BGMとSFXの分離

**BGM用AudioSource:**
- loop = true
- BGM再生専用
- musicVolume * masterVolume

**SFX用AudioSource:**
- loop = false
- 効果音再生専用
- PlayOneShot()で再生
- sfxVolume * masterVolume

**分離のメリット:**
- BGMと効果音の音量を独立して調整可能
- BGMを止めずに効果音を再生可能
- 複数の効果音を同時に再生可能

## 設計の利点

### 1. イベント駆動アーキテクチャ

**GameSoundManager ←→ UserDataManager:**
- 直接依存せず、R3のSubjectを介して通信
- UserDataManagerの実装詳細をGameSoundManagerが知る必要がない

### 2. 拡張性の高い設計

**新しい効果音の追加が容易:**
```csharp
// 例: HP回復サウンド
var healSubscriber = UserDataManager.Data.OnHealReceived.Subscribe(healInfo =>
{
    sfxAudioSource.PlayOneShot(healSound);
});

// 例: レベルアップサウンド
var levelUpSubscriber = UserDataManager.Data.OnLevelUp.Subscribe(levelInfo =>
{
    sfxAudioSource.PlayOneShot(levelUpSound);
});
```

### 3. メモリ管理

**OnDestroy()で購読を解放:**
- damageSubscription?.Dispose()
- メモリリーク防止

### 4. PlayOneShot()の利点

**BGMを止めずに効果音を再生:**
- Play()ではなくPlayOneShot()を使用
- BGMと効果音を同時に再生可能
- 複数の効果音を重ねて再生可能

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- R3のSubjectを使用してダメージイベントを購読し、効果音再生処理を実装しました
- SFX専用のAudioSourceを追加し、BGMとSFXを分離しました
- PlayOneShot()を使用することで、BGMを止めずに効果音を再生できます
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- ダメージシステム全体がイベント駆動アーキテクチャで設計されており、新しい購読者（効果音、画面エフェクトなど）を容易に追加可能です
- GameSoundManager、GameInputManager、GameUIManagerの3つのコンポーネントがそれぞれ独立してダメージイベントを購読しています
- Inspector から damagedSound に AudioClip を設定する必要があります
- 音量設定（masterVolume、sfxVolume、musicVolume）を将来的にはInspectorから調整可能にすることも検討できます
