# 作業レポート 2025-10-16 13:54

## 変更内容の概要

- SpeedBasedPostProcessingをGamePostProcessManagerに変更しました
- ダメージイベント購読機能を追加しました
- ダメージ時に画面を赤く光らせるColorAdjustments処理を実装しました

## 変更理由

ダメージを受けたときに画面を赤く光らせることで、プレイヤーにダメージを受けたことを視覚的にフィードバックする必要がありました。

既存のSpeedBasedPostProcessingは移動速度に応じたポストプロセス効果のみを管理していましたが、ダメージ時の画面フラッシュ効果も含めた総合的なポストプロセス管理クラスとして、GamePostProcessManagerに名称変更しました。

R3のReactive Propertyを使用してUserDataManagerのダメージイベント（OnDamageReceived）を購読することで、ダメージシステム全体のイベント駆動アーキテクチャに統一しました。

## 変更したファイル

### 新規作成: Assets/Scripts/Character/GamePostProcessManager.cs

**追加したusingディレクティブ (4-6行目):**

```csharp
using R3;
using System;
using System.Collections;
```

**クラス名の変更:**
- SpeedBasedPostProcessing → GamePostProcessManager

**追加したフィールド (43-51行目):**

```csharp
[Header("ダメージ時フラッシュ設定")]
[SerializeField] private bool enableDamageFlash = true;
[SerializeField] private Color damageFlashColor = new Color(1f, 0f, 0f, 1f);  // 赤色
[SerializeField] private float damageFlashDuration = 0.3f;  // フラッシュ持続時間
[SerializeField] private float damageFlashIntensity = 0.5f; // フラッシュの明るさ強度
```

**設計の特徴:**
- **enableDamageFlash**: ダメージフラッシュのON/OFF切り替え
- **damageFlashColor**: フラッシュの色（デフォルトは赤色）
- **damageFlashDuration**: フラッシュの持続時間（デフォルト0.3秒）
- **damageFlashIntensity**: フラッシュの明るさ強度（0〜1の範囲）

**追加したポストプロセスコンポーネント (58行目):**

```csharp
private ColorAdjustments colorAdjustments;
```

ColorAdjustmentsはURPのポストプロセス効果の一つで、colorFilterパラメータを使用して画面全体の色調を変更できます。

**追加したダメージフラッシュ制御フィールド (64-66行目):**

```csharp
private float damageFlashProgress = 0f;
private bool isDamageFlashing = false;
```

**追加したR3購読管理 (69行目):**

```csharp
private IDisposable damageSubscription;
```

**更新したStart() (71-75行目):**

```csharp
void Start()
{
    InitializePostProcessing();
    SubscribeDamageEvents();
}
```

**追加したSubscribeDamageEvents() (77-88行目):**

```csharp
/// <summary>
/// ダメージイベントを購読
/// </summary>
void SubscribeDamageEvents()
{
    damageSubscription = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
    {
        if (enableDamageFlash)
        {
            StartDamageFlash();
        }
    });
}
```

UserDataManager.Data.OnDamageReceivedを購読し、ダメージを受けたときにStartDamageFlash()を呼び出します。

**更新したInitializePostProcessing() (135-145行目):**

```csharp
// ColorAdjustments（ダメージフラッシュ用）
if (enableDamageFlash)
{
    if (!volumeProfile.TryGet(out colorAdjustments))
    {
        colorAdjustments = volumeProfile.Add<ColorAdjustments>(false);
    }
    colorAdjustments.active = true;
}
```

ColorAdjustmentsコンポーネントをVolumeProfileに追加し、activeをtrueに設定します。

**更新したUpdate() (156-160行目):**

```csharp
void Update()
{
    UpdatePostProcessingEffects();
    UpdateDamageFlash();
}
```

毎フレーム、UpdateDamageFlash()を呼び出してダメージフラッシュエフェクトを更新します。

**追加したOnDestroy() (162-166行目):**

```csharp
void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
}
```

コンポーネント破棄時にR3購読を解放し、メモリリークを防止します。

**追加したStartDamageFlash() (248-253行目):**

```csharp
/// <summary>
/// ダメージフラッシュを開始
/// </summary>
void StartDamageFlash()
{
    isDamageFlashing = true;
    damageFlashProgress = 0f;
}
```

ダメージフラッシュを開始し、進行度を0にリセットします。

**追加したUpdateDamageFlash() (255-277行目):**

```csharp
/// <summary>
/// ダメージフラッシュエフェクトを更新
/// </summary>
void UpdateDamageFlash()
{
    if (!isDamageFlashing || colorAdjustments == null) return;

    // フラッシュの進行度を更新
    damageFlashProgress += Time.deltaTime / damageFlashDuration;

    if (damageFlashProgress >= 1f)
    {
        // フラッシュ終了
        isDamageFlashing = false;
        damageFlashProgress = 1f;
    }

    // フラッシュ強度をイージング（最初は強く、徐々に減衰）
    float easedProgress = 1f - damageFlashProgress;
    float currentFlashIntensity = easedProgress * damageFlashIntensity;

    // ColorAdjustmentsのColorFilterを使用して画面を赤く染める
    Color flashColor = Color.Lerp(Color.white, damageFlashColor, currentFlashIntensity);
    colorAdjustments.colorFilter.value = flashColor;
}
```

**処理の流れ:**
1. **フラッシュ進行度の更新**: Time.deltaTime / damageFlashDurationで進行度を計算
2. **フラッシュ終了判定**: 進行度が1以上になったらフラッシュ終了
3. **イージング計算**: 1f - damageFlashProgressで最初は強く、徐々に減衰する効果を実現
4. **ColorFilter更新**: Color.Lerpで白色からdamageFlashColorへ補間し、colorFilter.valueに設定

**イージングの仕組み:**
- damageFlashProgress: 0 → 1 (時間経過とともに増加)
- easedProgress: 1 → 0 (時間経過とともに減少)
- currentFlashIntensity: damageFlashIntensity → 0 (最初は強く、徐々に減衰)

**更新したResetEffects() (279-292行目):**

```csharp
public void ResetEffects()
{
    currentSpeed = 0f;
    currentEffectIntensity = 0f;
    isDamageFlashing = false;
    damageFlashProgress = 0f;

    UpdatePostProcessingEffects();

    if (colorAdjustments != null)
    {
        colorAdjustments.colorFilter.value = Color.white;
    }
}
```

エフェクトリセット時に、ダメージフラッシュの状態もリセットし、colorFilterをColor.whiteに戻します。

**更新したSetEffectEnabled() (294-318行目):**

```csharp
public void SetEffectEnabled(string effectName, bool enabled)
{
    switch (effectName.ToLower())
    {
        case "lensdistortion":
            enableLensDistortion = enabled;
            if (lensDistortion != null) lensDistortion.active = enabled;
            break;
        case "vignette":
            enableVignette = enabled;
            if (vignette != null) vignette.active = enabled;
            break;
        case "motionblur":
            enableMotionBlur = enabled;
            if (motionBlur != null) motionBlur.active = enabled;
            break;
        case "chromaticaberration":
            enableChromaticAberration = enabled;
            if (chromaticAberration != null) chromaticAberration.active = enabled;
            break;
        case "damageflash":
            enableDamageFlash = enabled;
            break;
    }
}
```

"damageflash"ケースを追加し、ダメージフラッシュのON/OFF切り替えを可能にしました。

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがDamageSourceタグのオブジェクト（Spike）に衝突
   ↓
2. GameCharacterCollisionTrigger.OnTriggerEnter()
   - DamageSourceタグを検知
   ↓
3. GameCharacterCollisionTrigger.TakeDamageFromSource()
   - UserDataManager.TakeDamage()を呼び出す
   ↓
4. UserDataManager.TakeDamage()
   - CurrentHp.Valueを減らす
   - OnDamageReceived.OnNext(DamageInfo)を発火
   ↓
5. 購読者（GameInputManager、GameUIManager、GameSoundManager、GamePostProcessManager）がイベントを受信
   ↓
6. GamePostProcessManager.StartDamageFlash()
   - isDamageFlashing = true
   - damageFlashProgress = 0
   ↓
7. GamePostProcessManager.UpdateDamageFlash()（毎フレーム）
   - 進行度を更新
   - イージング計算
   - ColorAdjustments.colorFilter.valueを更新して画面を赤く染める
```

### ダメージイベントの購読者（現在4つ）

**1. GameInputManager:**
- ノックバックアニメーション遷移
- ノックバック移動
- 入力無効化

**2. GameUIManager:**
- HP表示更新
- デバッグログ出力

**3. GameSoundManager:**
- ダメージサウンド再生

**4. GamePostProcessManager（今回追加）:**
- ダメージフラッシュエフェクト（画面を赤く光らせる）

### ColorAdjustmentsのcolorFilterパラメータ

**colorFilterの役割:**
- 画面全体に色を乗算して色調を変更
- Color.white (1, 1, 1, 1)の場合は元の色のまま
- Color.red (1, 0, 0, 1)の場合は赤色成分のみが残る

**ダメージフラッシュでの使用:**
```csharp
Color flashColor = Color.Lerp(Color.white, damageFlashColor, currentFlashIntensity);
colorAdjustments.colorFilter.value = flashColor;
```

- currentFlashIntensity = 0の場合: flashColor = Color.white（通常）
- currentFlashIntensity = 1の場合: flashColor = damageFlashColor（最大赤色）
- 中間値の場合: 白色と赤色の中間色

### イージング効果

**時間経過とcolorFilterの変化:**
```
時刻   progress  easedProgress  intensity  colorFilter (R, G, B)
0.0s   0.0       1.0            0.5        (1.0, 0.5, 0.5) 赤く光る
0.1s   0.33      0.67           0.33       (1.0, 0.67, 0.67)
0.2s   0.67      0.33           0.17       (1.0, 0.83, 0.83)
0.3s   1.0       0.0            0.0        (1.0, 1.0, 1.0) 通常に戻る
```

最初は強く赤く光り、徐々に減衰して通常の色に戻ります。

## 設計の利点

### 1. イベント駆動アーキテクチャ

**GamePostProcessManager ←→ UserDataManager:**
- 直接依存せず、R3のSubjectを介して通信
- UserDataManagerの実装詳細をGamePostProcessManagerが知る必要がない

### 2. 拡張性の高い設計

**新しいポストプロセス効果の追加が容易:**
```csharp
// 例: 回復時に緑色フラッシュ
var healSubscriber = UserDataManager.Data.OnHealReceived.Subscribe(healInfo =>
{
    StartHealFlash();
});

// 例: クリティカルヒット時に画面を強く光らせる
var criticalHitSubscriber = CombatManager.Data.OnCriticalHit.Subscribe(critInfo =>
{
    StartCriticalFlash();
});
```

### 3. メモリ管理

**OnDestroy()で購読を解放:**
- damageSubscription?.Dispose()
- メモリリーク防止

### 4. Inspector設定の柔軟性

**ダメージフラッシュの細かい調整が可能:**
- enableDamageFlash: ON/OFF切り替え
- damageFlashColor: 色の変更（赤以外も可能）
- damageFlashDuration: 持続時間の調整
- damageFlashIntensity: 強度の調整

### 5. 既存機能の維持

**SpeedBasedPostProcessingの全機能を継承:**
- レンズディストーション
- ビネット
- モーションブラー
- クロマティックアベレーション

移動速度に応じたポストプロセス効果はそのまま動作します。

## テスト結果

診断ツールで確認した結果、新しく作成したGamePostProcessManager.csにはコンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- SpeedBasedPostProcessing.csをGamePostProcessManager.csに名称変更しました（元のファイルは残っています）
- R3のSubjectを使用してダメージイベントを購読し、画面フラッシュ処理を実装しました
- ColorAdjustmentsのcolorFilterパラメータを使用して画面を赤く光らせます
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- ダメージシステム全体がイベント駆動アーキテクチャで設計されており、新しい購読者（画面エフェクト、カメラシェイクなど）を容易に追加可能です
- GameInputManager、GameUIManager、GameSoundManager、GamePostProcessManagerの4つのコンポーネントがそれぞれ独立してダメージイベントを購読しています
- Inspector から enableDamageFlash、damageFlashColor、damageFlashDuration、damageFlashIntensity を設定できます
- 既存のSpeedBasedPostProcessingを使用しているシーンでは、GameObjectのコンポーネントをGamePostProcessManagerに差し替える必要があります
- 既存のSpeedBasedPostProcessing.csファイルは残っているため、必要に応じて削除してください
