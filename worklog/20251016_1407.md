# 作業レポート 2025-10-16 14:07

## 変更内容の概要

- UserDataにIsCautionプロパティを追加しました（HP≦1でtrue）
- GamePostProcessManagerでIsCautionを購読して画面赤色点滅処理を実装しました
- 点滅の色と周期をInspectorで設定可能にしました

## 変更理由

残りHPが1の時にプレイヤーに危険な状態を視覚的にフィードバックする必要がありました。

UserDataにIsCautionプロパティ（ReadOnlyReactiveProperty<bool>）を追加し、CurrentHpから派生させることで、HP状態の変化を自動的に検知できるようにしました。

GamePostProcessManagerでIsCautionを購読することで、ダメージシステム全体のイベント駆動アーキテクチャに統一し、HP警告状態の開始/終了を自動的に検知して画面点滅を制御します。

## 変更したファイル

### 変更: Assets/Scripts/UserData/UserDataManager.cs

**追加したIsCautionプロパティ (91-94行目):**

```csharp
/// <summary>
/// HPが1以下になったときにtrueになる警告状態フラグ
/// </summary>
public ReadOnlyReactiveProperty<bool> IsCaution { get; private set; }
```

**設計の特徴:**
- **ReadOnlyReactiveProperty<bool>**: 外部から読み取り専用、内部でCurrentHpから派生
- **警告条件**: HP ≦ 1 かつ HP > 0（死亡時は警告しない）

**更新したUserDataコンストラクタ (108行目):**

```csharp
public UserData(int initialHp)
{
    CurrentCoin = new ReactiveProperty<int>(0);
    CurrentHp = new ReactiveProperty<int>(initialHp);
    MaxHp = new ReactiveProperty<int>(initialHp);
    IsDead = CurrentHp.Select(x => x <= 0).ToReadOnlyReactiveProperty();
    IsCaution = CurrentHp.Select(x => x <= 1 && x > 0).ToReadOnlyReactiveProperty();
    OnDamageReceived = new Subject<DamageInfo>();
}
```

**IsCautionの派生ロジック:**
- `CurrentHp.Select(x => x <= 1 && x > 0)` でHP変動を監視
- HP = 3: IsCaution = false
- HP = 2: IsCaution = false
- HP = 1: IsCaution = true（警告状態）
- HP = 0: IsCaution = false（死亡、警告不要）

### 変更: Assets/Scripts/Character/GamePostProcessManager.cs

**更新したクラスコメント (8-13行目):**

```csharp
/// <summary>
/// ゲーム全体のポストプロセッシング効果を管理
/// - 移動速度に応じたポストプロセス効果（レンズディストーション、ビネット、モーションブラー）
/// - ダメージ時の画面赤色フラッシュ効果
/// - HP警告時の画面赤色点滅効果
/// </summary>
```

**追加したHP警告時点滅設定 (48-52行目):**

```csharp
[Header("HP警告時点滅設定")]
[SerializeField] private bool enableCautionBlink = true;
[SerializeField] private Color cautionBlinkColor = new Color(1f, 0f, 0f, 1f);  // 赤色
[SerializeField] private float cautionBlinkCycle = 1.5f;  // 点滅周期（秒）
[SerializeField] private float cautionBlinkIntensity = 0.3f; // 点滅の明るさ強度
```

**設計の特徴:**
- **enableCautionBlink**: 点滅のON/OFF切り替え（デフォルト: true）
- **cautionBlinkColor**: 点滅の色（デフォルト: 赤色、変更可能）
- **cautionBlinkCycle**: 点滅の周期（デフォルト: 1.5秒、変更可能）
- **cautionBlinkIntensity**: 点滅の明るさ強度（デフォルト: 0.3、ダメージフラッシュより弱め）

**追加したHP警告時点滅制御フィールド (69-71行目):**

```csharp
// HP警告時点滅制御
private bool isCautionMode = false;
private float cautionBlinkTime = 0f;
```

**追加したR3購読管理 (75行目):**

```csharp
private IDisposable cautionSubscription;
```

**更新したStart() (77-82行目):**

```csharp
void Start()
{
    InitializePostProcessing();
    SubscribeDamageEvents();
    SubscribeCautionEvents();
}
```

**追加したSubscribeCautionEvents() (98-114行目):**

```csharp
/// <summary>
/// HP警告状態を購読
/// </summary>
void SubscribeCautionEvents()
{
    cautionSubscription = UserDataManager.Data.IsCaution.Subscribe(isCaution =>
    {
        isCautionMode = isCaution;
        cautionBlinkTime = 0f;

        // 警告モードが終了したらColorFilterをリセット
        if (!isCaution && colorAdjustments != null && !isDamageFlashing)
        {
            colorAdjustments.colorFilter.value = Color.white;
        }
    });
}
```

**処理の流れ:**
1. **IsCaution購読**: UserDataManager.Data.IsCautionの変化を検知
2. **警告モード開始**: isCautionMode = true、cautionBlinkTime = 0にリセット
3. **警告モード終了**: isCaution = falseの場合、ColorFilterをColor.whiteにリセット
   - ただし、ダメージフラッシュ中（isDamageFlashing）は何もしない

**更新したUpdate() (180-185行目):**

```csharp
void Update()
{
    UpdatePostProcessingEffects();
    UpdateDamageFlash();
    UpdateCautionBlink();
}
```

**更新したOnDestroy() (187-192行目):**

```csharp
void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
    cautionSubscription?.Dispose();
}
```

**追加したUpdateCautionBlink() (315-338行目):**

```csharp
/// <summary>
/// HP警告時の点滅エフェクトを更新
/// </summary>
void UpdateCautionBlink()
{
    if (!enableCautionBlink || !isCautionMode || colorAdjustments == null) return;

    // ダメージフラッシュ中は警告点滅を行わない
    if (isDamageFlashing) return;

    // 点滅時間を更新
    cautionBlinkTime += Time.deltaTime;

    // サイン波で滑らかな点滅を作成（0〜1の範囲）
    float blinkPhase = Mathf.Sin(cautionBlinkTime * Mathf.PI * 2f / cautionBlinkCycle);
    blinkPhase = (blinkPhase + 1f) * 0.5f; // -1〜1 を 0〜1 に変換

    // 点滅強度を計算
    float currentBlinkIntensity = blinkPhase * cautionBlinkIntensity;

    // ColorAdjustmentsのColorFilterを使用して画面を赤く染める
    Color blinkColor = Color.Lerp(Color.white, cautionBlinkColor, currentBlinkIntensity);
    colorAdjustments.colorFilter.value = blinkColor;
}
```

**処理の流れ:**
1. **早期リターン条件**:
   - enableCautionBlink = false
   - isCautionMode = false
   - colorAdjustments = null
   - isDamageFlashing = true（ダメージフラッシュ中は点滅しない）

2. **点滅時間更新**: cautionBlinkTime += Time.deltaTime

3. **サイン波計算**:
   - `Mathf.Sin(cautionBlinkTime * Mathf.PI * 2f / cautionBlinkCycle)`
   - 周期: cautionBlinkCycle秒
   - 出力範囲: -1 〜 1

4. **0〜1の範囲に変換**:
   - `blinkPhase = (blinkPhase + 1f) * 0.5f`
   - -1 → 0、0 → 0.5、1 → 1

5. **点滅強度計算**:
   - `currentBlinkIntensity = blinkPhase * cautionBlinkIntensity`
   - 0 〜 cautionBlinkIntensity の範囲

6. **ColorFilter更新**:
   - `Color.Lerp(Color.white, cautionBlinkColor, currentBlinkIntensity)`
   - 白色から赤色へ滑らかに補間

**サイン波による点滅の仕組み:**

```
時刻   sin値   blinkPhase  intensity(0.3)  効果
0.0s   0.0     0.5         0.15            中間の赤さ
0.375s 1.0     1.0         0.30            最も赤い
0.75s  0.0     0.5         0.15            中間の赤さ
1.125s -1.0    0.0         0.00            白色（通常）
1.5s   0.0     0.5         0.15            中間の赤さ（1周期）
```

滑らかに赤くなったり白くなったりを繰り返します。

**更新したResetEffects() (343-358行目):**

```csharp
public void ResetEffects()
{
    currentSpeed = 0f;
    currentEffectIntensity = 0f;
    isDamageFlashing = false;
    damageFlashProgress = 0f;
    isCautionMode = false;
    cautionBlinkTime = 0f;

    UpdatePostProcessingEffects();

    if (colorAdjustments != null)
    {
        colorAdjustments.colorFilter.value = Color.white;
    }
}
```

警告点滅の状態もリセットします。

**更新したSetEffectEnabled() (386-388行目):**

```csharp
case "cautionblink":
    enableCautionBlink = enabled;
    break;
```

"cautionblink"ケースを追加し、点滅のON/OFF切り替えを可能にしました。

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがDamageSourceタグのオブジェクト（Spike）に衝突
   ↓
2. GameCharacterCollisionTrigger.TakeDamageFromSource()
   - UserDataManager.TakeDamage()を呼び出す
   ↓
3. UserDataManager.TakeDamage()
   - CurrentHp.Value を減らす（例: 3 → 1）
   ↓
4. UserData.CurrentHp の変化を検知
   ↓
5. UserData.IsCaution が自動的に更新される
   - CurrentHp.Select(x => x <= 1 && x > 0)
   - HP = 1: IsCaution = true
   ↓
6. GamePostProcessManager.SubscribeCautionEvents() がIsCautionの変化を受信
   - isCautionMode = true
   - cautionBlinkTime = 0
   ↓
7. GamePostProcessManager.UpdateCautionBlink()（毎フレーム）
   - サイン波で点滅強度を計算
   - ColorAdjustments.colorFilter.valueを更新して画面を赤く点滅させる
```

### ダメージフラッシュと警告点滅の優先順位

**ダメージフラッシュが優先:**
```csharp
// UpdateCautionBlink()内
if (isDamageFlashing) return;
```

- ダメージを受けた瞬間はダメージフラッシュが優先
- ダメージフラッシュ終了後に警告点滅が再開
- 両方のエフェクトが同時に表示されることはない

### IsCautionの自動更新

**ReactivePropertyのSelectを使用:**
```csharp
IsCaution = CurrentHp.Select(x => x <= 1 && x > 0).ToReadOnlyReactiveProperty();
```

- CurrentHpが変化すると自動的にIsCautionが更新される
- 手動でIsCautionを更新する必要がない
- HP = 3 → 1: IsCaution = false → true（警告点滅開始）
- HP = 1 → 2: IsCaution = true → false（警告点滅終了）
- HP = 1 → 0: IsCaution = true → false（死亡、警告点滅終了）

## 設計の利点

### 1. イベント駆動アーキテクチャ

**GamePostProcessManager ←→ UserDataManager:**
- 直接依存せず、R3のReadOnlyReactivePropertyを介して通信
- UserDataManagerの実装詳細をGamePostProcessManagerが知る必要がない

### 2. 自動的な状態管理

**CurrentHpからIsCautionを派生:**
- HP変動に応じてIsCautionが自動更新
- 手動でフラグを管理する必要がない
- バグが入りにくい

### 3. 拡張性の高い設計

**新しい警告状態の追加が容易:**
```csharp
// 例: HP≦2で別の警告（黄色点滅）
public ReadOnlyReactiveProperty<bool> IsWarning { get; private set; }

IsWarning = CurrentHp.Select(x => x <= 2 && x > 1).ToReadOnlyReactiveProperty();
```

### 4. メモリ管理

**OnDestroy()で購読を解放:**
- damageSubscription?.Dispose()
- cautionSubscription?.Dispose()
- メモリリーク防止

### 5. Inspector設定の柔軟性

**点滅の細かい調整が可能:**
- enableCautionBlink: ON/OFF切り替え
- cautionBlinkColor: 色の変更（赤以外も可能）
- cautionBlinkCycle: 周期の調整（速い/遅い点滅）
- cautionBlinkIntensity: 強度の調整（強い/弱い点滅）

### 6. サイン波による滑らかな点滅

**急激な点滅ではなく滑らかな点滅:**
- Mathf.Sin()を使用して滑らかに明暗が変化
- プレイヤーに不快感を与えない
- ゲーム体験を損なわない

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- UserDataにIsCautionプロパティ（ReadOnlyReactiveProperty<bool>）を追加しました
- CurrentHp.Select()を使用してHPから自動的にIsCautionを派生させます
- GamePostProcessManagerでIsCautionを購読し、警告状態の開始/終了を自動検知します
- サイン波（Mathf.Sin）を使用して滑らかな点滅を実現しています
- ダメージフラッシュ中は警告点滅を行わず、ダメージフラッシュが優先されます
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- Inspector から enableCautionBlink、cautionBlinkColor、cautionBlinkCycle、cautionBlinkIntensity を設定できます
- 点滅周期はデフォルト1.5秒、強度はデフォルト0.3（ダメージフラッシュ0.5より弱め）です
- HP = 1の時に点滅が開始され、HP ≧ 2 または HP = 0 の時に点滅が終了します
