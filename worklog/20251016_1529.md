# 作業レポート 2025-10-16 15:29

## 変更内容の概要

- UserDataにCoinGetInfo構造体とOnCoinGetReceived Subjectを追加しました
- UserDataManagerにAddCoin()メソッドを追加し、コイン取得イベントを発火するようにしました
- GameSoundManagerでOnCoinGetReceivedを購読してcoinGetSoundを再生するようにしました
- Coin.csをUserDataManager.AddCoin()呼び出しに変更し、イベント駆動に統一しました

## 変更理由

ダメージサウンドがイベント経由で実装されていたため、コイン取得サウンドも同様のアーキテクチャに統一する必要がありました。

CoinGetInfo構造体を作成し、取得したコイン数、コインソース、取得後のコイン数を含めることで、ダメージシステムと同じ設計パターンに統一しました。

UserDataManager.AddCoin()を通してコイン取得を一元管理することで、コイン取得時の処理（サウンド再生など）を追加する際に、各コンポーネントがイベントを購読するだけで対応できるようになりました。

## 変更したファイル

### 変更: Assets/Scripts/UserData/UserDataManager.cs

**追加したCoinGetInfo構造体 (26-46行目):**

```csharp
/// <summary>
/// コイン取得情報
/// </summary>
public readonly struct CoinGetInfo
{
    /// <summary>取得したコイン数</summary>
    public readonly int Amount;

    /// <summary>コインソース（どのオブジェクトから取得したか）</summary>
    public readonly GameObject Source;

    /// <summary>取得後の現在コイン数</summary>
    public readonly int CurrentCoin;

    public CoinGetInfo(int amount, GameObject source, int currentCoin)
    {
        Amount = amount;
        Source = source;
        CurrentCoin = currentCoin;
    }
}
```

**設計の特徴:**
- **Amount**: 取得したコイン数
- **Source**: コインソース（GameObject）
- **CurrentCoin**: 取得後の現在コイン数

DamageInfoと同じ設計パターンに統一しています。

**追加したAddCoin()メソッド (102-115行目):**

```csharp
/// <summary>
/// コインを追加する処理
/// </summary>
/// <param name="amount">追加するコイン数</param>
/// <param name="coinSource">コインソース（GameObject）</param>
public static void AddCoin(int amount, GameObject coinSource)
{
    // コイン数を増やす
    int newCoin = userData.CurrentCoin.CurrentValue + amount;
    userData.CurrentCoin.Value = newCoin;

    // コイン取得イベントを発火
    userData.OnCoinGetReceived.OnNext(new CoinGetInfo(amount, coinSource, newCoin));
}
```

**処理の流れ:**
1. **コイン数を増やす**: CurrentCoin.Value = newCoin
2. **コイン取得イベントを発火**: OnCoinGetReceived.OnNext()
   - CoinGetInfoに取得したコイン数、コインソース、取得後のコイン数を設定

TakeDamage()と同じ設計パターンに統一しています。

**追加したOnCoinGetReceived Subject (139-143行目):**

```csharp
/// <summary>
/// コインを取得したときに発火するSubject
/// 取得したコイン数、コインソース、取得後のコイン数を通知
/// </summary>
public Subject<CoinGetInfo> OnCoinGetReceived { get; private set; }
```

**更新したUserDataコンストラクタ (153行目):**

```csharp
public UserData(int initialHp)
{
    CurrentCoin = new ReactiveProperty<int>(0);
    CurrentHp = new ReactiveProperty<int>(initialHp);
    MaxHp = new ReactiveProperty<int>(initialHp);
    IsDead = CurrentHp.Select(x => x <= 0).ToReadOnlyReactiveProperty();
    IsCaution = CurrentHp.Select(x => x <= 1 && x > 0).ToReadOnlyReactiveProperty();
    OnDamageReceived = new Subject<DamageInfo>();
    OnCoinGetReceived = new Subject<CoinGetInfo>();
}
```

OnCoinGetReceived = new Subject<CoinGetInfo>()を追加しました。

### 変更: Assets/Sounds/GameSoundManager.cs

**追加したR3購読管理 (41行目):**

```csharp
private IDisposable coinGetSubscription;
```

**追加したコイン取得イベント購読 (92-96行目):**

```csharp
// コイン取得イベントを購読
coinGetSubscription = UserDataManager.Data.OnCoinGetReceived.Subscribe(coinGetInfo =>
{
    PlayCoinGetSound();
});
```

**処理の流れ:**
1. **OnCoinGetReceived購読**: UserDataManager.Data.OnCoinGetReceivedの変化を検知
2. **PlayCoinGetSound()呼び出し**: コイン取得サウンドを再生

**追加したPlayCoinGetSound() (110-119行目):**

```csharp
/// <summary>
/// コイン取得サウンドを再生
/// </summary>
private void PlayCoinGetSound()
{
    if (coinGetSound != null && sfxAudioSource != null)
    {
        sfxAudioSource.PlayOneShot(coinGetSound, sfxVolume * masterVolume);
    }
}
```

**処理の流れ:**
1. **coinGetSoundとsfxAudioSourceの存在確認**
2. **PlayOneShot()で効果音を再生**
   - BGMを止めずに効果音を重ねて再生
   - 音量: sfxVolume * masterVolume

PlayDamagedSound()と同じ実装パターンに統一しています。

**更新したOnDestroy() (149行目):**

```csharp
private void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
    cautionSubscription?.Dispose();
    coinGetSubscription?.Dispose();
}
```

coinGetSubscription?.Dispose()を追加し、メモリリークを防止します。

### 変更: Assets/Scripts/Interactables/Coin.cs

**更新したCollect()メソッド (77-78行目):**

```csharp
// ユーザデータ更新（コイン取得イベントを発火）
UserDataManager.AddCoin(1, gameObject);
```

**変更前:**
```csharp
// ユーザデータ更新
UserDataManager.Data.CurrentCoin.Value ++;
```

**変更後:**
```csharp
// ユーザデータ更新（コイン取得イベントを発火）
UserDataManager.AddCoin(1, gameObject);
```

**変更理由:**
- 直接CurrentCoin.Valueを変更すると、OnCoinGetReceivedイベントが発火しない
- UserDataManager.AddCoin()を呼び出すことで、コイン取得イベントが発火し、サウンド再生などの処理が実行される

## アーキテクチャの設計

### データフローの全体像

```
1. プレイヤーがコインに接触
   ↓
2. Coin.Collect()
   - UserDataManager.AddCoin(1, gameObject)を呼び出す
   ↓
3. UserDataManager.AddCoin()
   - CurrentCoin.Value を増やす
   - OnCoinGetReceived.OnNext(CoinGetInfo)を発火
   ↓
4. GameSoundManager.coinGetSubscription がOnCoinGetReceivedの変化を受信
   ↓
5. GameSoundManager.PlayCoinGetSound()
   - sfxAudioSource.PlayOneShot(coinGetSound)でサウンド再生
```

### イベント駆動アーキテクチャの統一

**ダメージシステムとコイン取得システムの比較:**

| 項目 | ダメージシステム | コイン取得システム |
|------|-----------------|-------------------|
| 情報構造体 | DamageInfo | CoinGetInfo |
| イベント発火メソッド | TakeDamage() | AddCoin() |
| Subject | OnDamageReceived | OnCoinGetReceived |
| 購読者 | GameInputManager, GameUIManager, GameSoundManager, GamePostProcessManager | GameSoundManager |

両方とも同じ設計パターンに統一されています。

### R3購読者の整理

**GameSoundManagerの購読:**
1. **OnDamageReceived**: ダメージサウンド再生（PlayOneShot）
2. **IsCaution**: 警告サウンドのループ再生/停止（Play/Stop）
3. **OnCoinGetReceived**: コイン取得サウンド再生（PlayOneShot）

### PlayOneShot()の使用

**ダメージサウンドとコイン取得サウンドでPlayOneShot()を使用:**
- BGMを止めずに効果音を重ねて再生
- 複数の効果音を同時に再生可能
- ループ設定に影響されない

**警告サウンドでPlay()/Stop()を使用:**
- loop=trueでループ再生
- Stop()で明示的に停止

## 設計の利点

### 1. イベント駆動アーキテクチャの統一

**Coin.cs ←→ GameSoundManager:**
- 直接依存せず、UserDataManager経由でイベントを発火
- Coin.csはGameSoundManagerの存在を知る必要がない

### 2. 拡張性の高い設計

**新しいコイン取得時の処理を追加が容易:**
```csharp
// 例: コイン取得時にエフェクトを表示
var coinEffectSubscription = UserDataManager.Data.OnCoinGetReceived.Subscribe(coinGetInfo =>
{
    ShowCoinEffect(coinGetInfo.Source.transform.position);
});

// 例: コイン取得時にスコア加算
var scoreSubscription = UserDataManager.Data.OnCoinGetReceived.Subscribe(coinGetInfo =>
{
    ScoreManager.AddScore(coinGetInfo.Amount * 10);
});
```

### 3. メモリ管理

**OnDestroy()で購読を解放:**
- damageSubscription?.Dispose()
- cautionSubscription?.Dispose()
- coinGetSubscription?.Dispose()
- メモリリーク防止

### 4. 一貫性のある設計

**DamageInfoとCoinGetInfoの構造が統一:**
- Amount/Damage: 数値
- Source: GameObject
- CurrentCoin/CurrentHp: 変更後の値

新しい情報構造体を追加する際も、同じパターンで実装可能です。

### 5. デバッグの容易性

**イベント発火のログ出力が容易:**
```csharp
// デバッグ用
UserDataManager.Data.OnCoinGetReceived.Subscribe(coinGetInfo =>
{
    Debug.Log($"コイン取得: {coinGetInfo.Amount}枚, " +
              $"ソース: {coinGetInfo.Source.name}, " +
              $"合計: {coinGetInfo.CurrentCoin}枚");
});
```

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- UserDataにCoinGetInfo構造体とOnCoinGetReceived Subjectを追加しました
- UserDataManager.AddCoin()を通してコイン取得を一元管理します
- GameSoundManagerでOnCoinGetReceivedを購読し、コイン取得サウンドを再生します
- Coin.csをUserDataManager.AddCoin()呼び出しに変更し、イベント駆動に統一しました
- ダメージシステムと同じ設計パターンに統一しています
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- Inspector から coinGetSound に AudioClip を設定する必要があります
- 音量はsfxVolume * masterVolumeで設定されます（BGMとは独立）
- PlayOneShot()を使用することで、BGMを止めずに効果音を再生できます
- 将来的にコイン取得時の処理（エフェクト表示、スコア加算など）を追加する際も、OnCoinGetReceivedを購読するだけで対応可能です
