# 作業レポート 2025-10-16 16:15

## 変更内容の概要

- GameInputManagerでIsDead ReactivePropertyを購読し、死亡時に死亡アニメーション遷移と入力無効化を実装しました
- GamePostProcessManagerでIsDeadを購読し、死亡時に画面暗転エフェクト（postExposure: 0→-100）を実装しました
- UserDataManagerにRespawn()メソッドを追加し、HPをMaxHpに回復して死亡状態を解除する処理を実装しました
- GameManagerにリスポーン処理を実装し、死亡→暗転→HP回復→リスポーン地点移動→暗転解除→ゲーム再開のシーケンスを完成させました

## 変更理由

ダメージシステムとHP警告システムが既にR3イベント駆動で実装されていたため、死亡システムも同じアーキテクチャに統一する必要がありました。

UserDataのIsDeadはCurrentHpから自動計算されるReadOnlyReactivePropertyなので、各コンポーネントがIsDeadを購読することで死亡イベントを検知できます。

リスポーン処理ではHPをMaxHpに戻すだけでIsDeadが自動的にfalseになるため、Reactive Propertyの利点を活かした設計になっています。

## 変更したファイル

### 変更: Assets/Scripts/GameManager/GameInputManager.cs

**追加したR3購読管理フィールド (95行目):**

```csharp
private IDisposable deadSubscription;
```

**追加したSubscribeDeadEvents()呼び出し (141行目):**

Start()メソッド内でSubscribeDeadEvents()を呼び出し、IsDead購読を開始します。

**追加したSubscribeDeadEvents()メソッド (605-614行目):**

```csharp
/// <summary>
/// 死亡イベントを購読
/// </summary>
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            OnDead();
        }
    });
}
```

**処理の流れ:**
1. **IsDead購読**: UserDataManager.Data.IsDeadの変化を検知
2. **isDead == true**: 死亡した場合にOnDead()を呼び出し

**追加したOnDead()メソッド (619-634行目):**

```csharp
/// <summary>
/// 死亡時の処理
/// </summary>
void OnDead()
{
    if (EnableVerboseLog)
    {
        Debug.Log($"GameInputManager: 死亡しました。アニメーション遷移。");
    }

    // 死亡アニメーション遷移
    if (animator != null && animator.runtimeAnimatorController != null && animator.isInitialized)
    {
        animator.SetBool("IsDead", true);
    }

    // 入力を無効化
    enabled = false;
}
```

**処理の流れ:**
1. **死亡アニメーション遷移**: animator.SetBool("IsDead", true)でアニメーター遷移
2. **入力を無効化**: enabled = falseでGameInputManagerコンポーネントを無効化

**更新したOnDestroy()メソッド (737行目):**

```csharp
void OnDestroy()
{
    damageSubscription?.Dispose();
    cautionSubscription?.Dispose();
    deadSubscription?.Dispose();
}
```

deadSubscription?.Dispose()を追加し、メモリリークを防止します。

### 変更: Assets/Scripts/Character/GamePostProcessManager.cs

**追加した死亡時暗転設定 (55-57行目):**

```csharp
[Header("死亡時暗転設定")]
[SerializeField] private bool enableDeadFade = true;
[SerializeField] private float deadFadeDuration = 1.0f;  // 暗転時間（秒）
```

**設計の特徴:**
- **enableDeadFade**: 死亡時暗転エフェクトの有効/無効切り替え
- **deadFadeDuration**: 暗転アニメーションの長さ（デフォルト1.0秒）

**追加した制御フィールド (78-85行目):**

```csharp
// 死亡時暗転制御
private bool isDeadFading = false;
private float deadFadeProgress = 0f;

// R3購読管理
private IDisposable damageSubscription;
private IDisposable cautionSubscription;
private IDisposable deadSubscription;
```

**追加したSubscribeDeadEvents()呼び出し (92行目):**

Start()メソッド内でSubscribeDeadEvents()を呼び出し、IsDead購読を開始します。

**追加したSubscribeDeadEvents()メソッド (130-139行目):**

```csharp
/// <summary>
/// 死亡イベントを購読
/// </summary>
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead && enableDeadFade)
        {
            StartDeadFade();
        }
    });
}
```

**処理の流れ:**
1. **IsDead購読**: UserDataManager.Data.IsDeadの変化を検知
2. **isDead == true && enableDeadFade**: 死亡時暗転が有効な場合にStartDeadFade()を呼び出し

**更新したUpdate()メソッド (210行目):**

```csharp
void Update()
{
    UpdatePostProcessingEffects();
    UpdateDamageFlash();
    UpdateCautionBlink();
    UpdateDeadFade();
}
```

UpdateDeadFade()を追加し、死亡時暗転エフェクトを毎フレーム更新します。

**追加したStartDeadFade()メソッド (373-377行目):**

```csharp
/// <summary>
/// 死亡時の暗転を開始
/// </summary>
void StartDeadFade()
{
    isDeadFading = true;
    deadFadeProgress = 0f;
}
```

**追加したUpdateDeadFade()メソッド (382-397行目):**

```csharp
/// <summary>
/// 死亡時の暗転エフェクトを更新
/// </summary>
void UpdateDeadFade()
{
    if (!isDeadFading || colorAdjustments == null) return;

    // 暗転の進行度を更新
    deadFadeProgress += Time.deltaTime / deadFadeDuration;

    if (deadFadeProgress >= 1f)
    {
        deadFadeProgress = 1f;
    }

    // 暗転強度を計算（0 → -100で完全に黒くなる）
    float exposure = Mathf.Lerp(0f, -100f, deadFadeProgress);
    colorAdjustments.postExposure.value = exposure;
}
```

**処理の流れ:**
1. **進行度を更新**: deadFadeProgress += Time.deltaTime / deadFadeDuration
2. **暗転強度を計算**: postExposure.value = Mathf.Lerp(0f, -100f, deadFadeProgress)
   - 0 = 通常の明るさ
   - -100 = 完全に黒い画面

**追加したClearDeadFade()メソッド (402-412行目):**

```csharp
/// <summary>
/// 暗転を解除してゲームを再開
/// </summary>
public void ClearDeadFade()
{
    isDeadFading = false;
    deadFadeProgress = 0f;

    if (colorAdjustments != null)
    {
        colorAdjustments.postExposure.value = 0f;
        colorAdjustments.colorFilter.value = Color.white;
    }
}
```

**処理の流れ:**
1. **暗転フラグをリセット**: isDeadFading = false, deadFadeProgress = 0f
2. **postExposureを0にリセット**: 通常の明るさに戻す
3. **colorFilterをColor.whiteにリセット**: ダメージフラッシュや警告点滅の影響を除去

**更新したUpdateCautionBlink()メソッド (353行目):**

```csharp
// 死亡フェード中は警告点滅を行わない
if (isDeadFading) return;
```

死亡時暗転エフェクトが優先されるように、警告点滅を停止します。

**更新したOnDestroy()メソッド (218行目):**

```csharp
void OnDestroy()
{
    // R3購読の解放
    damageSubscription?.Dispose();
    cautionSubscription?.Dispose();
    deadSubscription?.Dispose();
}
```

deadSubscription?.Dispose()を追加し、メモリリークを防止します。

### 変更: Assets/Scripts/UserData/UserDataManager.cs

**追加したRespawn()メソッド (117-125行目):**

```csharp
/// <summary>
/// リスポーン処理（HPをMaxHpに回復、死亡状態を解除）
/// </summary>
public static void Respawn()
{
    // HPをMaxHpに回復
    userData.CurrentHp.Value = userData.MaxHp.CurrentValue;
    Debug.Log("UserDataManager: リスポーンしました。HP回復。");
}
```

**処理の流れ:**
1. **CurrentHp.Value = MaxHp.CurrentValue**: HPをMaxHpに回復
2. **IsDeadが自動的にfalseになる**: CurrentHp > 0になるため、IsDead ReactivePropertyが自動更新

**設計の特徴:**
- HPを回復するだけでIsDeadが自動的にfalseになる（Reactive Propertyの自動計算）
- シンプルで明確なインターフェース

### 変更: Assets/Scripts/GameManager/GameManager.cs

**追加したusing文 (5-6行目):**

```csharp
using R3;
using System;
```

**追加したリスポーン設定フィールド (42-51行目):**

```csharp
[Header("リスポーン設定")]
[Tooltip("リスポーン地点（シーン内のDefaultSpawnPointタグを持つオブジェクト）")]
[SerializeField] private Transform defaultSpawnPoint;

[Tooltip("死亡後リスポーンまでの待機時間（秒）")]
[SerializeField] private float respawnDelay = 2f;

[Header("ポストプロセス管理")]
[Tooltip("GamePostProcessManager（暗転制御用）")]
[SerializeField] private GamePostProcessManager postProcessManager;
```

**設計の特徴:**
- **defaultSpawnPoint**: リスポーン地点のTransform（自動検出も可能）
- **respawnDelay**: 死亡後リスポーンまでの待機時間（デフォルト2秒）
- **postProcessManager**: GamePostProcessManagerへの参照（自動検出も可能）

**追加したR3購読管理フィールド (57行目):**

```csharp
/// <summary>R3購読管理</summary>
private IDisposable deadSubscription;
```

**追加した自動検出処理 (94-116行目):**

Awake()メソッド内で、GamePostProcessManagerとDefaultSpawnPointを自動検出します。

```csharp
// GamePostProcessManagerの自動検出
if (postProcessManager == null)
{
    postProcessManager = FindFirstObjectByType<GamePostProcessManager>();
    if (postProcessManager == null)
    {
        Debug.LogWarning("GameManager: GamePostProcessManagerが見つかりません。暗転制御が無効になります。");
    }
}

// DefaultSpawnPointの自動検出
if (defaultSpawnPoint == null)
{
    GameObject spawnPointObj = GameObject.FindGameObjectWithTag("DefaultSpawnPoint");
    if (spawnPointObj != null)
    {
        defaultSpawnPoint = spawnPointObj.transform;
    }
    else
    {
        Debug.LogWarning("GameManager: DefaultSpawnPointタグのオブジェクトが見つかりません。リスポーン位置が設定されていません。");
    }
}
```

**更新したStart()メソッド (126-128行目):**

```csharp
// 死亡イベントを購読
SubscribeDeadEvents();
```

**追加したOnDestroy()メソッド (130-134行目):**

```csharp
void OnDestroy()
{
    // R3購読の解放
    deadSubscription?.Dispose();
}
```

メモリリークを防止します。

**追加したSubscribeDeadEvents()メソッド (226-239行目):**

```csharp
/// <summary>
/// 死亡イベントを購読
/// </summary>
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            // リスポーン処理を開始
            StartCoroutine(RespawnSequence());
        }
    });
}
```

**処理の流れ:**
1. **IsDead購読**: UserDataManager.Data.IsDeadの変化を検知
2. **isDead == true**: 死亡した場合にRespawnSequence()コルーチンを開始

**追加したRespawnSequence()コルーチン (241-315行目):**

```csharp
/// <summary>
/// リスポーン処理のシーケンス
/// </summary>
IEnumerator RespawnSequence()
{
    if (enableVerboseLog)
    {
        Debug.Log("GameManager: リスポーン処理を開始します。");
    }

    // 暗転完了まで待機
    yield return new WaitForSeconds(respawnDelay);

    // HPをリセット
    UserDataManager.Respawn();

    // キャラクターをリスポーン地点に移動
    if (activeCharacter != null && defaultSpawnPoint != null)
    {
        CharacterController controller = activeCharacter.GetComponent<CharacterController>();
        if (controller != null)
        {
            // CharacterControllerの場合は無効化してから移動
            controller.enabled = false;
            activeCharacter.transform.position = defaultSpawnPoint.position;
            activeCharacter.transform.rotation = defaultSpawnPoint.rotation;
            controller.enabled = true;
        }
        else
        {
            // CharacterController以外の場合は直接移動
            activeCharacter.transform.position = defaultSpawnPoint.position;
            activeCharacter.transform.rotation = defaultSpawnPoint.rotation;
        }

        if (enableVerboseLog)
        {
            Debug.Log($"GameManager: キャラクターをリスポーン地点に移動しました。位置: {defaultSpawnPoint.position}");
        }
    }

    // アニメーターのIsDead状態をリセット
    if (inputManager != null)
    {
        Animator animator = activeCharacter.GetComponent<Animator>();
        if (animator != null)
        {
            animator.SetBool("IsDead", false);
        }

        // GameInputManagerを再有効化
        inputManager.enabled = true;

        if (enableVerboseLog)
        {
            Debug.Log("GameManager: GameInputManagerを再有効化しました。");
        }
    }

    // 暗転を解除
    if (postProcessManager != null)
    {
        postProcessManager.ClearDeadFade();

        if (enableVerboseLog)
        {
            Debug.Log("GameManager: 暗転を解除しました。");
        }
    }

    if (enableVerboseLog)
    {
        Debug.Log("GameManager: リスポーン処理が完了しました。");
    }
}
```

**処理の流れ:**

1. **暗転完了まで待機**: yield return new WaitForSeconds(respawnDelay)
   - デフォルト2秒待機（暗転アニメーション完了を待つ）

2. **HPをリセット**: UserDataManager.Respawn()
   - HPがMaxHpに回復
   - IsDeadが自動的にfalseになる

3. **キャラクターをリスポーン地点に移動**:
   - CharacterControllerの場合: controller.enabled = false → 移動 → controller.enabled = true
   - その他の場合: transform.position/rotationを直接設定

4. **アニメーターのIsDead状態をリセット**: animator.SetBool("IsDead", false)

5. **GameInputManagerを再有効化**: inputManager.enabled = true

6. **暗転を解除**: postProcessManager.ClearDeadFade()
   - postExposureを0にリセット
   - colorFilterをColor.whiteにリセット

## アーキテクチャの設計

### データフローの全体像

```
1. 敵の攻撃でダメージを受ける
   ↓
2. UserDataManager.TakeDamage()
   - CurrentHp.Value を減らす
   - HP <= 0 の場合、IsDeadが自動的にtrueになる
   ↓
3. GameInputManager.deadSubscription がIsDeadの変化を受信
   ↓
4. GameInputManager.OnDead()
   - animator.SetBool("IsDead", true)で死亡アニメーション遷移
   - enabled = falseで入力を無効化
   ↓
5. GamePostProcessManager.deadSubscription がIsDeadの変化を受信
   ↓
6. GamePostProcessManager.StartDeadFade()
   - isDeadFading = trueで暗転開始
   - UpdateDeadFade()で暗転エフェクト実行（0 → -100）
   ↓
7. GameManager.deadSubscription がIsDeadの変化を受信
   ↓
8. GameManager.RespawnSequence()
   - 2秒待機（暗転完了まで）
   - UserDataManager.Respawn()でHP回復（IsDeadが自動的にfalseになる）
   - キャラクターをリスポーン地点に移動
   - animator.SetBool("IsDead", false)でアニメーション復帰
   - inputManager.enabled = trueで入力を再有効化
   - postProcessManager.ClearDeadFade()で暗転解除
```

### イベント駆動アーキテクチャの統一

**ダメージシステム、HP警告システム、死亡システムの比較:**

| 項目 | ダメージシステム | HP警告システム | 死亡システム |
|------|-----------------|---------------|-------------|
| トリガー | TakeDamage() | CurrentHp <= 1 | CurrentHp <= 0 |
| イベント発火 | OnDamageReceived | IsCaution | IsDead |
| 購読者 | GameInputManager, GameUIManager, GameSoundManager, GamePostProcessManager | GameSoundManager, GamePostProcessManager | GameInputManager, GamePostProcessManager, GameManager |
| エフェクト | 赤色フラッシュ、ダメージサウンド | 赤色点滅、警告サウンド | 死亡アニメーション、暗転、リスポーン |

すべて同じR3 Reactive Propertyパターンに統一されています。

### R3購読者の整理

**GameInputManager:**
1. **OnDamageReceived**: ダメージ方向ベクトル取得（ノックバック処理用）
2. **IsCaution**: 警告状態検知（未使用）
3. **IsDead**: 死亡アニメーション遷移、入力無効化

**GamePostProcessManager:**
1. **OnDamageReceived**: ダメージフラッシュ（赤色フラッシュ）
2. **IsCaution**: HP警告時点滅（赤色点滅）
3. **IsDead**: 死亡時暗転（postExposure: 0 → -100）

**GameSoundManager:**
1. **OnDamageReceived**: ダメージサウンド再生（PlayOneShot）
2. **IsCaution**: 警告サウンドのループ再生/停止（Play/Stop）
3. **OnCoinGetReceived**: コイン取得サウンド再生（PlayOneShot）

**GameManager:**
1. **IsDead**: リスポーンシーケンス実行

**GameUIManager:**
1. **CurrentCoin**: コイン数表示更新
2. **CurrentHp**: ハート表示更新
3. **OnDamageReceived**: ハート表示更新（冗長購読、CurrentHpで十分）

### Reactive Propertyの自動計算の利点

**IsDeadの定義 (UserData.cs):**

```csharp
IsDead = CurrentHp.Select(x => x <= 0).ToReadOnlyReactiveProperty();
```

**特徴:**
- CurrentHpが変化すると、IsDeadが自動的に更新される
- CurrentHp <= 0 → IsDead = true
- CurrentHp > 0 → IsDead = false

**リスポーン処理での利点:**

```csharp
// UserDataManager.Respawn()
userData.CurrentHp.Value = userData.MaxHp.CurrentValue;
// ↓ これだけでIsDeadが自動的にfalseになる！
```

明示的にIsDeadをfalseにする必要がなく、HPを回復するだけで死亡状態が自動解除されます。

### CharacterController移動の注意点

CharacterControllerを使用している場合、transform.positionを直接変更する前にenabled = falseにする必要があります。

```csharp
CharacterController controller = activeCharacter.GetComponent<CharacterController>();
if (controller != null)
{
    // CharacterControllerの場合は無効化してから移動
    controller.enabled = false;
    activeCharacter.transform.position = defaultSpawnPoint.position;
    activeCharacter.transform.rotation = defaultSpawnPoint.rotation;
    controller.enabled = true;
}
```

これにより、CharacterControllerの内部状態がリセットされ、テレポート移動が正しく動作します。

## 設計の利点

### 1. イベント駆動アーキテクチャの統一

**各コンポーネントが直接依存せず、UserDataManager経由でイベントを発火:**
- GameInputManager ←/→ GamePostProcessManager: 互いに存在を知る必要がない
- GameManager ←/→ GameInputManager: enabled = trueで再有効化するだけ
- すべてのコンポーネントがUserDataManagerのReactive Propertyを購読

### 2. 拡張性の高い設計

**新しい死亡時の処理を追加が容易:**

```csharp
// 例: 死亡時にエフェクトを表示
var deathEffectSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
{
    if (isDead)
    {
        ShowDeathEffect();
    }
});

// 例: 死亡回数をカウント
var deathCountSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
{
    if (isDead)
    {
        DeathCounter.IncrementDeathCount();
    }
});
```

### 3. メモリ管理

**OnDestroy()で購読を解放:**
- GameInputManager: deadSubscription?.Dispose()
- GamePostProcessManager: deadSubscription?.Dispose()
- GameManager: deadSubscription?.Dispose()
- メモリリーク防止

### 4. 一貫性のある設計

**DamageInfo、CoinGetInfo、IsDeadの構造が統一:**
- DamageInfo: struct（ダメージ量、ソース、現在HP）
- CoinGetInfo: struct（取得コイン数、ソース、現在コイン数）
- IsDead: ReadOnlyReactiveProperty<bool>（CurrentHpから自動計算）

新しいイベントを追加する際も、同じパターンで実装可能です。

### 5. デバッグの容易性

**イベント発火のログ出力が容易:**

```csharp
// デバッグ用
UserDataManager.Data.IsDead.Subscribe(isDead =>
{
    Debug.Log($"IsDead変化: {isDead}");
});
```

### 6. コルーチンによる時間制御

**WaitForSecondsで暗転完了を待つ:**

```csharp
yield return new WaitForSeconds(respawnDelay);
```

暗転アニメーションが完了してからリスポーン処理を実行することで、プレイヤーに視覚的なフィードバックを提供します。

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 必要な設定

### 1. Animatorに"IsDead"パラメーターを追加

Animatorに以下のパラメーターを追加してください:
- 名前: `IsDead`
- タイプ: `Bool`
- デフォルト値: `false`

死亡アニメーション遷移を設定してください。

### 2. シーンに"DefaultSpawnPoint"タグのオブジェクトを配置

リスポーン地点として使用するオブジェクトに"DefaultSpawnPoint"タグを設定してください。

または、GameManagerのInspectorで`Default Spawn Point`フィールドに直接Transformを設定してください。

### 3. GameManagerの設定確認

GameManagerのInspectorで以下を確認してください:
- `Input Manager`: GameInputManagerへの参照（自動検出）
- `Post Process Manager`: GamePostProcessManagerへの参照（自動検出）
- `Default Spawn Point`: リスポーン地点のTransform（自動検出または手動設定）
- `Respawn Delay`: リスポーンまでの待機時間（デフォルト2秒）

### 4. GamePostProcessManagerの設定確認

GamePostProcessManagerのInspectorで以下を確認してください:
- `Enable Dead Fade`: 死亡時暗転エフェクトの有効化（デフォルトtrue）
- `Dead Fade Duration`: 暗転アニメーションの長さ（デフォルト1秒）

## 備考

- GameInputManagerでIsDeadを購読し、死亡時に死亡アニメーション遷移と入力無効化を実装しました
- GamePostProcessManagerでIsDeadを購読し、死亡時に画面暗転エフェクト（postExposure: 0→-100）を実装しました
- UserDataManager.Respawn()でHPをMaxHpに回復し、IsDeadが自動的にfalseになります
- GameManagerでリスポーン処理を実装し、死亡→暗転→HP回復→リスポーン地点移動→暗転解除→ゲーム再開のシーケンスを完成させました
- CharacterControllerを使用している場合、transform.position変更前にenabled = falseにする必要があります
- ダメージシステム、HP警告システムと同じR3イベント駆動アーキテクチャに統一しています
- OnDestroy()でR3購読を解放し、メモリリークを防止しています
- Animatorに"IsDead"パラメーター（Bool型）を追加する必要があります
- シーンに"DefaultSpawnPoint"タグのオブジェクトを配置するか、GameManagerのInspectorで手動設定する必要があります
- respawnDelay（デフォルト2秒）を調整することで、暗転時間とリスポーンタイミングを調整できます
- 将来的に死亡時の処理（エフェクト表示、死亡カウントなど）を追加する際も、IsDeadを購読するだけで対応可能です
