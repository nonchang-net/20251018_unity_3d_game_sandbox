# 作業レポート 2025-10-16 16:20

## 変更内容の概要

- GamePostProcessManagerに死亡アニメーション表示後に暗転を開始するディレイ設定（deadFadeDelay）を追加しました
- 暗転開始待機フラグ（isWaitingForDeadFade）と待機タイマー（deadFadeWaitTimer）を追加し、死亡アニメーションを見せてから暗転を開始するようにしました
- GameManagerのrespawnDelayのデフォルト値を3秒に変更し、暗転完了を待つための時間を確保しました

## 変更理由

ユーザーから「やられたモーションを見せてから暗転を開始したい」という要望がありました。

死亡直後に即座に暗転が始まると、死亡アニメーションが見えないため、プレイヤーに視覚的なフィードバックが不足していました。

死亡アニメーション表示後に暗転を開始することで、プレイヤーが死亡したことを明確に認識できるようになります。

## 変更したファイル

### 変更: Assets/Scripts/Character/GamePostProcessManager.cs

**追加した死亡時暗転ディレイ設定 (57-60行目):**

```csharp
[Header("死亡時暗転設定")]
[SerializeField] private bool enableDeadFade = true;
[Tooltip("死亡アニメーション表示後、暗転を開始するまでの待機時間（秒）")]
[SerializeField] private float deadFadeDelay = 1.5f;
[Tooltip("暗転アニメーションの長さ（秒）")]
[SerializeField] private float deadFadeDuration = 1.0f;
```

**設計の特徴:**
- **deadFadeDelay**: 死亡アニメーション表示後、暗転を開始するまでの待機時間（デフォルト1.5秒）
- **deadFadeDuration**: 暗転アニメーションの長さ（デフォルト1.0秒）

これにより、合計2.5秒で暗転が完了します。

**追加した暗転開始待機フラグとタイマー (83-85行目):**

```csharp
// 死亡時暗転制御
private bool isDeadFading = false;
private bool isWaitingForDeadFade = false;  // 暗転開始待機中フラグ
private float deadFadeWaitTimer = 0f;       // 暗転開始までの待機タイマー
private float deadFadeProgress = 0f;
```

**更新したStartDeadFade()メソッド (375-383行目):**

```csharp
/// <summary>
/// 死亡時の暗転を開始（待機タイマーをセット）
/// </summary>
void StartDeadFade()
{
    isWaitingForDeadFade = true;
    deadFadeWaitTimer = 0f;
    deadFadeProgress = 0f;
}
```

**変更前:**
```csharp
void StartDeadFade()
{
    isDeadFading = true;
    deadFadeProgress = 0f;
}
```

**変更後:**
```csharp
void StartDeadFade()
{
    isWaitingForDeadFade = true;  // 待機フラグをセット
    deadFadeWaitTimer = 0f;       // 待機タイマーを初期化
    deadFadeProgress = 0f;
}
```

**処理の流れ:**
1. **isWaitingForDeadFade = true**: 暗転開始待機中フラグをセット
2. **deadFadeWaitTimer = 0f**: 待機タイマーを初期化
3. **deadFadeProgress = 0f**: 暗転進行度を初期化

**更新したUpdateDeadFade()メソッド (385-421行目):**

```csharp
/// <summary>
/// 死亡時の暗転エフェクトを更新
/// </summary>
void UpdateDeadFade()
{
    if (colorAdjustments == null) return;

    // 暗転開始待機中の処理
    if (isWaitingForDeadFade)
    {
        deadFadeWaitTimer += Time.deltaTime;

        if (deadFadeWaitTimer >= deadFadeDelay)
        {
            // 待機時間が経過したら暗転を開始
            isWaitingForDeadFade = false;
            isDeadFading = true;
        }

        return;
    }

    // 暗転エフェクトの実行
    if (!isDeadFading) return;

    // 暗転の進行度を更新
    deadFadeProgress += Time.deltaTime / deadFadeDuration;

    if (deadFadeProgress >= 1f)
    {
        deadFadeProgress = 1f;
    }

    // 暗転強度を計算（0 → -100で完全に黒くなる）
    float exposure = Mathf.Lerp(0f, -100f, deadFadeProgress);
    colorAdjustments.postExposure.value = exposure;
}
```

**処理の流れ:**

**フェーズ1: 暗転開始待機中（isWaitingForDeadFade == true）**
1. **deadFadeWaitTimer += Time.deltaTime**: 待機タイマーを更新
2. **deadFadeWaitTimer >= deadFadeDelay**: 待機時間が経過したか確認
3. **isWaitingForDeadFade = false, isDeadFading = true**: 暗転エフェクト開始
4. **return**: この時点では暗転エフェクトは実行しない

**フェーズ2: 暗転エフェクト実行中（isDeadFading == true）**
1. **deadFadeProgress += Time.deltaTime / deadFadeDuration**: 暗転進行度を更新
2. **deadFadeProgress >= 1f**: 暗転完了チェック
3. **postExposure.value = Mathf.Lerp(0f, -100f, deadFadeProgress)**: 暗転強度を計算

**タイムライン:**

```
死亡検知
  ↓
[0秒] StartDeadFade()呼び出し
  ↓
[0秒～1.5秒] 暗転開始待機中（死亡アニメーション表示）
  - isWaitingForDeadFade = true
  - 画面は通常の明るさのまま
  - 死亡アニメーションが再生される
  ↓
[1.5秒] 暗転エフェクト開始
  - isWaitingForDeadFade = false
  - isDeadFading = true
  ↓
[1.5秒～2.5秒] 暗転エフェクト実行中
  - postExposure: 0 → -100 に変化
  - 画面が徐々に黒くなる
  ↓
[2.5秒] 暗転完了
  - postExposure = -100（完全に黒い画面）
```

**更新したClearDeadFade()メソッド (423-438行目):**

```csharp
/// <summary>
/// 暗転を解除してゲームを再開
/// </summary>
public void ClearDeadFade()
{
    isWaitingForDeadFade = false;
    isDeadFading = false;
    deadFadeWaitTimer = 0f;
    deadFadeProgress = 0f;

    if (colorAdjustments != null)
    {
        colorAdjustments.postExposure.value = 0f;
        colorAdjustments.colorFilter.value = Color.white;
    }
}
```

**変更内容:**
- **isWaitingForDeadFade = false**: 待機フラグをリセット
- **deadFadeWaitTimer = 0f**: 待機タイマーをリセット

リスポーン時にすべての暗転関連フラグとタイマーを確実にリセットします。

### 変更: Assets/Scripts/GameManager/GameManager.cs

**更新したrespawnDelayの設定 (46-47行目):**

```csharp
[Tooltip("死亡後リスポーンまでの待機時間（秒）\n※暗転開始ディレイ + 暗転時間 を考慮して設定してください")]
[SerializeField] private float respawnDelay = 3f;
```

**変更前:**
```csharp
[Tooltip("死亡後リスポーンまでの待機時間（秒）")]
[SerializeField] private float respawnDelay = 2f;
```

**変更後:**
```csharp
[Tooltip("死亡後リスポーンまでの待機時間（秒）\n※暗転開始ディレイ + 暗転時間 を考慮して設定してください")]
[SerializeField] private float respawnDelay = 3f;
```

**変更理由:**
- deadFadeDelay（1.5秒）+ deadFadeDuration（1.0秒）= 2.5秒
- 暗転完了後にリスポーン処理を実行するため、respawnDelay = 3秒に変更

**Tooltipの更新:**
- 暗転開始ディレイと暗転時間を考慮して設定する必要があることを明示

## アーキテクチャの設計

### データフローの全体像

```
1. 敵の攻撃でダメージを受ける
   ↓
2. UserDataManager.TakeDamage()
   - CurrentHp.Value を減らす
   - HP <= 0 の場合、IsDeadが自動的にtrueになる
   ↓
3. GameInputManager.OnDead()
   - animator.SetBool("IsDead", true)で死亡アニメーション遷移
   - enabled = falseで入力を無効化
   ↓
4. GamePostProcessManager.StartDeadFade()
   - isWaitingForDeadFade = trueで暗転開始待機
   ↓
5. [0秒～1.5秒] 死亡アニメーション表示
   - UpdateDeadFade()でdeadFadeWaitTimerを更新
   - 画面は通常の明るさのまま
   - 死亡アニメーションが再生される
   ↓
6. [1.5秒] 暗転エフェクト開始
   - isWaitingForDeadFade = false
   - isDeadFading = true
   ↓
7. [1.5秒～2.5秒] 暗転エフェクト実行中
   - UpdateDeadFade()でdeadFadeProgressを更新
   - postExposure: 0 → -100 に変化
   ↓
8. [3秒] GameManager.RespawnSequence()
   - UserDataManager.Respawn()でHP回復
   - キャラクターをリスポーン地点に移動
   - animator.SetBool("IsDead", false)でアニメーション復帰
   - inputManager.enabled = trueで入力を再有効化
   - postProcessManager.ClearDeadFade()で暗転解除
```

### タイムライン設計

**デフォルト設定での時間配分:**

| 時間 | 状態 | 画面表示 | 処理内容 |
|------|------|----------|----------|
| 0秒 | 死亡検知 | 通常 | IsDead = true, 死亡アニメーション遷移 |
| 0～1.5秒 | 暗転開始待機中 | 通常 | 死亡アニメーション再生中 |
| 1.5秒 | 暗転エフェクト開始 | 通常→暗転 | postExposure: 0 → -100 開始 |
| 1.5～2.5秒 | 暗転エフェクト実行中 | 暗転中 | 徐々に黒くなる |
| 2.5秒 | 暗転完了 | 完全に黒 | postExposure = -100 |
| 3秒 | リスポーン処理開始 | 完全に黒 | HP回復、リスポーン地点移動 |
| 3秒 | 暗転解除 | 通常に復帰 | postExposure = 0, ゲーム再開 |

### 設定のカスタマイズ

**Inspector設定:**
- **deadFadeDelay（デフォルト1.5秒）**: 死亡アニメーション表示時間
- **deadFadeDuration（デフォルト1.0秒）**: 暗転アニメーションの長さ
- **respawnDelay（デフォルト3秒）**: 死亡後リスポーンまでの待機時間

**推奨設定:**
- respawnDelay >= deadFadeDelay + deadFadeDuration
- 例: deadFadeDelay=1.5秒, deadFadeDuration=1.0秒 → respawnDelay=3秒以上

**カスタマイズ例1: 死亡アニメーションを長く見せる**
- deadFadeDelay = 2.5秒（死亡アニメーション表示時間を延長）
- deadFadeDuration = 1.0秒
- respawnDelay = 4秒

**カスタマイズ例2: 素早くリスポーン**
- deadFadeDelay = 0.5秒（短い死亡アニメーション）
- deadFadeDuration = 0.5秒（素早い暗転）
- respawnDelay = 1.5秒

## 設計の利点

### 1. 視覚的なフィードバックの改善

**死亡直後に即座に暗転（改善前）:**
- 死亡アニメーションが見えない
- プレイヤーが死亡したことを認識しにくい

**死亡アニメーション表示後に暗転（改善後）:**
- 死亡アニメーションをしっかり見せることができる
- プレイヤーが死亡したことを明確に認識できる

### 2. 柔軟な時間調整

**Inspector設定で簡単に調整可能:**
- deadFadeDelay: 死亡アニメーション表示時間
- deadFadeDuration: 暗転アニメーションの長さ
- respawnDelay: リスポーンまでの待機時間

ゲームの難易度やテンポに応じて、Inspector設定を変更するだけで調整可能です。

### 3. 段階的な状態遷移

**3つの明確なフェーズ:**
1. **暗転開始待機中**: 死亡アニメーション表示
2. **暗転エフェクト実行中**: 画面が徐々に黒くなる
3. **リスポーン処理**: HP回復、キャラクター移動、ゲーム再開

各フェーズが明確に分離されているため、デバッグやカスタマイズが容易です。

### 4. フラグによる状態管理

**2つのフラグで状態を管理:**
- **isWaitingForDeadFade**: 暗転開始待機中
- **isDeadFading**: 暗転エフェクト実行中

どちらのフェーズにいるかが明確で、状態遷移のバグを防ぎやすくなっています。

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 設定推奨値

### デフォルト設定（バランス型）

**GamePostProcessManager:**
- deadFadeDelay = 1.5秒（死亡アニメーション表示時間）
- deadFadeDuration = 1.0秒（暗転アニメーションの長さ）

**GameManager:**
- respawnDelay = 3秒（リスポーンまでの待機時間）

**合計時間:**
- 死亡～リスポーン完了まで約3秒

### 素早いテンポのゲーム向け

**GamePostProcessManager:**
- deadFadeDelay = 0.5秒
- deadFadeDuration = 0.5秒

**GameManager:**
- respawnDelay = 1.5秒

**合計時間:**
- 死亡～リスポーン完了まで約1.5秒

### じっくり見せるゲーム向け

**GamePostProcessManager:**
- deadFadeDelay = 2.5秒
- deadFadeDuration = 1.5秒

**GameManager:**
- respawnDelay = 5秒

**合計時間:**
- 死亡～リスポーン完了まで約5秒

## 備考

- GamePostProcessManagerに死亡アニメーション表示後に暗転を開始するディレイ設定（deadFadeDelay）を追加しました
- 暗転開始待機フラグ（isWaitingForDeadFade）と待機タイマー（deadFadeWaitTimer）を追加しました
- 死亡アニメーションを見せてから暗転を開始することで、プレイヤーに視覚的なフィードバックを提供します
- GameManagerのrespawnDelayを3秒に変更し、暗転完了を待つための時間を確保しました
- Inspector設定で死亡アニメーション表示時間、暗転時間、リスポーン時間を柔軟に調整できます
- respawnDelay >= deadFadeDelay + deadFadeDuration となるように設定することを推奨します
- ゲームのテンポや難易度に応じて、Inspector設定を調整してください
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
