# 作業レポート 2025-10-16 16:24

## 変更内容の概要

- GameInputManagerにOnRespawn()メソッドを追加し、リスポーン時にAnimatorのisDeadパラメーターを自動的にfalseに戻すようにしました
- GameInputManagerのSubscribeDeadEvents()でIsDead == falseの場合にOnRespawn()を呼び出すように変更しました
- GameManagerのRespawnSequence()から、アニメーター操作とGameInputManager再有効化の処理を削除しました（GameInputManagerが自動的に処理するため）

## 変更理由

ユーザーから「リスポーン後にAnimatorのisDeadを解除しましょう」という要望がありました。

以前の実装では、GameManagerがGameInputManagerの内部状態（アニメーター）を直接操作していましたが、これは責任分離の原則に反していました。

GameInputManagerがIsDeadを購読して、死亡時（isDead == true）とリスポーン時（isDead == false）の両方を自動的に処理することで、各コンポーネントの責任が明確になりました。

## 変更したファイル

### 変更: Assets/Scripts/GameManager/GameInputManager.cs

**更新したSubscribeDeadEvents()メソッド (605-618行目):**

```csharp
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            OnDead();
        }
        else
        {
            OnRespawn();
        }
    });
}
```

**変更前:**
```csharp
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            OnDead();
        }
    });
}
```

**変更後:**
```csharp
void SubscribeDeadEvents()
{
    deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            OnDead();  // 死亡時の処理
        }
        else
        {
            OnRespawn();  // リスポーン時の処理
        }
    });
}
```

**処理の流れ:**
1. **isDead == true**: OnDead()を呼び出し
   - animator.SetBool("isDead", true)
   - enabled = false（入力無効化）
2. **isDead == false**: OnRespawn()を呼び出し
   - animator.SetBool("isDead", false)
   - enabled = true（入力再有効化）

**追加したOnRespawn()メソッド (640-658行目):**

```csharp
/// <summary>
/// リスポーン時の処理
/// </summary>
void OnRespawn()
{
    if (EnableVerboseLog)
    {
        Debug.Log($"GameInputManager: リスポーンしました。アニメーション復帰。");
    }

    // 死亡アニメーションを解除
    if (animator != null && animator.runtimeAnimatorController != null && animator.isInitialized)
    {
        animator.SetBool("isDead", false);
    }

    // 入力を再有効化
    enabled = true;
}
```

**処理の流れ:**
1. **デバッグログ出力**: "リスポーンしました。アニメーション復帰。"
2. **animator.SetBool("isDead", false)**: 死亡アニメーションを解除
3. **enabled = true**: GameInputManagerコンポーネントを再有効化（入力受付を再開）

### 変更: Assets/Scripts/GameManager/GameManager.cs

**更新したRespawnSequence()コルーチン (282-289行目):**

```csharp
// アニメーターのIsDead状態をリセット
if (inputManager != null)
{
    Animator animator = activeCharacter.GetComponent<Animator>();
    if (animator != null)
    {
        animator.SetBool("IsDead", false);
    }

    // GameInputManagerを再有効化
    inputManager.enabled = true;

    if (enableVerboseLog)
    {
        Debug.Log("GameManager: GameInputManagerを再有効化しました。");
    }
}

// 暗転を解除
```

**上記のコードを削除しました。**

**変更理由:**
- GameInputManagerがIsDead購読によって自動的にアニメーターをリセットし、自身を再有効化するため
- GameManagerがGameInputManagerの内部状態を直接操作する必要がなくなった
- 責任分離の原則に従った設計

**変更後:**

```csharp
// 暗転を解除
if (postProcessManager != null)
{
    postProcessManager.ClearDeadFade();

    if (enableVerboseLog)
    {
        Debug.Log("GameManager: 暗転を解除しました。");
    }
}
```

GameManagerはキャラクター移動とポストプロセス制御のみを担当するようになりました。

## アーキテクチャの設計

### データフローの全体像

```
1. 敵の攻撃でダメージを受ける
   ↓
2. UserDataManager.TakeDamage()
   - CurrentHp.Value を減らす
   - HP <= 0 の場合、IsDead = true
   ↓
3. GameInputManager.OnDead() (IsDead = true)
   - animator.SetBool("isDead", true)
   - enabled = false（入力無効化）
   ↓
4. GamePostProcessManager.StartDeadFade() (IsDead = true)
   - 暗転開始待機（1.5秒）
   - 暗転エフェクト実行（1秒）
   ↓
5. GameManager.RespawnSequence() (IsDead = true)
   - 3秒待機
   - UserDataManager.Respawn()でHP回復
   - CurrentHp.Value = MaxHp → IsDead = false に自動変化
   - キャラクターをリスポーン地点に移動
   - postProcessManager.ClearDeadFade()で暗転解除
   ↓
6. GameInputManager.OnRespawn() (IsDead = false)
   - animator.SetBool("isDead", false)
   - enabled = true（入力再有効化）
```

### 責任分離の設計

**各コンポーネントの責任:**

| コンポーネント | 責任 | IsDead購読 |
|--------------|------|-----------|
| **GameInputManager** | 入力制御とアニメーター操作 | ✓ (OnDead/OnRespawn) |
| **GamePostProcessManager** | ポストプロセス制御（暗転エフェクト） | ✓ (StartDeadFade) |
| **GameManager** | キャラクター移動とリスポーンシーケンス全体の管理 | ✓ (RespawnSequence) |

**改善前（問題のあった設計）:**
- GameManagerがGameInputManagerの内部状態（アニメーター、enabled）を直接操作
- 責任が分散し、どこで何が行われるか分かりにくい

**改善後（現在の設計）:**
- GameInputManagerが自身の状態を完全に管理
- GameManagerはリスポーン地点移動とポストプロセス制御のみを担当
- 各コンポーネントの責任が明確

### IsDead Reactive Propertyの利点

**IsDead == trueの時:**
1. GameInputManager.OnDead()
2. GamePostProcessManager.StartDeadFade()
3. GameManager.RespawnSequence()

**IsDead == falseの時:**
1. GameInputManager.OnRespawn()

すべてのコンポーネントがIsDeadの変化を購読しているため、UserDataManager.Respawn()でHPを回復するだけで、自動的にすべてのコンポーネントがリスポーン処理を実行します。

**Reactive Propertyの自動計算:**

```csharp
// UserData.cs
IsDead = CurrentHp.Select(x => x <= 0).ToReadOnlyReactiveProperty();
```

CurrentHpが変化すると、IsDeadが自動的に更新されます:
- CurrentHp <= 0 → IsDead = true
- CurrentHp > 0 → IsDead = false

**リスポーン処理の実装:**

```csharp
// UserDataManager.Respawn()
userData.CurrentHp.Value = userData.MaxHp.CurrentValue;
// ↓ これだけでIsDeadが自動的にfalseになり、
// GameInputManager.OnRespawn()が自動的に呼び出される！
```

### タイムライン

```
[0秒] 死亡検知 (IsDead = true)
  ├─ GameInputManager.OnDead()
  │   - animator.SetBool("isDead", true)
  │   - enabled = false
  ├─ GamePostProcessManager.StartDeadFade()
  │   - isWaitingForDeadFade = true
  └─ GameManager.RespawnSequence() 開始
      ↓
[0～1.5秒] 死亡アニメーション表示
  - GamePostProcessManager.UpdateDeadFade() (待機中)
  - 画面は通常の明るさ
      ↓
[1.5秒] 暗転エフェクト開始
  - GamePostProcessManager.UpdateDeadFade() (暗転実行)
  - postExposure: 0 → -100
      ↓
[2.5秒] 暗転完了
  - postExposure = -100（完全に黒）
      ↓
[3秒] リスポーン処理実行 (IsDead = false)
  ├─ UserDataManager.Respawn()
  │   - CurrentHp.Value = MaxHp
  │   - IsDead = false に自動変化
  ├─ GameManager
  │   - キャラクターをリスポーン地点に移動
  │   - postProcessManager.ClearDeadFade()
  └─ GameInputManager.OnRespawn() (自動呼び出し)
      - animator.SetBool("isDead", false)
      - enabled = true
```

## 設計の利点

### 1. 責任分離の徹底

**GameInputManager:**
- 自身の状態（アニメーター、入力有効/無効）を完全に管理
- 外部からの直接操作を受けない

**GameManager:**
- リスポーン地点移動とポストプロセス制御のみを担当
- GameInputManagerの内部状態を直接操作しない

### 2. イベント駆動アーキテクチャの統一

**IsDead Reactive Propertyを購読:**
- GameInputManager: 死亡時/リスポーン時の処理
- GamePostProcessManager: 暗転エフェクト
- GameManager: リスポーンシーケンス全体の管理

すべてのコンポーネントがIsDeadの変化を検知して、自動的に処理を実行します。

### 3. 拡張性の向上

**新しいリスポーン時の処理を追加が容易:**

```csharp
// 例: リスポーン時にエフェクトを表示
UserDataManager.Data.IsDead.Subscribe(isDead =>
{
    if (!isDead)
    {
        ShowRespawnEffect();
    }
});

// 例: リスポーン回数をカウント
UserDataManager.Data.IsDead.Subscribe(isDead =>
{
    if (!isDead)
    {
        RespawnCounter.IncrementRespawnCount();
    }
});
```

IsDead == falseを購読するだけで、リスポーン時の処理を追加できます。

### 4. コードの可読性向上

**改善前:**
- GameManagerがGameInputManagerの内部状態を直接操作
- どこで何が行われるか分かりにくい

**改善後:**
- 各コンポーネントがIsDead購読によって自身の責任を管理
- コードの流れが明確

### 5. テスト容易性

**GameInputManagerの動作をテスト:**

```csharp
// テストコード例
UserDataManager.Data.CurrentHp.Value = 0;  // 死亡
// → GameInputManager.OnDead()が呼び出される
// → animator.SetBool("isDead", true)
// → enabled = false

UserDataManager.Data.CurrentHp.Value = 3;  // リスポーン
// → GameInputManager.OnRespawn()が呼び出される
// → animator.SetBool("isDead", false)
// → enabled = true
```

UserDataのCurrentHpを変更するだけで、GameInputManagerの動作をテストできます。

## テスト結果

診断ツールで確認した結果、コンパイルエラーはなく、Hintレベルの最適化提案のみでした。

## 備考

- GameInputManagerにOnRespawn()メソッドを追加し、リスポーン時にAnimatorのisDeadパラメーターを自動的にfalseに戻すようにしました
- GameInputManagerのSubscribeDeadEvents()でIsDead == falseの場合にOnRespawn()を呼び出すように変更しました
- GameManagerのRespawnSequence()から、アニメーター操作とGameInputManager再有効化の処理を削除しました
- 各コンポーネントが自身の責任を明確に持つようになり、責任分離の原則に従った設計になりました
- GameManagerはキャラクター移動とポストプロセス制御のみを担当するようになりました
- GameInputManagerが自身の状態（アニメーター、入力有効/無効）を完全に管理するようになりました
- IsDead Reactive Propertyの変化を購読することで、すべてのコンポーネントが自動的に処理を実行します
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
