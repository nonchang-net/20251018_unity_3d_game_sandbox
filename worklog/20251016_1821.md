# 作業レポート 2025-10-16 18:21

## 変更内容の概要

- 移動するプラットフォームを制御する「MovingCurve」コンポーネントを作成しました
- 複数のTransformポイント間をCatmull-Romスプライン補間で滑らかに移動します
- Closed Loop（ループ）モードと往復モードに対応しています
- 往復モード時のパスの端での待機機能を実装しました
- イージング機能（Linear, Ease In, Ease Out, Ease InOut）を実装しました
- ゲーム開始時の位置を0.0～1.0で指定できるようにし、Gizmoで表示します

## 変更理由

ユーザーから「移動するプラットフォームを制御する『MovingCurve』コンポーネントを作成してください」という要望がありました。

既存のPrefabCurveScatterはプレファブを複数配置するための機能でしたが、MovingCurveは単一のオブジェクトをパス上で移動させるための機能です。

プラットフォームゲームでは、移動する足場や障害物が重要な要素であり、滑らかな移動と柔軟な設定が必要です。

## 変更したファイル

### 新規作成: Assets/Scripts/Utilities/MovingCurve.cs

**クラス概要:**

```csharp
/// <summary>
/// 複数のポイント間を滑らかに移動するコンポーネント
/// - プラットフォームなどの移動オブジェクトに使用
/// - Catmull-Romスプライン補間による滑らかな移動
/// - イージング機能（Ease In, Ease Out, Ease InOut）
/// - Closed Loop対応
/// - 端での待機機能
/// </summary>
public class MovingCurve : MonoBehaviour
```

**イージングタイプ列挙型 (13-20行目):**

```csharp
/// <summary>
/// イージングタイプ
/// </summary>
public enum EasingType
{
    Linear,     // 線形（イージングなし）
    EaseIn,     // 加速
    EaseOut,    // 減速
    EaseInOut   // 加速→減速
}
```

**Inspector設定フィールド:**

| フィールド | 説明 | デフォルト値 |
|-----------|------|-------------|
| targetTransform | 移動させるTransform（未設定の場合は自分自身） | null |
| pathPoints | 移動経路のポイント（最低2つ必要） | - |
| closedLoop | ループさせるか | false |
| moveSpeed | 移動速度（単位/秒） | 2f |
| waitTimeAtEnd | パスの端での待機時間（秒）※Closed Loop無効時のみ | 1f |
| easingType | イージングタイプ | Linear |
| initialPosition | ゲーム開始時のパス上の位置（0.0～1.0） | 0f |
| showGizmos | Gizmoを表示するか | true |
| pathColor | パスの色 | Green |
| initialPositionColor | 初期位置マーカーの色 | Yellow |

**主要メソッド:**

#### Start() (89-108行目)

```csharp
void Start()
{
    // targetTransformが未設定の場合は自分自身を使用
    if (targetTransform == null)
    {
        targetTransform = transform;
    }

    // パスポイントのチェック
    if (pathPoints == null || pathPoints.Length < 2)
    {
        Debug.LogError("MovingCurve: パスポイントが2つ以上必要です。");
        enabled = false;
        return;
    }

    // パスの総距離を計算
    CalculateTotalPathLength();

    // 初期位置を設定
    currentPathPosition = initialPosition;
    UpdatePosition(currentPathPosition);
}
```

**処理の流れ:**
1. **targetTransform設定**: 未設定の場合は自分自身を使用
2. **パスポイントチェック**: 2つ以上必要
3. **パスの総距離を計算**: CalculateTotalPathLength()
4. **初期位置を設定**: initialPositionから開始

#### Update() (110-153行目)

```csharp
void Update()
{
    // 待機中の処理
    if (isWaiting)
    {
        waitTimer += Time.deltaTime;
        if (waitTimer >= waitTimeAtEnd)
        {
            isWaiting = false;
            waitTimer = 0f;
            direction *= -1; // 方向を反転
        }
        return;
    }

    // 移動処理
    float deltaPosition = (moveSpeed * Time.deltaTime) / totalPathLength * direction;
    currentPathPosition += deltaPosition;

    // パスの端到達チェック
    if (closedLoop)
    {
        // ループモード: 0～1の範囲でループ
        if (currentPathPosition > 1f)
        {
            currentPathPosition -= 1f;
        }
        else if (currentPathPosition < 0f)
        {
            currentPathPosition += 1f;
        }
    }
    else
    {
        // 往復モード: 端で反転
        if (currentPathPosition >= 1f)
        {
            currentPathPosition = 1f;
            isWaiting = true;
            waitTimer = 0f;
        }
        else if (currentPathPosition <= 0f)
        {
            currentPathPosition = 0f;
            isWaiting = true;
            waitTimer = 0f;
        }
    }

    // 位置を更新
    UpdatePosition(currentPathPosition);
}
```

**処理の流れ:**

**フェーズ1: 待機中（isWaiting == true）**
- waitTimerを更新
- waitTimeAtEnd経過で待機終了、方向を反転

**フェーズ2: 移動中**
1. **deltaPosition計算**: (moveSpeed * Time.deltaTime) / totalPathLength * direction
2. **currentPathPosition更新**: 0.0～1.0の範囲で移動
3. **端到達チェック**:
   - Closed Loop有効: ループ（0.0に戻る）
   - Closed Loop無効: 待機開始、方向反転
4. **位置を更新**: UpdatePosition()

#### CalculateTotalPathLength() (155-176行目)

```csharp
void CalculateTotalPathLength()
{
    totalPathLength = 0f;

    if (closedLoop)
    {
        // ループモード: すべてのポイント間の距離を加算
        for (int i = 0; i < pathPoints.Length; i++)
        {
            int nextIndex = (i + 1) % pathPoints.Length;
            totalPathLength += Vector3.Distance(pathPoints[i].position, pathPoints[nextIndex].position);
        }
    }
    else
    {
        // 往復モード: 最初から最後までの距離を加算
        for (int i = 0; i < pathPoints.Length - 1; i++)
        {
            totalPathLength += Vector3.Distance(pathPoints[i].position, pathPoints[i + 1].position);
        }
    }
}
```

**Closed Loop有効:**
- すべてのポイント間の距離を加算
- 最後のポイントから最初のポイントまでも含む

**Closed Loop無効:**
- 最初から最後までの距離のみ加算

#### UpdatePosition() (178-193行目)

```csharp
void UpdatePosition(float t)
{
    // イージングを適用
    float easedT = ApplyEasing(t, easingType);

    // Catmull-Romスプライン補間で位置を計算
    Vector3 newPosition = GetPositionOnPath(easedT);

    // ターゲットの位置を更新
    if (targetTransform != null)
    {
        targetTransform.position = newPosition;
    }
}
```

**処理の流れ:**
1. **イージング適用**: ApplyEasing()
2. **位置計算**: GetPositionOnPath() でCatmull-Romスプライン補間
3. **位置更新**: targetTransform.position = newPosition

#### GetPositionOnPath() (195-220行目)

```csharp
Vector3 GetPositionOnPath(float t)
{
    if (pathPoints.Length == 2)
    {
        // ポイントが2つの場合は線形補間
        return Vector3.Lerp(pathPoints[0].position, pathPoints[1].position, t);
    }

    // ポイント数に応じてセグメントを計算
    int segmentCount = closedLoop ? pathPoints.Length : pathPoints.Length - 1;
    float segmentLength = 1f / segmentCount;

    // 現在のセグメントを特定
    int segmentIndex = Mathf.FloorToInt(t / segmentLength);
    segmentIndex = Mathf.Clamp(segmentIndex, 0, segmentCount - 1);

    // セグメント内のローカルt（0.0～1.0）
    float localT = (t - segmentIndex * segmentLength) / segmentLength;

    // Catmull-Romスプライン補間用の4つのポイントを取得
    Vector3 p0, p1, p2, p3;
    GetCatmullRomPoints(segmentIndex, out p0, out p1, out p2, out p3);

    // Catmull-Romスプライン補間
    return CatmullRomInterpolation(p0, p1, p2, p3, localT);
}
```

**処理の流れ:**
1. **ポイント数チェック**: 2つの場合は線形補間
2. **セグメント計算**: 全体のパスを複数のセグメントに分割
3. **現在のセグメント特定**: segmentIndex
4. **ローカルt計算**: セグメント内の位置（0.0～1.0）
5. **Catmull-Rom補間用ポイント取得**: GetCatmullRomPoints()
6. **Catmull-Rom補間**: CatmullRomInterpolation()

#### GetCatmullRomPoints() (222-257行目)

```csharp
void GetCatmullRomPoints(int segmentIndex, out Vector3 p0, out Vector3 p1, out Vector3 p2, out Vector3 p3)
{
    int pointCount = pathPoints.Length;

    if (closedLoop)
    {
        // ループモード
        int i0 = (segmentIndex - 1 + pointCount) % pointCount;
        int i1 = segmentIndex;
        int i2 = (segmentIndex + 1) % pointCount;
        int i3 = (segmentIndex + 2) % pointCount;

        p0 = pathPoints[i0].position;
        p1 = pathPoints[i1].position;
        p2 = pathPoints[i2].position;
        p3 = pathPoints[i3].position;
    }
    else
    {
        // 往復モード
        int i0 = Mathf.Max(0, segmentIndex - 1);
        int i1 = segmentIndex;
        int i2 = Mathf.Min(pointCount - 1, segmentIndex + 1);
        int i3 = Mathf.Min(pointCount - 1, segmentIndex + 2);

        p0 = pathPoints[i0].position;
        p1 = pathPoints[i1].position;
        p2 = pathPoints[i2].position;
        p3 = pathPoints[i3].position;
    }
}
```

**Catmull-Romスプライン補間:**
- 4つのポイント（p0, p1, p2, p3）を使用
- p1からp2の間を補間
- p0とp3は曲線の滑らかさを制御

**Closed Loop有効:**
- モジュロ演算（%）でループ
- 最後のポイントの次は最初のポイント

**Closed Loop無効:**
- Mathf.Clampで範囲制限
- 端ではポイントを重複使用

#### CatmullRomInterpolation() (259-273行目)

```csharp
Vector3 CatmullRomInterpolation(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
{
    float t2 = t * t;
    float t3 = t2 * t;

    Vector3 result = 0.5f * (
        (2f * p1) +
        (-p0 + p2) * t +
        (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2 +
        (-p0 + 3f * p1 - 3f * p2 + p3) * t3
    );

    return result;
}
```

**Catmull-Romスプライン補間の数式:**
```
P(t) = 0.5 * [
    (2 * p1) +
    (-p0 + p2) * t +
    (2*p0 - 5*p1 + 4*p2 - p3) * t^2 +
    (-p0 + 3*p1 - 3*p2 + p3) * t^3
]
```

この数式により、p1からp2へ滑らかな曲線で補間されます。

#### ApplyEasing() (275-299行目)

```csharp
float ApplyEasing(float t, EasingType type)
{
    switch (type)
    {
        case EasingType.EaseIn:
            return t * t;

        case EasingType.EaseOut:
            return 1f - (1f - t) * (1f - t);

        case EasingType.EaseInOut:
            if (t < 0.5f)
            {
                return 2f * t * t;
            }
            else
            {
                return 1f - 2f * (1f - t) * (1f - t);
            }

        case EasingType.Linear:
        default:
            return t;
    }
}
```

**イージングタイプ:**

| タイプ | 数式 | 効果 |
|-------|------|------|
| **Linear** | t | 等速運動 |
| **EaseIn** | t^2 | 加速（ゆっくり始まり、速く終わる） |
| **EaseOut** | 1 - (1-t)^2 | 減速（速く始まり、ゆっくり終わる） |
| **EaseInOut** | 前半: 2*t^2, 後半: 1 - 2*(1-t)^2 | 加速→減速（ゆっくり始まり、中間で最速、ゆっくり終わる） |

#### OnDrawGizmos() (301-353行目)

```csharp
void OnDrawGizmos()
{
    if (!showGizmos || pathPoints == null || pathPoints.Length < 2)
    {
        return;
    }

    // パスを描画
    Gizmos.color = pathColor;

    if (closedLoop)
    {
        // ループモード: すべてのポイントを結ぶ
        for (int i = 0; i < pathPoints.Length; i++)
        {
            if (pathPoints[i] == null) continue;

            int nextIndex = (i + 1) % pathPoints.Length;
            if (pathPoints[nextIndex] == null) continue;

            DrawSmoothPath(i, pathPoints[i].position, pathPoints[nextIndex].position);
        }
    }
    else
    {
        // 往復モード: 最初から最後まで結ぶ
        for (int i = 0; i < pathPoints.Length - 1; i++)
        {
            if (pathPoints[i] == null || pathPoints[i + 1] == null) continue;

            DrawSmoothPath(i, pathPoints[i].position, pathPoints[i + 1].position);
        }
    }

    // ポイントを描画
    foreach (Transform point in pathPoints)
    {
        if (point == null) continue;
        Gizmos.DrawSphere(point.position, 0.2f);
    }

    // 初期位置マーカーを描画
    Gizmos.color = initialPositionColor;
    Vector3 initialPos = GetPositionOnPath(initialPosition);
    Gizmos.DrawWireSphere(initialPos, 0.3f);
    Gizmos.DrawLine(initialPos + Vector3.up * 0.5f, initialPos - Vector3.up * 0.5f);
    Gizmos.DrawLine(initialPos + Vector3.right * 0.5f, initialPos - Vector3.right * 0.5f);
    Gizmos.DrawLine(initialPos + Vector3.forward * 0.5f, initialPos - Vector3.forward * 0.5f);
}
```

**Gizmo描画内容:**
1. **パス描画**: DrawSmoothPath()で滑らかな曲線を描画
2. **ポイント描画**: 各パスポイントに球を描画（半径0.2）
3. **初期位置マーカー描画**:
   - ワイヤー球（半径0.3）
   - 十字線（上下、左右、前後）

#### DrawSmoothPath() (355-371行目)

```csharp
void DrawSmoothPath(int segmentIndex, Vector3 start, Vector3 end)
{
    const int segments = 20;
    Vector3 prevPoint = start;

    for (int i = 1; i <= segments; i++)
    {
        float t = i / (float)segments;
        float globalT = (segmentIndex + t) / (closedLoop ? pathPoints.Length : pathPoints.Length - 1);
        Vector3 point = GetPositionOnPath(globalT);
        Gizmos.DrawLine(prevPoint, point);
        prevPoint = point;
    }
}
```

**処理の流れ:**
1. **セグメント分割**: 20分割
2. **各ポイント計算**: GetPositionOnPath()
3. **線描画**: Gizmos.DrawLine()

滑らかな曲線を複数の直線で近似して描画します。

#### パブリックメソッド (373-395行目)

```csharp
/// <summary>
/// パス上の位置を設定（外部から呼び出し可能）
/// </summary>
public void SetPathPosition(float t)
{
    currentPathPosition = Mathf.Clamp01(t);
    UpdatePosition(currentPathPosition);
}

/// <summary>
/// 現在のパス上の位置を取得
/// </summary>
public float GetCurrentPathPosition()
{
    return currentPathPosition;
}

/// <summary>
/// 移動を一時停止/再開
/// </summary>
public void SetPaused(bool paused)
{
    enabled = !paused;
}
```

**外部制御用メソッド:**
- **SetPathPosition()**: パス上の位置を直接設定
- **GetCurrentPathPosition()**: 現在位置を取得
- **SetPaused()**: 移動を一時停止/再開

## アーキテクチャの設計

### データフローの全体像

```
1. Start()
   - パスポイントチェック
   - パスの総距離を計算
   - 初期位置を設定
   ↓
2. Update() (毎フレーム)
   - 待機中の処理
   - 移動処理（currentPathPosition更新）
   - 端到達チェック
   - 位置を更新
   ↓
3. UpdatePosition()
   - イージング適用
   - GetPositionOnPath()で位置計算
   - targetTransform.position更新
   ↓
4. GetPositionOnPath()
   - セグメント計算
   - GetCatmullRomPoints()で4つのポイント取得
   - CatmullRomInterpolation()で補間
```

### Catmull-Romスプライン補間の仕組み

**4つのポイント（p0, p1, p2, p3）:**
```
p0 -----> p1 -----> p2 -----> p3
          ^         ^
          補間区間
```

- **p1からp2へ補間**: 実際に移動する区間
- **p0とp3**: 曲線の滑らかさを制御

**利点:**
- 滑らかな曲線で移動
- ポイントを正確に通過
- 自然な加速/減速

### イージングの効果

**Linear（線形）:**
```
速度: ━━━━━━━━━━━━━━━━━━━━
     一定速度
```

**EaseIn（加速）:**
```
速度: ━╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱
     ゆっくり → 速く
```

**EaseOut（減速）:**
```
速度: ╲╲╲╲╲╲╲╲╲╲╲╲╲╲╲╲╲╲━
     速く → ゆっくり
```

**EaseInOut（加速→減速）:**
```
速度: ━╱╱╱╱╱━━━━╲╲╲╲╲━
     ゆっくり → 速く → ゆっくり
```

### Closed Loopの動作

**Closed Loop有効:**
```
Point 0 → Point 1 → Point 2 → Point 3 → Point 0 → ...
└────────────────────────────────────────┘
```
- 最後のポイントから最初のポイントへループ
- 待機なし

**Closed Loop無効:**
```
Point 0 → Point 1 → Point 2 → Point 3
                                  ↓ 待機
Point 0 ← Point 1 ← Point 2 ← Point 3
  ↓ 待機
Point 0 → ...
```
- 端で待機（waitTimeAtEnd）
- 方向を反転して往復

## 使用方法

### 基本的なセットアップ

1. **移動させたいオブジェクトにアタッチ**:
   - プラットフォームなどにMovingCurveコンポーネントを追加

2. **パスポイントを配置**:
   - 空のGameObjectを作成し、パスの各ポイントに配置
   - 最低2つ必要

3. **Inspector設定**:
   - Path Pointsに配置したTransformを設定
   - Move Speedで移動速度を調整
   - Closed Loopで移動モードを選択

### 設定例

**例1: 水平移動プラットフォーム**
- Path Points: 2つ（左端、右端）
- Closed Loop: false（往復）
- Move Speed: 2f
- Wait Time At End: 1f（端で1秒待機）
- Easing Type: EaseInOut（滑らかな往復）

**例2: 円形移動プラットフォーム**
- Path Points: 8つ（円形に配置）
- Closed Loop: true（ループ）
- Move Speed: 3f
- Easing Type: Linear（等速）

**例3: 複雑な経路を移動する障害物**
- Path Points: 5つ（複雑な経路）
- Closed Loop: true（ループ）
- Move Speed: 4f
- Easing Type: EaseIn（加速）
- Initial Position: 0.5（中間から開始）

## 設計の利点

### 1. Catmull-Romスプライン補間による滑らかな移動

**直線補間の問題:**
- ポイントで急激に方向転換
- 不自然な動き

**Catmull-Rom補間の利点:**
- 滑らかな曲線で移動
- 自然な加速/減速
- ポイントを正確に通過

### 2. 柔軟なイージング設定

**4つのイージングタイプ:**
- Linear: 等速運動
- EaseIn: 加速（ダイナミックな移動）
- EaseOut: 減速（安定した停止）
- EaseInOut: 加速→減速（自然な往復）

ゲームの雰囲気に合わせて調整可能です。

### 3. Closed Loop対応

**ループモード:**
- 無限ループで移動
- エレベーターや回転する障害物に最適

**往復モード:**
- 端で待機してから反転
- プラットフォームや往復する障害物に最適

### 4. 初期位置の設定

**initialPosition（0.0～1.0）:**
- ゲーム開始時のパス上の位置を指定
- 複数のプラットフォームを配置する際、タイミングをずらせる

**Gizmo表示:**
- 初期位置を視覚的に確認
- レベルデザインが容易

### 5. 外部制御用API

**SetPathPosition():**
- パス上の位置を直接設定
- カットシーンやイベントで使用

**GetCurrentPathPosition():**
- 現在位置を取得
- プレイヤーとの同期などに使用

**SetPaused():**
- 移動を一時停止/再開
- ポーズメニューなどで使用

### 6. targetTransform対応

**未設定の場合:**
- 自分自身を移動

**設定した場合:**
- 別のオブジェクトを移動
- MovingCurveコンポーネントと移動オブジェクトを分離可能

## テスト結果

診断ツールで確認した結果、コンパイルエラーはありませんでした。

## 備考

- 移動するプラットフォームを制御する「MovingCurve」コンポーネントを作成しました
- 複数のTransformポイント間をCatmull-Romスプライン補間で滑らかに移動します
- Closed Loop（ループ）モードと往復モードに対応しています
- 往復モード時のパスの端での待機機能（waitTimeAtEnd）を実装しました
- イージング機能（Linear, Ease In, Ease Out, Ease InOut）を実装しました
- ゲーム開始時の位置をinitialPosition（0.0～1.0）で指定できます
- Gizmoでパス、ポイント、初期位置マーカーを表示します
- targetTransformで移動させるオブジェクトを指定できます（未設定の場合は自分自身）
- 外部制御用API（SetPathPosition, GetCurrentPathPosition, SetPaused）を提供しています
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
- 最低2つのパスポイントが必要です
- パスポイントは空のGameObjectを配置して設定してください
