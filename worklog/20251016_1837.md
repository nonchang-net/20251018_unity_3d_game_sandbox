# 作業レポート 2025-10-16 18:37

## 変更内容の概要

- MovingCurveコンポーネントのイージング機能を無効化しました
- UpdatePosition()メソッドからApplyEasing()の呼び出しを削除しました
- easingTypeフィールドとApplyEasing()メソッドをコメントアウトしました

## 変更理由

ユーザーから「Linearに指定してもイージングしているように見えますね」という報告がありました。

問題の原因は、イージング関数をパス上の位置パラメータ`t`（0.0～1.0）に適用した後にCatmull-Rom補間を行っていたためです。Catmull-Rom補間自体が曲線を作るため、パラメータ`t`にイージングを適用すると以下の問題が発生します：

1. **Linearイージングでも非線形な動き**: Catmull-Romスプライン補間は曲線の曲率に応じて自然に速度が変化します。パラメータ`t`を線形に変化させても、実際の移動速度は曲線の形状によって変わります。
2. **イージングの効果が予測困難**: `t`にイージングを適用すると、スプライン補間の非線形性と組み合わさって複雑な動きになります。

イージング機能を無効化することで、一定速度での移動を実現します。

## 変更したファイル

### 変更: Assets/Scripts/Utilities/MovingCurve.cs

**クラスコメントの更新 (3-10行目):**

```csharp
/// <summary>
/// 複数のポイント間を滑らかに移動するコンポーネント
/// - プラットフォームなどの移動オブジェクトに使用
/// - Catmull-Romスプライン補間による滑らかな移動
/// - 繰り返しモード（Once, Loop, PingPong Loop）
/// - 端での待機機能（PingPong Loop時）
/// ※イージング機能はスプライン補間と相性が悪いため、現在は無効化しています
/// </summary>
```

**変更前:**
```csharp
/// - イージング機能（Ease In, Ease Out, Ease InOut）
```

**変更後:**
```csharp
/// ※イージング機能はスプライン補間と相性が悪いため、現在は無効化しています
```

**easingTypeフィールドのコメントアウト (53-56行目):**

```csharp
// [Header("イージング設定")]
// [Tooltip("イージングタイプ")]
// [SerializeField] private EasingType easingType = EasingType.Linear;
// ※現在、イージングはスプライン補間と相性が悪いため無効化しています
```

**変更前:**
```csharp
[Header("イージング設定")]
[Tooltip("イージングタイプ")]
[SerializeField] private EasingType easingType = EasingType.Linear;
```

**変更後:**
コメントアウトして無効化しました。

**UpdatePosition()メソッドの更新 (205-221行目):**

```csharp
/// <summary>
/// パス上の位置（0.0～1.0）に基づいて、実際の位置を更新
/// </summary>
/// <param name="t">パス上の位置（0.0～1.0）</param>
void UpdatePosition(float t)
{
    // Catmull-Romスプライン補間で位置を計算
    // ※イージングはスプライン補間と相性が悪いため、ここでは適用しない
    // ※移動速度は一定に保たれる（Linear）
    Vector3 newPosition = GetPositionOnPath(t);

    // ターゲットの位置を更新
    if (targetTransform != null)
    {
        targetTransform.position = newPosition;
    }
}
```

**変更前:**
```csharp
void UpdatePosition(float t)
{
    // イージングを適用
    float easedT = ApplyEasing(t, easingType);

    // Catmull-Romスプライン補間で位置を計算
    Vector3 newPosition = GetPositionOnPath(easedT);

    // ターゲットの位置を更新
    if (targetTransform != null)
    {
        targetTransform.position = newPosition;
    }
}
```

**変更後:**
ApplyEasing()の呼び出しを削除し、`t`を直接GetPositionOnPath()に渡すようにしました。これにより、パラメータ`t`が線形に変化し、一定速度での移動が実現されます。

**ApplyEasing()メソッドのコメントアウト (310-338行目):**

```csharp
// /// <summary>
// /// イージングを適用
// /// ※現在、イージングはスプライン補間と相性が悪いため無効化しています
// /// </summary>
// float ApplyEasing(float t, EasingType type)
// {
//     switch (type)
//     {
//         case EasingType.EaseIn:
//             return t * t;
//
//         case EasingType.EaseOut:
//             return 1f - (1f - t) * (1f - t);
//
//         case EasingType.EaseInOut:
//             if (t < 0.5f)
//             {
//                 return 2f * t * t;
//             }
//             else
//             {
//                 return 1f - 2f * (1f - t) * (1f - t);
//             }
//
//         case EasingType.Linear:
//         default:
//             return t;
//     }
// }
```

**変更前:**
```csharp
float ApplyEasing(float t, EasingType type)
{
    // イージング関数の実装
}
```

**変更後:**
コメントアウトして無効化しました。将来的にイージングを実装する場合は、スプライン補間とは別の方法（例：実際の移動距離に対してイージングを適用する）が必要になります。

## アーキテクチャの設計

### イージングとスプライン補間の相性問題

**問題:**
```
パラメータt（0.0～1.0）にイージングを適用
   ↓
Catmull-Romスプライン補間で座標を計算
   ↓
非線形な動き（Linearでも速度が変化）
```

**原因:**

Catmull-Romスプライン補間は、4つの制御点を使用して滑らかな曲線を生成します。この曲線は以下の特性を持ちます：

1. **パラメータtと実際の距離が非線形**: `t`が0.0から1.0まで線形に変化しても、実際の移動距離は曲線の曲率に応じて変化します。
2. **曲率に応じた速度変化**: 曲線がきつい部分では移動距離が短く、緩やかな部分では移動距離が長くなります。

例えば、以下のような4つのポイントがある場合：

```
Point 0 (0, 0, 0)
Point 1 (1, 0, 0)
Point 2 (2, 1, 0)  ← 急カーブ
Point 3 (3, 0, 0)
```

`t`を0.0から1.0まで線形に変化させても、Point 1からPoint 2への移動（急カーブ）では実際の速度が遅くなります。

**イージングを適用した場合:**

`t`にイージングを適用すると、スプライン補間の非線形性と組み合わさって、以下のような複雑な動きになります：

```
EaseIn（加速）を適用:
  t = 0.0 → easedT = 0.0
  t = 0.5 → easedT = 0.25  ← まだ遅い
  t = 1.0 → easedT = 1.0   ← 最後に速い

スプライン補間の非線形性:
  easedT = 0.0 → 位置A
  easedT = 0.25 → 位置B（急カーブで実際の距離は短い）
  easedT = 1.0 → 位置C

結果: 加速しているはずなのに、急カーブで減速したように見える
```

### 解決策: イージングを無効化

**修正後:**

```
パラメータt（0.0～1.0）を線形に変化
   ↓
Catmull-Romスプライン補間で座標を計算
   ↓
一定速度での移動（パラメータtが線形）
```

`t`を線形に変化させることで、Catmull-Romスプライン補間の自然な動きを活かします。曲線の曲率に応じて若干の速度変化はありますが、全体として滑らかで一定の速度での移動が実現されます。

### 将来的なイージング実装の方向性

イージングを実装する場合は、以下のような方法が考えられます：

**1. 実際の移動距離に対してイージングを適用:**

```csharp
// パスの総距離を計算
float totalDistance = CalculateTotalPathLength();

// 現在の移動距離にイージングを適用
float easedDistance = ApplyEasing(currentDistance / totalDistance) * totalDistance;

// 距離に対応するパラメータtを逆算
float t = GetTFromDistance(easedDistance);

// 座標を計算
Vector3 position = GetPositionOnPath(t);
```

**2. 線形補間とスプライン補間を組み合わせる:**

```csharp
// Linearの場合: スプライン補間
if (easingType == EasingType.Linear)
{
    position = GetPositionOnPath(t);
}
// イージングの場合: 線形補間（滑らかさを犠牲にする）
else
{
    float easedT = ApplyEasing(t);
    position = Vector3.Lerp(startPoint, endPoint, easedT);
}
```

**3. イージングを別の要素に適用:**

```csharp
// 回転やスケールにイージングを適用
float easedT = ApplyEasing(t);
transform.rotation = Quaternion.Lerp(startRotation, endRotation, easedT);

// 位置は線形
transform.position = GetPositionOnPath(t);
```

## 動作確認

### 修正前の動作:

- **Linear指定**: パラメータ`t`にイージングを適用していないが、Catmull-Rom補間の非線形性により速度が変化していた
- **EaseIn/EaseOut指定**: イージングとスプライン補間の相互作用により、予測困難な動きになっていた

### 修正後の動作:

- **すべてのケース**: パラメータ`t`が線形に変化し、Catmull-Romスプライン補間の自然な動きを活かした一定速度での移動が実現される

### テスト手順:

1. Unity Editorでシーンを開く
2. MovingCurveコンポーネントがアタッチされたGameObjectを選択
3. InspectorでLoop Modeを設定（Once, Loop, PingPongLoop）
4. Move Speedを設定（例: 2.0）
5. Path Pointsに複数のTransformを設定
6. ゲームを実行して、一定速度での移動を確認

## 備考

- MovingCurveコンポーネントのイージング機能を無効化しました
- UpdatePosition()メソッドからApplyEasing()の呼び出しを削除しました
- easingTypeフィールドとApplyEasing()メソッドをコメントアウトしました
- これにより、Linearイージングでも一定速度での移動が実現されます
- 将来的にイージングを実装する場合は、実際の移動距離に対してイージングを適用するなど、スプライン補間と相性の良い方法を検討する必要があります
- EasingType列挙型は残していますが、現在は使用されていません
- コメントアウトしたコードは、将来的な実装の参考として残しています
