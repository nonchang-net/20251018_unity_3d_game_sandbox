# 作業レポート 2025-10-16 21:43

## 変更内容の概要

- MovingCurveコンポーネントで、パスポイントの位置情報をStart()時にコピーして保持するように変更しました
- 移動対象のTransform自体をパスの一部として指定できるようになりました
- 実行中の移動計算が、元のTransformの位置変化に影響されなくなりました

## 変更理由

ユーザーから「設定作業の簡略化のために、移動対象のTransformそれ自体をパスの一部として指定できるようにしたいです。現在そのように指定すると、移動が計算結果に影響を与えてしまい不自然な挙動を示していました。実行前にtransform内容をコピーすることでこの要件を達成できると思います。」という指示がありました。

例えば、以下のような設定をしたい場合：

```
Path Points:
  - Point 0: 自分自身のTransform（移動対象）
  - Point 1: 別のEmpty GameObject
  - Point 2: さらに別のEmpty GameObject
```

この場合、Point 0は移動対象自身を指しているため、移動中にPoint 0の位置が変化してしまい、パスの計算結果が変わってしまいます。これにより、不自然な挙動が発生していました。

Start()時にパスポイントの位置情報をコピーすることで、実行中の移動がパス計算に影響しないようにしました。

## 変更したファイル

### 変更: Assets/Scripts/Utilities/MovingCurve.cs

**pathPositionsフィールドの追加 (44-45行目):**

```csharp
// パスポイントの位置情報のコピー（Start()時に保存）
private Vector3[] pathPositions;
```

パスポイントの位置情報を保存するためのVector3配列を追加しました。

**Start()メソッドの更新 (47-79行目):**

```csharp
void Start()
{
    // targetTransformが未設定の場合は自分自身を使用
    if (targetTransform == null)
    {
        targetTransform = transform;
    }

    // パスポイントのチェック
    if (pathPoints == null || pathPoints.Length < 2)
    {
        Debug.LogError("MovingCurve: パスポイントが2つ以上必要です。");
        enabled = false;
        return;
    }

    // パスポイントの位置情報をコピー（移動対象自身がパスに含まれていても問題ないように）
    pathPositions = new Vector3[pathPoints.Length];
    for (int i = 0; i < pathPoints.Length; i++)
    {
        if (pathPoints[i] != null)
        {
            pathPositions[i] = pathPoints[i].position;
        }
    }

    // パスの総距離を計算
    CalculateTotalPathLength();

    // 初期位置を設定
    currentPathPosition = initialPosition;
    UpdatePosition(currentPathPosition);
}
```

**変更前:**
```csharp
void Start()
{
    // targetTransformが未設定の場合は自分自身を使用
    if (targetTransform == null)
    {
        targetTransform = transform;
    }

    // パスポイントのチェック
    if (pathPoints == null || pathPoints.Length < 2)
    {
        Debug.LogError("MovingCurve: パスポイントが2つ以上必要です。");
        enabled = false;
        return;
    }

    // パスの総距離を計算
    CalculateTotalPathLength();

    // 初期位置を設定
    currentPathPosition = initialPosition;
    UpdatePosition(currentPathPosition);
}
```

**変更後:**
パスポイントのチェック後、CalculateTotalPathLength()を呼ぶ前に、pathPositions配列を作成してpathPoints[i].positionをコピーするようにしました。

**CalculateTotalPathLength()メソッドの更新 (100-112行目):**

```csharp
/// <summary>
/// パスの総距離を計算
/// </summary>
void CalculateTotalPathLength()
{
    totalPathLength = 0f;

    // 最初から最後までの距離を加算（コピーした位置情報を使用）
    for (int i = 0; i < pathPositions.Length - 1; i++)
    {
        totalPathLength += Vector3.Distance(pathPositions[i], pathPositions[i + 1]);
    }
}
```

**変更前:**
```csharp
void CalculateTotalPathLength()
{
    totalPathLength = 0f;

    // 最初から最後までの距離を加算
    for (int i = 0; i < pathPoints.Length - 1; i++)
    {
        totalPathLength += Vector3.Distance(pathPoints[i].position, pathPoints[i + 1].position);
    }
}
```

**変更後:**
`pathPoints[i].position`の代わりに`pathPositions[i]`（コピーした位置情報）を使用するようにしました。

**GetPositionOnPath()メソッドの更新 (130-164行目):**

```csharp
/// <summary>
/// パス上の位置（0.0～1.0）から実際の座標を取得
/// 線形補間を使用
/// </summary>
/// <param name="t">パス上の位置（0.0～1.0）</param>
/// <returns>実際の座標</returns>
Vector3 GetPositionOnPath(float t)
{
    // tを0.0～1.0にクランプ
    t = Mathf.Clamp01(t);

    // パス全体の距離に対する現在の距離を計算
    float targetDistance = t * totalPathLength;
    float accumulatedDistance = 0f;

    // どのセグメント上にいるかを特定（コピーした位置情報を使用）
    for (int i = 0; i < pathPositions.Length - 1; i++)
    {
        Vector3 segmentStart = pathPositions[i];
        Vector3 segmentEnd = pathPositions[i + 1];
        float segmentLength = Vector3.Distance(segmentStart, segmentEnd);

        if (accumulatedDistance + segmentLength >= targetDistance)
        {
            // このセグメント上にいる
            float segmentT = (targetDistance - accumulatedDistance) / segmentLength;
            return Vector3.Lerp(segmentStart, segmentEnd, segmentT);
        }

        accumulatedDistance += segmentLength;
    }

    // 最後のポイントを返す（念のため）
    return pathPositions[pathPositions.Length - 1];
}
```

**変更前:**
```csharp
Vector3 GetPositionOnPath(float t)
{
    // tを0.0～1.0にクランプ
    t = Mathf.Clamp01(t);

    // パス全体の距離に対する現在の距離を計算
    float targetDistance = t * totalPathLength;
    float accumulatedDistance = 0f;

    // どのセグメント上にいるかを特定
    for (int i = 0; i < pathPoints.Length - 1; i++)
    {
        Vector3 segmentStart = pathPoints[i].position;
        Vector3 segmentEnd = pathPoints[i + 1].position;
        float segmentLength = Vector3.Distance(segmentStart, segmentEnd);

        if (accumulatedDistance + segmentLength >= targetDistance)
        {
            // このセグメント上にいる
            float segmentT = (targetDistance - accumulatedDistance) / segmentLength;
            return Vector3.Lerp(segmentStart, segmentEnd, segmentT);
        }

        accumulatedDistance += segmentLength;
    }

    // 最後のポイントを返す（念のため）
    return pathPoints[pathPoints.Length - 1].position;
}
```

**変更後:**
- `pathPoints[i].position`の代わりに`pathPositions[i]`を使用
- `pathPoints.Length`の代わりに`pathPositions.Length`を使用
- コメントに「（コピーした位置情報を使用）」を追加

**OnDrawGizmos()メソッドの更新 (166-222行目):**

```csharp
/// <summary>
/// Gizmoを描画
/// </summary>
void OnDrawGizmos()
{
    if (!showGizmos || pathPoints == null || pathPoints.Length < 2)
    {
        return;
    }

    // パスを描画（直線）
    Gizmos.color = pathColor;

    // 実行前はpathPointsを使用、実行後はpathPositionsを使用
    if (pathPositions != null && pathPositions.Length == pathPoints.Length)
    {
        // 実行後: コピーした位置情報を使用
        for (int i = 0; i < pathPositions.Length - 1; i++)
        {
            Gizmos.DrawLine(pathPositions[i], pathPositions[i + 1]);
        }

        // ポイントを描画
        foreach (Vector3 pos in pathPositions)
        {
            Gizmos.DrawSphere(pos, 0.2f);
        }
    }
    else
    {
        // 実行前: pathPointsのTransformを直接使用
        for (int i = 0; i < pathPoints.Length - 1; i++)
        {
            if (pathPoints[i] == null || pathPoints[i + 1] == null) continue;

            Gizmos.DrawLine(pathPoints[i].position, pathPoints[i + 1].position);
        }

        // ポイントを描画
        foreach (Transform point in pathPoints)
        {
            if (point == null) continue;
            Gizmos.DrawSphere(point.position, 0.2f);
        }
    }

    // 初期位置マーカーを描画
    if (totalPathLength > 0f && pathPositions != null)
    {
        Gizmos.color = initialPositionColor;
        Vector3 initialPos = GetPositionOnPath(initialPosition);
        Gizmos.DrawWireSphere(initialPos, 0.3f);
        Gizmos.DrawLine(initialPos + Vector3.up * 0.5f, initialPos - Vector3.up * 0.5f);
        Gizmos.DrawLine(initialPos + Vector3.right * 0.5f, initialPos - Vector3.right * 0.5f);
        Gizmos.DrawLine(initialPos + Vector3.forward * 0.5f, initialPos - Vector3.forward * 0.5f);
    }
}
```

**変更前:**
```csharp
void OnDrawGizmos()
{
    if (!showGizmos || pathPoints == null || pathPoints.Length < 2)
    {
        return;
    }

    // パスを描画（直線）
    Gizmos.color = pathColor;

    for (int i = 0; i < pathPoints.Length - 1; i++)
    {
        if (pathPoints[i] == null || pathPoints[i + 1] == null) continue;

        Gizmos.DrawLine(pathPoints[i].position, pathPoints[i + 1].position);
    }

    // ポイントを描画
    foreach (Transform point in pathPoints)
    {
        if (point == null) continue;
        Gizmos.DrawSphere(point.position, 0.2f);
    }

    // 初期位置マーカーを描画
    if (totalPathLength > 0f)
    {
        Gizmos.color = initialPositionColor;
        Vector3 initialPos = GetPositionOnPath(initialPosition);
        Gizmos.DrawWireSphere(initialPos, 0.3f);
        Gizmos.DrawLine(initialPos + Vector3.up * 0.5f, initialPos - Vector3.up * 0.5f);
        Gizmos.DrawLine(initialPos + Vector3.right * 0.5f, initialPos - Vector3.right * 0.5f);
        Gizmos.DrawLine(initialPos + Vector3.forward * 0.5f, initialPos - Vector3.forward * 0.5f);
    }
}
```

**変更後:**
OnDrawGizmos()はエディタ上で実行前にも呼ばれるため、pathPositionsの有無で分岐を追加しました：

- **実行後（pathPositions != null）**: コピーした位置情報（pathPositions）を使用してGizmoを描画
- **実行前（pathPositions == null）**: pathPointsのTransformを直接使用してGizmoを描画

これにより、以下の動作が実現されます：

- **エディタ編集中**: pathPointsのTransformをリアルタイムで追跡（移動したら線も動く）
- **ゲーム実行中**: pathPositionsの固定された位置で描画（移動対象が動いても線は動かない）

## アーキテクチャの設計

### パス位置情報のコピーの仕組み

**実行フロー:**

```
1. Start()が呼ばれる
   ↓
2. pathPoints[].positionをpathPositions[]にコピー
   ↓
3. pathPositionsを使用してtotalPathLengthを計算
   ↓
4. Update()で移動処理
   ↓
5. GetPositionOnPath()でpathPositionsから座標を計算
   ↓
6. targetTransform.positionを更新
```

**重要な点:**
- pathPositionsは**Start()時の位置情報のスナップショット**
- 実行中にpathPoints[].positionが変化しても、pathPositionsは変化しない
- 移動計算は常にpathPositionsを参照

### 移動対象自身をパスに含める場合の動作

**例: 3つのポイントがある場合**

```
Path Points:
  - Point 0: MovingCurveがアタッチされたGameObject（自分自身）
    - 初期位置: (0, 0, 0)
  - Point 1: Empty GameObject
    - 位置: (5, 0, 0)
  - Point 2: Empty GameObject
    - 位置: (10, 0, 0)
```

**Start()時:**
```csharp
pathPositions[0] = (0, 0, 0)  // 自分自身の初期位置をコピー
pathPositions[1] = (5, 0, 0)
pathPositions[2] = (10, 0, 0)

totalPathLength = 5 + 5 = 10m
```

**Update()で移動中（t = 0.5）:**
```csharp
targetDistance = 0.5 * 10 = 5m

セグメント0（0, 0, 0）→（5, 0, 0）: 5m
  accumulatedDistance + segmentLength = 0 + 5 = 5 >= 5? → Yes
  segmentT = (5 - 0) / 5 = 1.0
  位置 = Lerp((0, 0, 0), (5, 0, 0), 1.0) = (5, 0, 0)

targetTransform.position = (5, 0, 0)
```

この時点で、Point 0（自分自身）の実際の位置は(5, 0, 0)になっていますが、pathPositions[0]は(0, 0, 0)のままです。

**さらに移動中（t = 0.75）:**
```csharp
targetDistance = 0.75 * 10 = 7.5m

セグメント0（0, 0, 0）→（5, 0, 0）: 5m
  accumulatedDistance + segmentLength = 0 + 5 = 5 >= 7.5? → No
  accumulatedDistance = 5m

セグメント1（5, 0, 0）→（10, 0, 0）: 5m
  accumulatedDistance + segmentLength = 5 + 5 = 10 >= 7.5? → Yes
  segmentT = (7.5 - 5) / 5 = 0.5
  位置 = Lerp((5, 0, 0), (10, 0, 0), 0.5) = (7.5, 0, 0)

targetTransform.position = (7.5, 0, 0)
```

Point 0（自分自身）の実際の位置は(7.5, 0, 0)ですが、計算には影響しません。pathPositions[0]は(0, 0, 0)のままで、計算はこの固定値を使用します。

### 修正前の問題

**修正前:**
```csharp
Vector3 segmentStart = pathPoints[i].position;  // 実行中の現在位置を参照
Vector3 segmentEnd = pathPoints[i + 1].position;
```

移動対象自身がpathPoints[0]の場合：
- t = 0.0: segmentStart = (0, 0, 0)
- t = 0.5: segmentStart = (5, 0, 0) ← 移動したので変化
- t = 0.75: segmentStart = (7.5, 0, 0) ← さらに変化

これにより、パスの計算結果が変わり、不自然な挙動が発生していました。

**修正後:**
```csharp
Vector3 segmentStart = pathPositions[i];  // Start()時の位置を参照
Vector3 segmentEnd = pathPositions[i + 1];
```

移動対象自身がpathPoints[0]の場合でも：
- t = 0.0: segmentStart = (0, 0, 0)
- t = 0.5: segmentStart = (0, 0, 0) ← 変化しない
- t = 0.75: segmentStart = (0, 0, 0) ← 変化しない

パスの計算結果が一定に保たれます。

## 使用例

### 設定例1: 自分自身をパスに含める

```
GameObject: MovingPlatform
  - MovingCurve (Component)
    - Target Transform: (空白 = 自分自身)
    - Path Points[3]:
      - [0]: MovingPlatform（自分自身）
      - [1]: WayPoint1
      - [2]: WayPoint2
    - Move Speed: 2.0
    - Initial Position: 0.0
```

**動作:**
- MovingPlatformは自分の初期位置からWayPoint1、WayPoint2へ移動
- 移動中にMovingPlatformの位置が変わっても、パス計算に影響しない

### 設定例2: 別のオブジェクトを移動させる

```
GameObject: PathController
  - MovingCurve (Component)
    - Target Transform: Platform（別のGameObject）
    - Path Points[3]:
      - [0]: Platform（移動対象）
      - [1]: WayPoint1
      - [2]: WayPoint2
    - Move Speed: 2.0
    - Initial Position: 0.0
```

**動作:**
- PlatformはPathControllerによって移動される
- PathControllerは動かず、Platformだけが移動
- Platformの初期位置からWayPoint1、WayPoint2へ移動

## 動作確認

### 期待される動作:

1. **設定の簡略化**: 移動対象自身をPath Pointsの1つとして指定できる
2. **正しい移動**: 移動中にパス計算が変化せず、一定速度で移動
3. **Gizmo表示**:
   - **実行前**: pathPointsのTransformをリアルタイムで追跡
   - **実行後**: pathPositionsの固定位置で描画

### テスト手順:

1. Unity Editorでシーンを開く
2. GameObjectを作成（例: MovingPlatform）
3. MovingCurveコンポーネントをアタッチ
4. Path Pointsに以下を設定:
   - [0]: MovingPlatform（自分自身）
   - [1]: 別のEmpty GameObject（WayPoint1）
   - [2]: さらに別のEmpty GameObject（WayPoint2）
5. Move Speed: 2.0
6. Initial Position: 0.0
7. ゲームを実行して、正しく移動することを確認

## 備考

- MovingCurveコンポーネントで、パスポイントの位置情報をStart()時にコピーして保持するように変更しました
- 移動対象のTransform自体をパスの一部として指定できるようになりました
- pathPositions配列を追加し、Start()時にpathPoints[].positionをコピーするようにしました
- CalculateTotalPathLength()、GetPositionOnPath()をpathPositionsを使用するように変更しました
- OnDrawGizmos()でpathPositionsの有無で分岐を追加し、実行前後で異なる描画を行うようにしました
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
- コード行数: 217行 → 249行（32行増加、約15%増加）
