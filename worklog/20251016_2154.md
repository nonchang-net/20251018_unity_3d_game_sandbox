# 作業レポート 2025-10-16 21:54

## 変更内容の概要

- MovingCurveコンポーネントにループモード（Loop、PingPongLoop）を追加しました
- イージング機能（Linear, Ease In, Ease Out, Ease InOut）を追加しました
- 3種類の繰り返しモード（Once, Loop, PingPong Loop）を実装しました

## 変更理由

ユーザーから「良さそうですね。続いて、ループモードとイージング実装を行ってください。」という指示がありました。

前回、Catmull-Romスプライン補間とイージングの相性問題により、これらの機能を削除してシンプルな実装にしました。今回は、直線的な線形補間をベースとして、ループモードとイージング機能を追加します。

直線的な移動では、イージングを適用しても予測可能な動作が得られます。

## 変更したファイル

### 変更: Assets/Scripts/Utilities/MovingCurve.cs

**LoopMode列挙型の追加 (12-20行目):**

```csharp
/// <summary>
/// 繰り返しモード
/// </summary>
public enum LoopMode
{
    Once,           // 一度だけ移動して停止
    Loop,           // 最初に戻ってループ
    PingPongLoop    // 往復ループ
}
```

3種類の繰り返しモードを定義しました。

**EasingType列挙型の追加 (22-31行目):**

```csharp
/// <summary>
/// イージングタイプ
/// </summary>
public enum EasingType
{
    Linear,     // 線形（イージングなし）
    EaseIn,     // 加速
    EaseOut,    // 減速
    EaseInOut   // 加速→減速
}
```

4種類のイージングタイプを定義しました。

**フィールドの追加 (41-86行目):**

```csharp
[Tooltip("繰り返しモード")]
[SerializeField] private LoopMode loopMode = LoopMode.Once;

[Header("待機設定")]
[Tooltip("パスの端に到達した際の待機時間（秒）※PingPong Loopモード時のみ")]
[SerializeField] private float waitTimeAtEnd = 1f;

[Header("イージング設定")]
[Tooltip("イージングタイプ")]
[SerializeField] private EasingType easingType = EasingType.Linear;

// 移動方向（1: 順方向, -1: 逆方向）※PingPongLoopモード時に使用
private int direction = 1;

// 待機中フラグ※PingPongLoopモード時に使用
private bool isWaiting = false;

// 待機タイマー※PingPongLoopモード時に使用
private float waitTimer = 0f;
```

**追加したフィールド:**
- `loopMode`: ループモードの選択
- `waitTimeAtEnd`: PingPongLoopモード時の端での待機時間
- `easingType`: イージングタイプの選択
- `direction`: 移動方向（PingPongLoopモード用）
- `isWaiting`: 待機中フラグ（PingPongLoopモード用）
- `waitTimer`: 待機タイマー（PingPongLoopモード用）

**Update()メソッドの更新 (122-193行目):**

```csharp
void Update()
{
    // 待機中の処理（PingPongLoopモード時）
    if (isWaiting)
    {
        waitTimer += Time.deltaTime;
        if (waitTimer >= waitTimeAtEnd)
        {
            isWaiting = false;
            waitTimer = 0f;
            direction *= -1; // 方向を反転
        }
        return;
    }

    // 移動処理
    float deltaPosition = (moveSpeed * Time.deltaTime) / totalPathLength * direction;
    currentPathPosition += deltaPosition;

    // パスの端到達チェック（ループモード別）
    switch (loopMode)
    {
        case LoopMode.Once:
            // 一度だけ移動: 端で停止
            if (currentPathPosition >= 1f)
            {
                currentPathPosition = 1f;
                UpdatePosition(currentPathPosition);
                enabled = false; // 移動を停止
                return;
            }
            else if (currentPathPosition <= 0f)
            {
                currentPathPosition = 0f;
                UpdatePosition(currentPathPosition);
                enabled = false; // 移動を停止
                return;
            }
            break;

        case LoopMode.Loop:
            // ループ: 0～1の範囲でループ
            if (currentPathPosition > 1f)
            {
                currentPathPosition -= 1f;
            }
            else if (currentPathPosition < 0f)
            {
                currentPathPosition += 1f;
            }
            break;

        case LoopMode.PingPongLoop:
            // 往復ループ: 端で反転
            if (currentPathPosition >= 1f)
            {
                currentPathPosition = 1f;
                isWaiting = true;
                waitTimer = 0f;
            }
            else if (currentPathPosition <= 0f)
            {
                currentPathPosition = 0f;
                isWaiting = true;
                waitTimer = 0f;
            }
            break;
    }

    // 位置を更新
    UpdatePosition(currentPathPosition);
}
```

**変更前:**
```csharp
void Update()
{
    // 移動処理
    float deltaPosition = (moveSpeed * Time.deltaTime) / totalPathLength;
    currentPathPosition += deltaPosition;

    // パスの端到達チェック（Onceモード: 端で停止）
    if (currentPathPosition >= 1f)
    {
        currentPathPosition = 1f;
        UpdatePosition(currentPathPosition);
        enabled = false; // 移動を停止
        return;
    }

    // 位置を更新
    UpdatePosition(currentPathPosition);
}
```

**変更後:**
- 待機処理を追加（PingPongLoopモード時）
- switch文で3種類のループモードに対応
- directionを使用して移動方向を制御（PingPongLoopモード用）

**CalculateTotalPathLength()メソッドの更新 (195-219行目):**

```csharp
/// <summary>
/// パスの総距離を計算
/// </summary>
void CalculateTotalPathLength()
{
    totalPathLength = 0f;

    if (loopMode == LoopMode.Loop)
    {
        // ループモード: すべてのポイント間の距離を加算（最後から最初へも含む）
        for (int i = 0; i < pathPositions.Length; i++)
        {
            int nextIndex = (i + 1) % pathPositions.Length;
            totalPathLength += Vector3.Distance(pathPositions[i], pathPositions[nextIndex]);
        }
    }
    else
    {
        // Once/PingPongループモード: 最初から最後までの距離を加算
        for (int i = 0; i < pathPositions.Length - 1; i++)
        {
            totalPathLength += Vector3.Distance(pathPositions[i], pathPositions[i + 1]);
        }
    }
}
```

**変更前:**
```csharp
void CalculateTotalPathLength()
{
    totalPathLength = 0f;

    // 最初から最後までの距離を加算（コピーした位置情報を使用）
    for (int i = 0; i < pathPositions.Length - 1; i++)
    {
        totalPathLength += Vector3.Distance(pathPositions[i], pathPositions[i + 1]);
    }
}
```

**変更後:**
Loopモード時のみ、最後から最初へのパスも含めるようにしました。

**UpdatePosition()メソッドの更新 (221-238行目):**

```csharp
/// <summary>
/// パス上の位置（0.0～1.0）に基づいて、実際の位置を更新
/// </summary>
/// <param name="t">パス上の位置（0.0～1.0）</param>
void UpdatePosition(float t)
{
    // イージングを適用
    float easedT = ApplyEasing(t, easingType);

    // 線形補間で位置を計算
    Vector3 newPosition = GetPositionOnPath(easedT);

    // ターゲットの位置を更新
    if (targetTransform != null)
    {
        targetTransform.position = newPosition;
    }
}
```

**変更前:**
```csharp
void UpdatePosition(float t)
{
    // 線形補間で位置を計算
    Vector3 newPosition = GetPositionOnPath(t);

    // ターゲットの位置を更新
    if (targetTransform != null)
    {
        targetTransform.position = newPosition;
    }
}
```

**変更後:**
ApplyEasing()を呼び出してイージングを適用するようにしました。

**GetPositionOnPath()メソッドの更新 (240-286行目):**

```csharp
/// <summary>
/// パス上の位置（0.0～1.0）から実際の座標を取得
/// 線形補間を使用
/// </summary>
/// <param name="t">パス上の位置（0.0～1.0）</param>
/// <returns>実際の座標</returns>
Vector3 GetPositionOnPath(float t)
{
    // tを0.0～1.0にクランプ
    t = Mathf.Clamp01(t);

    // パス全体の距離に対する現在の距離を計算
    float targetDistance = t * totalPathLength;
    float accumulatedDistance = 0f;

    // セグメント数を計算
    int segmentCount = (loopMode == LoopMode.Loop) ? pathPositions.Length : pathPositions.Length - 1;

    // どのセグメント上にいるかを特定（コピーした位置情報を使用）
    for (int i = 0; i < segmentCount; i++)
    {
        int nextIndex = (loopMode == LoopMode.Loop) ? (i + 1) % pathPositions.Length : i + 1;

        Vector3 segmentStart = pathPositions[i];
        Vector3 segmentEnd = pathPositions[nextIndex];
        float segmentLength = Vector3.Distance(segmentStart, segmentEnd);

        if (accumulatedDistance + segmentLength >= targetDistance)
        {
            // このセグメント上にいる
            float segmentT = (targetDistance - accumulatedDistance) / segmentLength;
            return Vector3.Lerp(segmentStart, segmentEnd, segmentT);
        }

        accumulatedDistance += segmentLength;
    }

    // 最後のポイントを返す（念のため）
    if (loopMode == LoopMode.Loop)
    {
        return pathPositions[0]; // ループモードは最初のポイント
    }
    else
    {
        return pathPositions[pathPositions.Length - 1]; // その他は最後のポイント
    }
}
```

**変更前:**
```csharp
Vector3 GetPositionOnPath(float t)
{
    // tを0.0～1.0にクランプ
    t = Mathf.Clamp01(t);

    // パス全体の距離に対する現在の距離を計算
    float targetDistance = t * totalPathLength;
    float accumulatedDistance = 0f;

    // どのセグメント上にいるかを特定（コピーした位置情報を使用）
    for (int i = 0; i < pathPositions.Length - 1; i++)
    {
        Vector3 segmentStart = pathPositions[i];
        Vector3 segmentEnd = pathPositions[i + 1];
        float segmentLength = Vector3.Distance(segmentStart, segmentEnd);

        if (accumulatedDistance + segmentLength >= targetDistance)
        {
            // このセグメント上にいる
            float segmentT = (targetDistance - accumulatedDistance) / segmentLength;
            return Vector3.Lerp(segmentStart, segmentEnd, segmentT);
        }

        accumulatedDistance += segmentLength;
    }

    // 最後のポイントを返す（念のため）
    return pathPositions[pathPositions.Length - 1];
}
```

**変更後:**
- segmentCountをloopModeに応じて計算
- nextIndexをloopModeに応じて計算（Loopモード時は剰余演算でループ）
- 最後のポイントの返却をloopModeに応じて変更

**ApplyEasing()メソッドの追加 (288-322行目):**

```csharp
/// <summary>
/// イージングを適用
/// </summary>
/// <param name="t">パス上の位置（0.0～1.0）</param>
/// <param name="type">イージングタイプ</param>
/// <returns>イージング適用後の位置</returns>
float ApplyEasing(float t, EasingType type)
{
    switch (type)
    {
        case EasingType.EaseIn:
            // 加速（2次関数）
            return t * t;

        case EasingType.EaseOut:
            // 減速（2次関数の逆）
            return 1f - (1f - t) * (1f - t);

        case EasingType.EaseInOut:
            // 加速→減速
            if (t < 0.5f)
            {
                return 2f * t * t;
            }
            else
            {
                return 1f - 2f * (1f - t) * (1f - t);
            }

        case EasingType.Linear:
        default:
            // 線形（イージングなし）
            return t;
    }
}
```

イージング関数を実装しました：

- **Linear**: イージングなし（t = t）
- **EaseIn**: 加速（t² = 2次関数）
- **EaseOut**: 減速（1 - (1-t)² = 2次関数の逆）
- **EaseInOut**: 加速→減速（t < 0.5: 2t², t >= 0.5: 1 - 2(1-t)²）

**OnDrawGizmos()メソッドの更新 (337-398行目):**

```csharp
// 実行前はpathPointsを使用、実行後はpathPositionsを使用
if (pathPositions != null && pathPositions.Length == pathPoints.Length)
{
    // 実行後: コピーした位置情報を使用
    if (loopMode == LoopMode.Loop)
    {
        // ループモード: すべてのポイントを結ぶ（最後から最初へも）
        for (int i = 0; i < pathPositions.Length; i++)
        {
            int nextIndex = (i + 1) % pathPositions.Length;
            Gizmos.DrawLine(pathPositions[i], pathPositions[nextIndex]);
        }
    }
    else
    {
        // Once/PingPongループモード: 最初から最後まで結ぶ
        for (int i = 0; i < pathPositions.Length - 1; i++)
        {
            Gizmos.DrawLine(pathPositions[i], pathPositions[i + 1]);
        }
    }

    // ポイントを描画
    foreach (Vector3 pos in pathPositions)
    {
        Gizmos.DrawSphere(pos, 0.2f);
    }
}
else
{
    // 実行前: pathPointsのTransformを直接使用
    if (loopMode == LoopMode.Loop)
    {
        // ループモード: すべてのポイントを結ぶ（最後から最初へも）
        for (int i = 0; i < pathPoints.Length; i++)
        {
            if (pathPoints[i] == null) continue;

            int nextIndex = (i + 1) % pathPoints.Length;
            if (pathPoints[nextIndex] == null) continue;

            Gizmos.DrawLine(pathPoints[i].position, pathPoints[nextIndex].position);
        }
    }
    else
    {
        // Once/PingPongループモード: 最初から最後まで結ぶ
        for (int i = 0; i < pathPoints.Length - 1; i++)
        {
            if (pathPoints[i] == null || pathPoints[i + 1] == null) continue;

            Gizmos.DrawLine(pathPoints[i].position, pathPoints[i + 1].position);
        }
    }

    // ポイントを描画
    foreach (Transform point in pathPoints)
    {
        if (point == null) continue;
        Gizmos.DrawSphere(point.position, 0.2f);
    }
}
```

**変更前:**
```csharp
// 実行前はpathPointsを使用、実行後はpathPositionsを使用
if (pathPositions != null && pathPositions.Length == pathPoints.Length)
{
    // 実行後: コピーした位置情報を使用
    for (int i = 0; i < pathPositions.Length - 1; i++)
    {
        Gizmos.DrawLine(pathPositions[i], pathPositions[i + 1]);
    }

    // ポイントを描画
    foreach (Vector3 pos in pathPositions)
    {
        Gizmos.DrawSphere(pos, 0.2f);
    }
}
else
{
    // 実行前: pathPointsのTransformを直接使用
    for (int i = 0; i < pathPoints.Length - 1; i++)
    {
        if (pathPoints[i] == null || pathPoints[i + 1] == null) continue;

        Gizmos.DrawLine(pathPoints[i].position, pathPoints[i + 1].position);
    }

    // ポイントを描画
    foreach (Transform point in pathPoints)
    {
        if (point == null) continue;
        Gizmos.DrawSphere(point.position, 0.2f);
    }
}
```

**変更後:**
loopModeに応じてGizmo描画を分岐し、Loopモード時は最後から最初へのパスも描画するようにしました。

## アーキテクチャの設計

### 3つのループモードの動作

#### Once（一度だけ移動）

```
Point 0 → Point 1 → Point 2 → Point 3 → 停止
                                         (enabled = false)
```

**特徴:**
- パスの端に到達したらenabled = falseで停止
- Update()が呼ばれなくなる
- 再開するにはSetPaused(false)またはenabled = trueを呼び出す

**用途:**
- 一度だけ動くプラットフォーム
- トリガーで起動する移動障害物
- カットシーンでの移動

#### Loop（ループ）

```
Point 0 → Point 1 → Point 2 → Point 3 → Point 0 → ...
└────────────────────────────────────────┘
```

**特徴:**
- currentPathPositionが1.0を超えたら1.0を減算
- 0.0～1.0の範囲でループ
- 待機なし
- 最後のポイントから最初のポイントへ滑らかに移動

**用途:**
- 円形に移動するプラットフォーム
- 無限ループする障害物
- エレベーター（閉じた経路）

#### PingPongLoop（往復ループ）

```
Point 0 → Point 1 → Point 2 → Point 3
                                  ↓ 待機（waitTimeAtEnd）
Point 0 ← Point 1 ← Point 2 ← Point 3
  ↓ 待機（waitTimeAtEnd）
Point 0 → ...
```

**特徴:**
- 端に到達したら待機（isWaiting = true）
- waitTimeAtEnd経過後にdirection *= -1で反転
- 往復を繰り返す

**用途:**
- 往復するプラットフォーム
- 左右に動く障害物
- エレベーター（直線経路）

### イージング機能

イージングは、パス上の位置パラメータ`t`（0.0～1.0）に対して適用されます。

**Linear（線形）:**
```
easedT = t
```
- イージングなし
- 一定速度で移動

**EaseIn（加速）:**
```
easedT = t²
```
- 2次関数
- 最初は遅く、徐々に加速
- t = 0.0: easedT = 0.0
- t = 0.5: easedT = 0.25
- t = 1.0: easedT = 1.0

**EaseOut（減速）:**
```
easedT = 1 - (1 - t)²
```
- 2次関数の逆
- 最初は速く、徐々に減速
- t = 0.0: easedT = 0.0
- t = 0.5: easedT = 0.75
- t = 1.0: easedT = 1.0

**EaseInOut（加速→減速）:**
```
t < 0.5: easedT = 2t²
t >= 0.5: easedT = 1 - 2(1 - t)²
```
- 最初は加速、後半は減速
- t = 0.0: easedT = 0.0
- t = 0.5: easedT = 0.5
- t = 1.0: easedT = 1.0

### 直線的な移動とイージングの組み合わせ

以前の実装では、Catmull-Romスプライン補間とイージングの相性が悪く、予測困難な動作になっていました。

今回の実装では、**直線的な線形補間**をベースとしているため、イージングを適用しても予測可能な動作が得られます。

**動作の流れ:**

```
1. currentPathPosition（0.0～1.0）を線形に変化
   ↓
2. ApplyEasing()でイージング適用 → easedT
   ↓
3. GetPositionOnPath(easedT)で実際の座標を計算
   ↓
4. 直線補間（Vector3.Lerp）で座標を算出
```

**例: EaseInで移動する場合**

```
t = 0.0 → easedT = 0.0 → 位置: Point 0
t = 0.5 → easedT = 0.25 → 位置: Point 0から25%の地点
t = 1.0 → easedT = 1.0 → 位置: Point 3
```

最初は遅く（t = 0.5でもまだ25%の地点）、徐々に加速します。

## 動作確認

### 期待される動作:

**Onceモード + Linear:**
- 一定速度で移動し、端で停止

**Onceモード + EaseIn:**
- 最初は遅く、徐々に加速して移動し、端で停止

**Loopモード + Linear:**
- 一定速度でループ

**Loopモード + EaseOut:**
- 最初は速く、各ポイントに近づくと減速

**PingPongLoopモード + EaseInOut:**
- 加速→減速で往復、端で待機

### テスト手順:

1. Unity Editorでシーンを開く
2. GameObjectを作成（例: MovingPlatform）
3. MovingCurveコンポーネントをアタッチ
4. Path Pointsに複数のTransformを設定（例: 4つ）
5. Loop Modeを選択（Once, Loop, PingPong Loop）
6. Easing Typeを選択（Linear, Ease In, Ease Out, Ease InOut）
7. Move Speed: 2.0
8. Wait Time At End: 1.0（PingPongLoopモード時）
9. Initial Position: 0.0
10. ゲームを実行して、選択したモードとイージングで動作することを確認

## 備考

- MovingCurveコンポーネントにループモード（Loop、PingPongLoop）を追加しました
- イージング機能（Linear, Ease In, Ease Out, Ease InOut）を追加しました
- 3種類の繰り返しモード（Once, Loop, PingPong Loop）を実装しました
- LoopMode列挙型とEasingType列挙型を追加しました
- Update()メソッドで3種類のループモードに対応しました
- CalculateTotalPathLength()、GetPositionOnPath()、OnDrawGizmos()をループモード対応にしました
- ApplyEasing()メソッドを追加し、4種類のイージングを実装しました
- 直線的な線形補間とイージングの組み合わせにより、予測可能な動作が得られます
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
- コード行数: 249行 → 437行（188行増加、約75%増加）
