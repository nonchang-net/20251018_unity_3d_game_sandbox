# 作業レポート 2025-10-16 22:39

## 変更内容の概要

- MovingPlatformタグを持つ移動するコライダーに着地したキャラクターが、プラットフォームに追従して移動するように実装しました
- CharacterController実装とRigidbody+Collider実装の両方に対応しました
- プラットフォームの移動量を検出し、キャラクターの位置に反映する仕組みを追加しました

## 変更理由

ユーザーから「moving platformに着地後、キャラクターが追従して動作しません。移動するコライダーオブジェクトに『MovingPlatform』タグを追加しました。着地時に追従するように修正してください」という指示がありました。

### 問題の詳細

MovingCurveで動作する移動プラットフォームにキャラクターが着地しても、プラットフォームの移動に追従せず、その場に留まってしまう問題がありました。これは、キャラクターの移動処理がプラットフォームの移動を考慮していなかったためです。

### 解決策

1. **プラットフォーム検出**: Raycast（Rigidbody実装）またはOnControllerColliderHit（CharacterController実装）でMovingPlatformタグを持つコライダーを検出
2. **移動量の追跡**: プラットフォームの前フレームと現フレームの位置差を計算
3. **キャラクターの移動**: プラットフォームの移動量をキャラクターに適用

## 変更したファイル

### 変更: Assets/Scripts/GameManager/GameInputManager.cs

**フィールドの追加 (86-88行目):**

```csharp
// MovingPlatform追従用
private Transform currentPlatform = null; // 現在接地しているプラットフォーム
private Vector3 previousPlatformPosition = Vector3.zero; // 前フレームのプラットフォーム位置
```

プラットフォーム追従に必要な情報を保持するフィールドを追加しました。

**HandleMovementCharacterController()の更新 (266-275行目):**

```csharp
void HandleMovementCharacterController()
{
    // MovingPlatform追従処理
    HandlePlatformMovement();

    // ジャンプ処理（移動処理の前に実行）
    if (Input.GetButtonDown("Jump") && characterController.isGrounded && !isCrouched)
    {
        velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
    }
```

**変更前:**
```csharp
void HandleMovementCharacterController()
{
    // ジャンプ処理（移動処理の前に実行）
    if (Input.GetButtonDown("Jump") && characterController.isGrounded && !isCrouched)
    {
        velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
    }
```

**変更後:**
移動処理の先頭で`HandlePlatformMovement()`を呼び出し、プラットフォームの移動に追従するようにしました。

**HandleMovementRigidbody()の更新 (360-369行目):**

```csharp
void HandleMovementRigidbody()
{
    // MovingPlatform追従処理
    HandlePlatformMovement();

    // ジャンプ処理
    if (Input.GetButtonDown("Jump") && isGroundedRigidbody && !isCrouched)
    {
        rigidbody.AddForce(Vector3.up * Mathf.Sqrt(jumpHeight * -2f * Physics.gravity.y), ForceMode.VelocityChange);
    }
```

**変更前:**
```csharp
void HandleMovementRigidbody()
{
    // ジャンプ処理
    if (Input.GetButtonDown("Jump") && isGroundedRigidbody && !isCrouched)
    {
        rigidbody.AddForce(Vector3.up * Mathf.Sqrt(jumpHeight * -2f * Physics.gravity.y), ForceMode.VelocityChange);
    }
```

**変更後:**
Rigidbody実装でも同様に、移動処理の先頭で`HandlePlatformMovement()`を呼び出すようにしました。

**CheckGroundRigidbody()の更新 (441-508行目):**

```csharp
void CheckGroundRigidbody()
{
    if (collider == null) return;

    // Colliderの種類に応じて地面判定の位置とレイキャスト距離を計算
    Vector3 origin;
    float checkDistance;

    if (collider is CapsuleCollider capsule)
    {
        // CapsuleCollider: カプセルの底から判定
        origin = targetCharacter.transform.position + Vector3.up * (capsule.radius + 0.01f);
        checkDistance = capsule.radius + groundCheckDistance;
    }
    else if (collider is BoxCollider box)
    {
        // BoxCollider: ボックスの底から判定
        Vector3 center = box.center;
        Vector3 size = box.size;
        float halfHeight = size.y / 2f;
        origin = targetCharacter.transform.position + center + Vector3.down * (halfHeight - 0.01f);
        checkDistance = groundCheckDistance;
    }
    else if (collider is SphereCollider sphere)
    {
        // SphereCollider: 球の底から判定
        origin = targetCharacter.transform.position + sphere.center + Vector3.down * (sphere.radius - 0.01f);
        checkDistance = groundCheckDistance;
    }
    else
    {
        // その他のCollider: Boundsを使用
        Bounds bounds = collider.bounds;
        origin = new Vector3(bounds.center.x, bounds.min.y + 0.01f, bounds.center.z);
        checkDistance = groundCheckDistance;
    }

    // Raycastで地面判定とMovingPlatform検出
    RaycastHit hit;
    isGroundedRigidbody = Physics.Raycast(origin, Vector3.down, out hit, checkDistance);

    // MovingPlatformタグの検出
    if (isGroundedRigidbody && hit.collider != null)
    {
        if (hit.collider.CompareTag("MovingPlatform"))
        {
            // 新しいプラットフォームに乗った
            if (currentPlatform != hit.collider.transform)
            {
                currentPlatform = hit.collider.transform;
                previousPlatformPosition = currentPlatform.position;
            }
        }
        else
        {
            // 通常の地面に着地
            currentPlatform = null;
        }
    }
    else
    {
        // 空中にいる
        currentPlatform = null;
    }
}
```

**変更前:**
```csharp
isGroundedRigidbody = Physics.Raycast(origin, Vector3.down, checkDistance);
```

**変更後:**
- Raycastの結果から`RaycastHit`を取得するように変更
- `hit.collider`から接地しているコライダーを取得
- MovingPlatformタグを持つ場合、`currentPlatform`に記録
- 空中または通常の地面の場合は`currentPlatform`をnullに設定

**OnControllerColliderHit()メソッドの追加 (797-825行目):**

```csharp
/// <summary>
/// CharacterController実装でのコライダー接触検出
/// MovingPlatformタグを検出
/// </summary>
void OnControllerColliderHit(ControllerColliderHit hit)
{
    if (implementationType != CharacterImplementationType.CharacterController)
        return;

    // 下方向の接触（地面に着地）かどうかを判定
    if (hit.normal.y > 0.5f && characterController.isGrounded)
    {
        // MovingPlatformタグの検出
        if (hit.collider.CompareTag("MovingPlatform"))
        {
            // 新しいプラットフォームに乗った
            if (currentPlatform != hit.collider.transform)
            {
                currentPlatform = hit.collider.transform;
                previousPlatformPosition = currentPlatform.position;
            }
        }
        else
        {
            // 通常の地面に着地
            currentPlatform = null;
        }
    }
}
```

CharacterController実装用に、OnControllerColliderHit()でMovingPlatformタグを検出する処理を追加しました。

**HandlePlatformMovement()メソッドの追加 (827-856行目):**

```csharp
/// <summary>
/// MovingPlatform追従処理
/// プラットフォームの移動量をキャラクターに適用
/// </summary>
void HandlePlatformMovement()
{
    // プラットフォームに乗っていない場合は何もしない
    if (currentPlatform == null || !IsGrounded())
    {
        currentPlatform = null;
        return;
    }

    // プラットフォームの移動量を計算
    Vector3 platformMovement = currentPlatform.position - previousPlatformPosition;

    // キャラクターをプラットフォームの移動量分移動させる
    if (implementationType == CharacterImplementationType.CharacterController && characterController != null)
    {
        characterController.Move(platformMovement);
    }
    else if (implementationType == CharacterImplementationType.RigidbodyAndCollider && rigidbody != null)
    {
        // Rigidbodyの場合は位置を直接加算
        targetCharacter.transform.position += platformMovement;
    }

    // 次フレーム用にプラットフォームの位置を記録
    previousPlatformPosition = currentPlatform.position;
}
```

プラットフォームの移動量を計算し、キャラクターに適用する処理を追加しました。

## アーキテクチャの設計

### プラットフォーム追従の仕組み

**フレームごとの処理:**

```
1. FixedUpdate() または OnControllerColliderHit()
   ↓
2. MovingPlatformタグの検出
   - Rigidbody実装: CheckGroundRigidbody() で Raycast
   - CharacterController実装: OnControllerColliderHit() で接触判定
   ↓
3. currentPlatform に記録
   - previousPlatformPosition にプラットフォームの位置を保存
   ↓
4. Update()
   ↓
5. HandlePlatformMovement()
   - プラットフォームの移動量を計算: platformMovement = currentPlatform.position - previousPlatformPosition
   - キャラクターを移動: characterController.Move(platformMovement) または transform.position += platformMovement
   - previousPlatformPosition を更新
```

### 実装方式の違い

#### CharacterController実装

**検出方法:**
- `OnControllerColliderHit()`で接触を検出
- `hit.normal.y > 0.5f`で下方向の接触（地面）を判定
- `characterController.isGrounded`で接地状態を確認

**移動方法:**
- `characterController.Move(platformMovement)`でプラットフォームの移動量を適用

#### Rigidbody+Collider実装

**検出方法:**
- `CheckGroundRigidbody()`で`Physics.Raycast()`を使用
- Colliderの種類（CapsuleCollider、BoxCollider、SphereCollider）に応じて適切な原点を計算
- Raycast結果の`hit.collider`からプラットフォームを検出

**移動方法:**
- `targetCharacter.transform.position += platformMovement`で直接位置を加算

### プラットフォーム検出の条件

```csharp
// CharacterController実装
if (hit.normal.y > 0.5f && characterController.isGrounded)

// Rigidbody実装
if (isGroundedRigidbody && hit.collider != null)
```

両方の実装で、地面に接地している状態のみプラットフォームを検出します。

### プラットフォームの移動量計算

```csharp
Vector3 platformMovement = currentPlatform.position - previousPlatformPosition;
```

前フレームのプラットフォーム位置と現フレームの位置の差分を計算することで、プラットフォームの移動量を取得します。

### 空中時の処理

```csharp
if (currentPlatform == null || !IsGrounded())
{
    currentPlatform = null;
    return;
}
```

空中にいる場合や、プラットフォームから離れた場合は`currentPlatform`をnullにして追従を停止します。

## 利点

### 1. 両方の実装方式に対応

**CharacterController実装:**
- OnControllerColliderHit()による正確な接触検出
- characterController.Move()による移動

**Rigidbody+Collider実装:**
- Raycastによる地面判定
- transform.position加算による移動

### 2. 滑らかな追従

プラットフォームの移動量を毎フレーム計算してキャラクターに適用することで、プラットフォームの動きに自然に追従します。

### 3. MovingPlatformタグの活用

タグでプラットフォームを識別することで、通常の地面と移動プラットフォームを区別できます。

## 使用例

### シーン設定

1. **MovingPlatformオブジェクト:**
   - MovingCurveコンポーネントをアタッチ
   - Collider（BoxColliderなど）をアタッチ
   - タグを「MovingPlatform」に設定

2. **キャラクター:**
   - CharacterControllerまたはRigidbody+Colliderを持つ
   - GameInputManagerで制御されている

### 実行時の動作

1. キャラクターがMovingPlatformに着地
2. GameInputManagerがMovingPlatformタグを検出
3. プラットフォームの移動量をキャラクターに適用
4. キャラクターがプラットフォームに追従して移動
5. キャラクターがジャンプまたはプラットフォームから離れると追従を停止

### 例: 往復プラットフォーム

```
設定:
  MovingPlatform (MovingCurveコンポーネント):
    - Loop Mode: PingPong Loop
    - Move Speed: 2.0
    - Path Points: 始点と終点（10m離れた位置）

  Character:
    - CharacterController または Rigidbody+Collider
    - GameInputManagerで制御

動作:
  1. キャラクターがプラットフォームに着地
  2. プラットフォームが往復移動
  3. キャラクターがプラットフォームに追従して移動
  4. キャラクターがジャンプすると追従を停止
  5. 再度着地すると追従を再開
```

## 動作確認

### 期待される動作:

1. **MovingPlatformへの着地**: キャラクターがMovingPlatformタグを持つプラットフォームに着地すると、プラットフォームに追従して移動する
2. **ジャンプ時の追従停止**: キャラクターがジャンプすると追従を停止する
3. **通常の地面**: MovingPlatformタグを持たない通常の地面に着地しても追従は発生しない
4. **CharacterController実装**: OnControllerColliderHit()でプラットフォームを検出
5. **Rigidbody実装**: Raycastでプラットフォームを検出

### テスト手順:

1. Unity Editorでシーンを開く
2. MovingPlatformオブジェクトを作成
3. MovingCurveコンポーネントをアタッチし、パスを設定
4. Collider（BoxColliderなど）をアタッチ
5. タグを「MovingPlatform」に設定
6. ゲームを実行して、キャラクターがプラットフォームに着地することを確認
7. プラットフォームが移動する際に、キャラクターが追従することを確認
8. キャラクターがジャンプすると追従が停止することを確認
9. 再度着地すると追従が再開することを確認

## 備考

- MovingPlatformタグを持つコライダーに着地したキャラクターが、プラットフォームに追従して移動するように実装しました
- CharacterController実装とRigidbody+Collider実装の両方に対応しました
- OnControllerColliderHit()（CharacterController実装）とRaycast（Rigidbody実装）でプラットフォームを検出します
- プラットフォームの移動量を毎フレーム計算し、キャラクターに適用します
- 空中にいる場合やプラットフォームから離れた場合は追従を停止します
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
- コード行数: 768行 → 865行（97行増加、約13%増加）
