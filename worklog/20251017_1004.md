# 作業レポート 2025-10-17 10:04

## 変更内容の概要

- キーボード入力に対応したデバッグコマンドシステムを実装しました
- Warp（ワープ）、Death（死亡）、Heal（回復）の3種類のデバッグコマンドを実装しました
- 任意個数のデバッグコマンドをInspectorで設定できるようにしました

## 変更理由

ユーザーから「デバッグ機能を拡充していきます。DebugCommands.csをヒエラルキーに配置しました。任意個数のキーボード入力に対するデバッグ操作を設定できるようにしてください。まずはフルキーボードの1,2,3に所定のtransformにワープする機能を設定しようと思います。デバッグ機能はenumから選べるようにします。まずは『warp』を実装してください。それぞれワープ先transformを指定できるようにしてください。任意タイミングで死亡状態にする『death』、任意タイミングでHPを1回復する『heal』デバッグコマンドも選べるようにしてください。（このコマンドの際のtransform指定部分は無視で良いでしょう）」という指示がありました。

### 実装の詳細

Enum-based command systemを採用し、Serializable配列によって任意個数のコマンドを設定可能にしました。CharacterController対応のワープ処理、UserDataManager統合の死亡・回復処理を実装しました。

## 変更したファイル

### 新規作成: Assets/Scripts/Utilities/DebugCommands.cs

**DebugCommandType enumの定義 (7-12行目):**

```csharp
/// <summary>
/// デバッグコマンドの種類
/// </summary>
public enum DebugCommandType
{
    Warp,   // 指定位置にワープ
    Death,  // 死亡状態にする
    Heal    // HPを1回復
}
```

デバッグコマンドの種類を定義するenumを作成しました。Warp、Death、Healの3種類です。

**DebugCommandEntry classの定義 (17-28行目):**

```csharp
/// <summary>
/// デバッグコマンドのエントリ
/// </summary>
[Serializable]
public class DebugCommandEntry
{
    [Tooltip("入力キー")]
    public KeyCode key;

    [Tooltip("コマンドの種類")]
    public DebugCommandType commandType;

    [Tooltip("ワープ先Transform（Warpコマンド用）")]
    public Transform warpTarget;
}
```

デバッグコマンドのエントリを定義するSerializableクラスを作成しました。KeyCode、commandType、warpTargetの3つのフィールドを持ちます。

**DebugCommands classのフィールド (36-46行目):**

```csharp
[Header("デバッグコマンド設定")]
[Tooltip("デバッグコマンドのリスト")]
[SerializeField] private DebugCommandEntry[] debugCommands;

[Header("参照")]
[Tooltip("GameManager")]
[SerializeField] private GameManager gameManager;

[Header("デバッグ設定")]
[Tooltip("デバッグログを表示する")]
[SerializeField] private bool enableDebugLog = true;
```

デバッグコマンド配列、GameManager参照、デバッグログの有効化フラグを定義しました。

**Awake()メソッド (48-59行目):**

```csharp
void Awake()
{
    // GameManagerの自動検出
    if (gameManager == null)
    {
        gameManager = FindFirstObjectByType<GameManager>();
        if (gameManager == null)
        {
            Debug.LogWarning("DebugCommands: GameManagerが見つかりません。一部のデバッグコマンドが動作しない可能性があります。");
        }
    }
}
```

GameManagerを自動検出するAwake()メソッドを実装しました。

**Update()メソッド (61-82行目):**

```csharp
void Update()
{
    // デバッグコマンドの入力チェック
    if (debugCommands == null || debugCommands.Length == 0)
    {
        return;
    }

    foreach (var command in debugCommands)
    {
        if (command == null)
        {
            continue;
        }

        // キー入力をチェック
        if (Input.GetKeyDown(command.key))
        {
            ExecuteCommand(command);
        }
    }
}
```

Update()メソッドでデバッグコマンド配列をループし、キー入力をチェックしてコマンドを実行します。

**ExecuteCommand()メソッド (88-105行目):**

```csharp
/// <summary>
/// デバッグコマンドを実行
/// </summary>
/// <param name="command">実行するコマンド</param>
void ExecuteCommand(DebugCommandEntry command)
{
    switch (command.commandType)
    {
        case DebugCommandType.Warp:
            ExecuteWarp(command);
            break;
        case DebugCommandType.Death:
            ExecuteDeath();
            break;
        case DebugCommandType.Heal:
            ExecuteHeal();
            break;
        default:
            Debug.LogWarning($"DebugCommands: 未知のコマンドタイプ: {command.commandType}");
            break;
    }
}
```

Switch文でコマンドタイプに応じて適切な実行メソッドを呼び出します。

**ExecuteWarp()メソッド (111-153行目):**

```csharp
/// <summary>
/// ワープコマンドを実行
/// </summary>
/// <param name="command">コマンドエントリ</param>
void ExecuteWarp(DebugCommandEntry command)
{
    if (command.warpTarget == null)
    {
        Debug.LogWarning($"DebugCommands: ワープ先が設定されていません（キー: {command.key}）");
        return;
    }

    if (gameManager == null)
    {
        Debug.LogWarning("DebugCommands: GameManagerが設定されていません。ワープできません。");
        return;
    }

    GameObject activeCharacter = gameManager.GetActiveCharacter();
    if (activeCharacter == null)
    {
        Debug.LogWarning("DebugCommands: アクティブキャラクターが見つかりません。ワープできません。");
        return;
    }

    // CharacterControllerを取得
    CharacterController characterController = activeCharacter.GetComponent<CharacterController>();
    if (characterController != null)
    {
        // CharacterControllerの場合は無効化してから移動
        characterController.enabled = false;
        activeCharacter.transform.position = command.warpTarget.position;
        activeCharacter.transform.rotation = command.warpTarget.rotation;
        characterController.enabled = true;
    }
    else
    {
        // CharacterController以外の場合は直接移動
        activeCharacter.transform.position = command.warpTarget.position;
        activeCharacter.transform.rotation = command.warpTarget.rotation;
    }

    if (enableDebugLog)
    {
        Debug.Log($"DebugCommands: キャラクターを '{command.warpTarget.name}' にワープしました（キー: {command.key}）");
    }
}
```

ワープコマンドを実装しました。CharacterController対応のために、無効化→移動→有効化のパターンを使用します。

**ExecuteDeath()メソッド (158-168行目):**

```csharp
/// <summary>
/// 死亡コマンドを実行
/// </summary>
void ExecuteDeath()
{
    // 現在のHPと同じダメージを与えて死亡させる
    int currentHp = UserDataManager.Data.CurrentHp.CurrentValue;
    UserDataManager.TakeDamage(currentHp, gameObject);

    if (enableDebugLog)
    {
        Debug.Log($"DebugCommands: 死亡コマンドを実行しました");
    }
}
```

死亡コマンドを実装しました。現在のHPと同じダメージを与えて死亡させます。

**ExecuteHeal()メソッド (173-181行目):**

```csharp
/// <summary>
/// 回復コマンドを実行
/// </summary>
void ExecuteHeal()
{
    UserDataManager.HealHp(1);

    if (enableDebugLog)
    {
        Debug.Log($"DebugCommands: HPを1回復しました");
    }
}
```

回復コマンドを実装しました。UserDataManager.HealHp(1)でHPを1回復します。

## アーキテクチャの設計

### デバッグコマンドシステムの仕組み

```
DebugCommands MonoBehaviour
  ↓
Update() でキー入力を監視
  ↓
debugCommands 配列をループ
  ↓
Input.GetKeyDown(command.key) でキー入力を検出
  ↓
ExecuteCommand(command) を呼び出し
  ↓
Switch文で commandType に応じて分岐
  ↓
  - Warp: ExecuteWarp(command)
  - Death: ExecuteDeath()
  - Heal: ExecuteHeal()
```

### Enum-based Command System

```
DebugCommandType enum:
  - Warp: 指定位置にワープ
  - Death: 死亡状態にする
  - Heal: HPを1回復

DebugCommandEntry class (Serializable):
  - KeyCode key: 入力キー
  - DebugCommandType commandType: コマンドタイプ
  - Transform warpTarget: ワープ先（Warpコマンド用）

DebugCommands class:
  - DebugCommandEntry[] debugCommands: コマンド配列
  - GameManager gameManager: GameManager参照
  - bool enableDebugLog: デバッグログの有効化
```

### Warpコマンドの処理フロー

```
ExecuteWarp(command) が呼ばれる
  ↓
warpTarget が null でないことを確認
  ↓
GameManager が null でないことを確認
  ↓
GameManager.GetActiveCharacter() でアクティブキャラクターを取得
  ↓
CharacterController を取得
  ↓
CharacterController がある場合:
  - characterController.enabled = false
  - transform.position = warpTarget.position
  - transform.rotation = warpTarget.rotation
  - characterController.enabled = true
  ↓
CharacterController がない場合:
  - transform.position = warpTarget.position
  - transform.rotation = warpTarget.rotation
  ↓
enableDebugLog が true の場合はログを出力
```

### Deathコマンドの処理フロー

```
ExecuteDeath() が呼ばれる
  ↓
UserDataManager.Data.CurrentHp.CurrentValue で現在のHPを取得
  ↓
UserDataManager.TakeDamage(currentHp, gameObject) で現在のHPと同じダメージを与える
  ↓
enableDebugLog が true の場合はログを出力
```

### Healコマンドの処理フロー

```
ExecuteHeal() が呼ばれる
  ↓
UserDataManager.HealHp(1) でHPを1回復
  ↓
enableDebugLog が true の場合はログを出力
```

### Inspector設定の例

```
Debug Commands配列:
  - Element 0:
      Key: Alpha1
      Command Type: Warp
      Warp Target: WarpPoint1
  - Element 1:
      Key: Alpha2
      Command Type: Warp
      Warp Target: WarpPoint2
  - Element 2:
      Key: Alpha3
      Command Type: Warp
      Warp Target: WarpPoint3
  - Element 3:
      Key: D
      Command Type: Death
      Warp Target: (null)
  - Element 4:
      Key: H
      Command Type: Heal
      Warp Target: (null)
```

## 利点

### 1. 柔軟なコマンド設定

任意個数のデバッグコマンドをInspectorで設定できます。配列のサイズを変更するだけで、コマンド数を増減できます。

### 2. Enum-based Type Safety

DebugCommandTypeのenumでコマンドタイプを選択するため、タイプセーフです。誤ったコマンドタイプを設定することがありません。

### 3. 拡張性

新しいコマンドタイプを追加する場合は、enumに追加し、Switchケースを追加するだけです。

### 4. CharacterController対応

ワープ処理でCharacterControllerを無効化してから移動するため、衝突判定の問題を回避できます。

### 5. UserDataManager統合

死亡・回復処理はUserDataManagerを使用するため、既存のゲームシステムと統合されています。

### 6. デバッグログ制御

enableDebugLogフラグでデバッグログの表示を制御できます。

## 使用例

### シーン設定

**DebugCommandsの配置:**
1. Hierarchyに空のGameObjectを作成（例: DebugCommands）
2. DebugCommandsコンポーネントをアタッチ
3. GameManagerは自動検出される

**ワープポイントの設定:**
1. Hierarchyに空のGameObjectを作成（例: WarpPoint1, WarpPoint2, WarpPoint3）
2. 各ワープポイントを適切な位置に配置
3. DebugCommandsのdebugCommands配列に追加

**コマンドの設定:**
1. DebugCommandsのdebugCommands配列のサイズを設定（例: 5）
2. 各要素にKey、CommandType、WarpTarget（Warpコマンドの場合のみ）を設定

### 例1: 3つのワープポイント

```
Inspector設定:
  - Debug Commands配列 (サイズ: 3)
    - Element 0: Key=Alpha1, CommandType=Warp, WarpTarget=WarpPoint1
    - Element 1: Key=Alpha2, CommandType=Warp, WarpTarget=WarpPoint2
    - Element 2: Key=Alpha3, CommandType=Warp, WarpTarget=WarpPoint3

動作:
  - キーボードの1キーを押す: WarpPoint1にワープ
  - キーボードの2キーを押す: WarpPoint2にワープ
  - キーボードの3キーを押す: WarpPoint3にワープ
```

### 例2: ワープ + 死亡 + 回復

```
Inspector設定:
  - Debug Commands配列 (サイズ: 5)
    - Element 0: Key=Alpha1, CommandType=Warp, WarpTarget=WarpPoint1
    - Element 1: Key=Alpha2, CommandType=Warp, WarpTarget=WarpPoint2
    - Element 2: Key=Alpha3, CommandType=Warp, WarpTarget=WarpPoint3
    - Element 3: Key=D, CommandType=Death, WarpTarget=(null)
    - Element 4: Key=H, CommandType=Heal, WarpTarget=(null)

動作:
  - キーボードの1, 2, 3キーを押す: それぞれのワープポイントにワープ
  - キーボードのDキーを押す: 死亡状態になる
  - キーボードのHキーを押す: HPが1回復する
```

### 例3: 複数のワープポイント

```
Inspector設定:
  - Debug Commands配列 (サイズ: 10)
    - Element 0-9: Key=Alpha1~Alpha0, CommandType=Warp, WarpTarget=WarpPoint1~10

動作:
  - キーボードの1～0キーで10個のワープポイントに移動可能
```

## 動作確認

### 期待される動作:

1. **初期状態**: デバッグコマンドが設定されている
2. **キー入力**: 設定されたキーを押すとコマンドが実行される
3. **Warpコマンド**: アクティブキャラクターが指定位置にワープする
4. **Deathコマンド**: キャラクターが死亡状態になる
5. **Healコマンド**: HPが1回復する
6. **デバッグログ**: enableDebugLogがtrueの場合、ログが出力される
7. **GameManager未設定**: 警告ログが表示され、Warpコマンドは動作しない

### テスト手順:

1. Unity Editorでシーンを開く
2. Hierarchyに空のGameObjectを作成し、DebugCommandsコンポーネントをアタッチ
3. ワープポイント用の空のGameObjectを作成し、配置
4. DebugCommandsのdebugCommands配列を設定
   - Element 0: Key=Alpha1, CommandType=Warp, WarpTarget=WarpPoint1
   - Element 1: Key=D, CommandType=Death
   - Element 2: Key=H, CommandType=Heal
5. ゲームを実行
6. キーボードの1キーを押してワープすることを確認
7. キーボードのDキーを押して死亡することを確認
8. キャラクターをリスポーンさせる
9. キーボードのHキーを押してHPが回復することを確認
10. デバッグログが出力されることを確認

## 備考

- キーボード入力に対応したデバッグコマンドシステムを実装しました
- Warp、Death、Healの3種類のデバッグコマンドを実装しました
- 任意個数のデバッグコマンドをInspectorで設定できます
- Enum-based command systemでタイプセーフな設計です
- CharacterController対応のワープ処理を実装しました
- UserDataManager統合の死亡・回復処理を実装しました
- GameManagerは自動検出されます
- enableDebugLogフラグでデバッグログの表示を制御できます
- 診断ツールで確認した結果、コンパイルエラーはありませんでした
- DebugCommands.cs: 新規作成（182行）
