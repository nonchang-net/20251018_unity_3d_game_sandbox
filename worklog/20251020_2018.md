# ワークログ: GameInputManagerのリファクタリング

作成日時: 2025-10-20 20:18

## 変更した内容の概要

- GameCharacterManager.csを新規作成し、キャラクターの移動・アニメーション・状態管理の責務を全て移動しました
- GameInputManager.csを入力管理専任にリファクタリングし、937行から181行に削減しました（約80%削減）
- GameInputManagerとGameCharacterManagerが疎結合で連携する設計に変更しました

## なぜそのように変更しようと考えたか

- 単一責任の原則に従い、GameInputManagerが入力管理とキャラクター処理の2つの責務を持っていた問題を解決するため
- GameInputManagerは「入力を受け取り配信する」、GameCharacterManagerは「キャラクターを制御する」と明確に責務を分離することで、コードの保守性と可読性を向上させるため
- キャラクター処理の機能追加や変更時に、入力管理部分に影響を与えないようにするため

## 実装詳細

### 新規作成: Assets/Scripts/GameManager/GameCharacterManager.cs (852行)

#### 責務
- キャラクターの初期化と実装タイプ判定（CharacterController / Rigidbody+Collider）
- CharacterController/Rigidbody実装の移動処理
- アニメーション制御
- ジャンプ処理
- ノックバック処理
- ハイジャンプ処理
- 死亡/リスポーン処理
- ポストプロセッシング連携
- MovingPlatform追従処理
- 地面判定

#### 主要な公開メソッド

```csharp
/// <summary>
/// GameInputManagerから入力値を設定
/// </summary>
public void SetMovementInput(Vector2 movementInput)
public void SetJumpRequest(bool jumpRequest)
public void SetSprintRequest(bool sprintRequest)

/// <summary>
/// カメラトラッカーを設定
/// </summary>
public void SetCameraTracker(CharacterTracker tracker)

/// <summary>
/// 制御対象のキャラクターを設定
/// </summary>
public void SetTargetCharacter(GameObject character)
```

#### R3イベント購読

```csharp
void Start()
{
    // イベント購読
    var damageSubscription = UserDataManager.Data.OnDamageReceived.Subscribe(damageInfo =>
    {
        OnDamageReceived(damageInfo);
    });

    var deadSubscription = UserDataManager.Data.IsDead.Subscribe(isDead =>
    {
        if (isDead)
        {
            OnDead();
        }
        else
        {
            OnRespawn();
        }
    });

    var highJumpSubscription = UserDataManager.Data.OnHighJump.Subscribe(highJumpInfo =>
    {
        OnHighJump(highJumpInfo);
    });

    // disposable登録
    disposable = Disposable.Combine(
        damageSubscription,
        deadSubscription,
        highJumpSubscription
    );
}
```

### 変更: Assets/Scripts/GameManager/GameInputManager.cs (937行 → 181行)

#### 削除した機能（GameCharacterManagerに移動）
- キャラクターの実装タイプ判定
- 移動処理（CharacterController/Rigidbody両対応）
- アニメーション制御
- ジャンプ処理
- ノックバック処理
- ハイジャンプ処理
- 死亡/リスポーン処理
- ポストプロセッシング連携
- MovingPlatform追従処理
- 地面判定
- R3イベント購読（Damage、Dead、HighJump）

#### 残した機能（入力管理専任）
- Input Systemのコールバック受信
- 入力値の保持（movement、requestJump、requestSprint、requestResetCamera）
- カメラ制御連携（CharacterTrackerへのLook入力送信、カメラリセット）
- UI操作連携（FPS表示切り替え、VRMロード、キャラクター切り替え）

#### 新規追加した参照

```csharp
[Header("参照")]
[SerializeField] private GameCharacterManager gameCharacterManager;
```

#### 入力値の送信処理

```csharp
void Update()
{
    // カメラリセット処理
    if (requestResetCamera)
    {
        cameraTracker.ResetCamera();
        requestResetCamera = false;
    }

    // 入力値をGameCharacterManagerに送信
    if (gameCharacterManager != null)
    {
        gameCharacterManager.SetMovementInput(movement);
        gameCharacterManager.SetJumpRequest(requestJump);
        gameCharacterManager.SetSprintRequest(requestSprint);
    }

    // ジャンプリクエストはperformedの次のフレームでリセット
    if (requestJump)
    {
        requestJump = false;
    }
}
```

#### Input Systemコールバック（変更なし）

```csharp
#region Interface implementation of InputSystem_Actions.IPlayerActions

public void OnMove(InputAction.CallbackContext context)
{
    movement = context.ReadValue<Vector2>();
}

public void OnLook(InputAction.CallbackContext context)
{
    cameraTracker?.SetLookInput(context.ReadValue<Vector2>());
}

public void OnJump(InputAction.CallbackContext context)
{
    requestJump = context.performed;
}

public void OnSprint(InputAction.CallbackContext context)
{
    requestSprint = context.ReadValue<float>() > 0.5f;
}

public void OnResetCamera(InputAction.CallbackContext context)
{
    requestResetCamera = context.ReadValue<float>() > 0.5f;
}

public void OnChangeCharacter(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        runtimeCharacterSwitcher?.SwitchToNextCharacter();
    }
}

public void OnToggleFPSView(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        gameUIManager.ToggleFpsCounterFrameActive();
    }
}

public void OnLoadVRMFile(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        vrmLoadManager.OpenLoadVrmFileDialog();
    }
}

#endregion
```

## アーキテクチャの改善

### リファクタリング前

```
GameInputManager (937行)
  ├── Input System受信
  ├── 入力値保持
  ├── カメラ制御連携
  ├── UI操作連携
  ├── キャラクター初期化
  ├── 移動処理
  ├── アニメーション制御
  ├── ジャンプ処理
  ├── ノックバック処理
  ├── ハイジャンプ処理
  ├── 死亡/リスポーン処理
  ├── ポストプロセッシング連携
  ├── MovingPlatform追従
  └── 地面判定
```

**問題点:**
- 単一のクラスに複数の責務が混在
- 937行の大規模クラス
- キャラクター処理の変更時に入力管理にも影響する可能性

### リファクタリング後

```
GameInputManager (181行)
  ├── Input System受信
  ├── 入力値保持
  ├── カメラ制御連携
  ├── UI操作連携
  └── GameCharacterManagerへの入力配信
      ↓
GameCharacterManager (852行)
  ├── キャラクター初期化
  ├── 移動処理
  ├── アニメーション制御
  ├── ジャンプ処理
  ├── ノックバック処理
  ├── ハイジャンプ処理
  ├── 死亡/リスポーン処理
  ├── ポストプロセッシング連携
  ├── MovingPlatform追従
  └── 地面判定
```

**改善点:**
- 単一責任の原則に従った設計
- GameInputManager: 入力管理専任（181行）
- GameCharacterManager: キャラクター処理専任（852行）
- 疎結合な連携（入力値の送信のみ）

## データフロー

```
Input System
    ↓
GameInputManager
    ├→ OnMove() → movement変数
    ├→ OnJump() → requestJump変数
    ├→ OnSprint() → requestSprint変数
    ├→ OnLook() → CharacterTracker.SetLookInput()
    ├→ OnResetCamera() → CharacterTracker.ResetCamera()
    ├→ OnChangeCharacter() → RuntimeCharacterSwitcher
    ├→ OnToggleFPSView() → GameUIManager
    └→ OnLoadVRMFile() → VRMLoadManager
    ↓ Update()で毎フレーム送信
GameCharacterManager
    ├→ SetMovementInput(movement)
    ├→ SetJumpRequest(requestJump)
    └→ SetSprintRequest(requestSprint)
    ↓
キャラクターの移動・アニメーション制御
```

## 連携インターフェース

### GameInputManager → GameCharacterManager

```csharp
// GameInputManagerのUpdate()で毎フレーム実行
gameCharacterManager.SetMovementInput(movement);      // Vector2
gameCharacterManager.SetJumpRequest(requestJump);     // bool
gameCharacterManager.SetSprintRequest(requestSprint); // bool
```

### GameCharacterManager → CharacterTracker

```csharp
// GameCharacterManagerのSetCameraTracker()で設定
public void SetCameraTracker(CharacterTracker tracker)
{
    cameraTracker = tracker;
    if (tracker != null && targetCharacter != null)
    {
        tracker.SetTarget(targetCharacter.transform);
    }
}
```

## 利点

### 1. 単一責任の原則
- GameInputManager: 入力管理のみに専念
- GameCharacterManager: キャラクター処理のみに専念

### 2. 保守性の向上
- キャラクター処理の変更がGameInputManagerに影響しない
- 入力処理の変更がGameCharacterManagerに影響しない

### 3. 可読性の向上
- GameInputManager: 937行 → 181行（約80%削減）
- 各クラスの責務が明確

### 4. テスト容易性
- 入力管理とキャラクター処理を個別にテスト可能
- GameCharacterManagerのSetMovementInput()などのメソッドを使って疎結合テストが可能

### 5. 拡張性
- 新しい入力タイプの追加はGameInputManagerのみ
- 新しいキャラクター処理の追加はGameCharacterManagerのみ

## 動作確認

### 診断ツール実行結果
- コンパイルエラー: なし
- ヒントのみ（読み取り専用フィールド、null チェック簡素化など）
- 機能的には問題なし

### 期待される動作
1. **移動**: GameInputManagerが入力を受け取り、GameCharacterManagerに送信してキャラクターが移動
2. **ジャンプ**: GameInputManagerがジャンプリクエストを受け取り、GameCharacterManagerに送信してジャンプ実行
3. **スプリント**: GameInputManagerがスプリントリクエストを受け取り、GameCharacterManagerに送信して移動速度変更
4. **カメラ制御**: GameInputManagerがLook入力とリセット処理を直接CharacterTrackerに送信
5. **UI操作**: GameInputManagerがUI操作を直接GameUIManagerに送信
6. **ダメージ/死亡/ハイジャンプ**: GameCharacterManagerがUserDataのR3イベントを購読して処理

## セットアップ手順

### Unityエディタでの設定
1. GameInputManagerオブジェクトのInspectorを開く
2. GameCharacterManager参照を設定
3. GameCharacterManagerオブジェクトのInspectorを開く
4. GameManager参照を設定
5. CharacterTracker参照を設定
6. SpeedBasedPostProcessing参照を設定

## 関連ファイル

- Assets/Scripts/GameManager/GameCharacterManager.cs (新規作成: 852行)
- Assets/Scripts/GameManager/GameInputManager.cs (修正: 937行 → 181行、約80%削減)

## 備考

- リファクタリング後も既存の機能は全て維持
- GameInputManagerとGameCharacterManagerの連携は疎結合（入力値の送信のみ）
- R3イベント購読はGameCharacterManagerが担当（Damage、Dead、HighJump）
- GameInputManagerはR3依存を削除（using R3を削除）
