# ワークログ: GameTimeManagerの実装とポーズ機能の追加

作成日時: 2025-10-21 12:11

## 変更した内容の概要

- GameTimeManager.csを新規作成し、タイムスケール（Time.timeScale）の一元管理機能を実装しました
- UserDataManager.csにポーズ状態（IsPaused）とタイムスケール（CurrentTimeScale）のReactivePropertyを追加しました
- GameInputManager.csのOnTogglePause()にポーズトグル機能を実装しました

## なぜそのように変更しようと考えたか

- ゲームのポーズやスローモーション表現など、時間操作を一元管理するコンポーネントが必要だったため
- UserDataのReactivePropertyを使用することで、ゲーム中の任意箇所からポーズ状態やタイムスケールを購読・制御できるようにするため
- Time.timeScaleの変更を一箇所で管理することで、ポーズ前の状態復元やスローモーション制御を安全に行えるようにするため

## 実装詳細

### 新規作成: Assets/Scripts/GameManager/GameTimeManager.cs (191行)

#### 責務
- Time.timeScaleの一元管理
- ポーズ状態の制御（ポーズ/ポーズ解除/トグル）
- タイムスケールの変更（スローモーション、早送りなど）
- ポーズ前のタイムスケール保存と復元

#### SerializeFieldパラメータ

```csharp
[Header("GameManager")]
[SerializeField] private GameManager gameManager;

[Header("ポーズ設定")]
[Tooltip("ポーズ時のタイムスケール")]
[SerializeField] private float pausedTimeScale = 0f;

[Tooltip("通常時のタイムスケール")]
[SerializeField] private float normalTimeScale = 1f;
```

#### R3イベント購読

```csharp
void Start()
{
    // 初期タイムスケールを設定
    Time.timeScale = normalTimeScale;
    UserDataManager.SetTimeScale(normalTimeScale);

    // ポーズ状態の購読
    var pauseSubscription = UserDataManager.Data.IsPaused.Subscribe(isPaused =>
    {
        OnPauseChanged(isPaused);
    });

    // タイムスケール変更の購読
    var timeScaleSubscription = UserDataManager.Data.CurrentTimeScale.Subscribe(timeScale =>
    {
        OnTimeScaleChanged(timeScale);
    });

    // disposable登録
    disposable = Disposable.Combine(
        pauseSubscription,
        timeScaleSubscription
    );
}
```

#### ポーズ制御の実装

```csharp
/// <summary>
/// ポーズ状態が変化したときの処理
/// </summary>
void OnPauseChanged(bool isPaused)
{
    if (isPaused)
    {
        // ポーズ前のタイムスケールを保存
        timeScaleBeforePause = Time.timeScale;

        // ポーズ時のタイムスケールを適用
        Time.timeScale = pausedTimeScale;
        UserDataManager.SetTimeScale(pausedTimeScale);
    }
    else
    {
        // ポーズ解除時は保存していたタイムスケールを復元
        Time.timeScale = timeScaleBeforePause;
        UserDataManager.SetTimeScale(timeScaleBeforePause);
    }
}
```

#### タイムスケール変更の実装

```csharp
/// <summary>
/// タイムスケールが変化したときの処理
/// </summary>
void OnTimeScaleChanged(float timeScale)
{
    // ポーズ中はタイムスケールを変更しない
    if (UserDataManager.Data.IsPaused.CurrentValue)
    {
        return;
    }

    // タイムスケールを適用
    Time.timeScale = timeScale;
}
```

#### 公開メソッド

```csharp
/// <summary>
/// ポーズをトグルする（外部から呼び出し可能）
/// </summary>
public void TogglePause()

/// <summary>
/// ゲームをポーズする（外部から呼び出し可能）
/// </summary>
public void Pause()

/// <summary>
/// ゲームのポーズを解除する（外部から呼び出し可能）
/// </summary>
public void Unpause()

/// <summary>
/// タイムスケールを設定する（外部から呼び出し可能）
/// </summary>
public void SetTimeScale(float timeScale)

/// <summary>
/// スローモーションを開始する
/// </summary>
/// <param name="slowMotionScale">スローモーションのタイムスケール（例: 0.5f = 半分の速度）</param>
public void StartSlowMotion(float slowMotionScale)

/// <summary>
/// 通常速度に戻す
/// </summary>
public void ResetToNormalSpeed()
```

### 変更: Assets/Scripts/UserData/UserDataManager.cs

#### 新規追加したReactiveProperty

```csharp
/// <summary>
/// ゲームがポーズ状態かどうか
/// </summary>
public ReactiveProperty<bool> IsPaused { get; private set; }

/// <summary>
/// 現在のタイムスケール（Time.timeScale）
/// </summary>
public ReactiveProperty<float> CurrentTimeScale { get; private set; }

public UserData(int initialHp)
{
    // ... 既存の初期化 ...
    IsPaused = new ReactiveProperty<bool>(false);
    CurrentTimeScale = new ReactiveProperty<float>(1f);
}
```

#### 新規追加した静的メソッド

```csharp
/// <summary>
/// ゲームをポーズする
/// </summary>
public static void Pause()
{
    userData.IsPaused.Value = true;
}

/// <summary>
/// ゲームのポーズを解除する
/// </summary>
public static void Unpause()
{
    userData.IsPaused.Value = false;
}

/// <summary>
/// ポーズ状態をトグルする
/// </summary>
public static void TogglePause()
{
    userData.IsPaused.Value = !userData.IsPaused.CurrentValue;
}

/// <summary>
/// タイムスケールを設定する
/// </summary>
/// <param name="timeScale">設定するタイムスケール</param>
public static void SetTimeScale(float timeScale)
{
    userData.CurrentTimeScale.Value = Mathf.Max(0f, timeScale);
}
```

### 変更: Assets/Scripts/GameManager/GameInputManager.cs

#### OnTogglePause()の実装

```csharp
public void OnTogglePause(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        gameManager?.TimeManager?.TogglePause();
    }
}
```

### 変更: Assets/Scripts/GameManager/GameManager.cs

#### GameTimeManagerへのgetter追加（既存の修正に含まれる）

```csharp
[SerializeField] private GameTimeManager timeManager;
public GameTimeManager TimeManager => timeManager;
```

## アーキテクチャ

### ポーズ制御のデータフロー

```
Input System (ESCキー など)
    ↓
GameInputManager.OnTogglePause()
    ↓
GameTimeManager.TogglePause()
    ↓
UserDataManager.TogglePause()
    ↓
UserData.IsPaused.Value = !IsPaused.CurrentValue
    ↓
GameTimeManager (購読)
    ├→ OnPauseChanged(isPaused)
    ├→ timeScaleBeforePause を保存
    ├→ Time.timeScale = pausedTimeScale (0f)
    └→ UserDataManager.SetTimeScale(pausedTimeScale)
```

### タイムスケール変更のデータフロー

```
任意のコンポーネント
    ↓
UserDataManager.SetTimeScale(0.5f) // スローモーション
    ↓
UserData.CurrentTimeScale.Value = 0.5f
    ↓
GameTimeManager (購読)
    ├→ OnTimeScaleChanged(0.5f)
    ├→ ポーズ中でないかチェック
    └→ Time.timeScale = 0.5f
```

### ポーズ解除時の復元フロー

```
GameInputManager.OnTogglePause()
    ↓
GameTimeManager.TogglePause()
    ↓
UserDataManager.TogglePause()
    ↓
UserData.IsPaused.Value = false
    ↓
GameTimeManager (購読)
    ├→ OnPauseChanged(false)
    ├→ Time.timeScale = timeScaleBeforePause (復元)
    └→ UserDataManager.SetTimeScale(timeScaleBeforePause)
```

## 利用例

### 基本的なポーズ制御

```csharp
// ポーズする
UserDataManager.Pause();

// ポーズ解除
UserDataManager.Unpause();

// ポーズトグル
UserDataManager.TogglePause();
```

### スローモーション

```csharp
// スローモーション開始（半分の速度）
gameManager.TimeManager.StartSlowMotion(0.5f);

// 通常速度に戻す
gameManager.TimeManager.ResetToNormalSpeed();
```

### タイムスケール直接設定

```csharp
// タイムスケールを0.3倍に設定
UserDataManager.SetTimeScale(0.3f);

// タイムスケールを2倍に設定（早送り）
UserDataManager.SetTimeScale(2f);
```

### ポーズ状態の購読

```csharp
// 任意のコンポーネントでポーズ状態を購読
var pauseSubscription = UserDataManager.Data.IsPaused.Subscribe(isPaused =>
{
    if (isPaused)
    {
        Debug.Log("ゲームがポーズされました");
        // ポーズメニューを表示など
    }
    else
    {
        Debug.Log("ポーズが解除されました");
        // ポーズメニューを非表示など
    }
});
```

### タイムスケールの購読

```csharp
// 任意のコンポーネントでタイムスケールを購読
var timeScaleSubscription = UserDataManager.Data.CurrentTimeScale.Subscribe(timeScale =>
{
    Debug.Log($"タイムスケールが変更されました: {timeScale}");
    // UI表示の更新など
});
```

## 利点

### 1. 一元管理
- Time.timeScaleの変更がGameTimeManagerに集約
- ポーズ前の状態を確実に復元

### 2. ReactiveProperty活用
- ポーズ状態やタイムスケールの変更を任意の場所から購読可能
- UIやエフェクトなど、複数のコンポーネントが独立して反応できる

### 3. 安全性
- ポーズ中はタイムスケール変更を無視
- タイムスケールは必ず0以上（Mathf.Max）

### 4. 拡張性
- スローモーション、早送りなど、様々な時間操作に対応
- 新しい時間操作機能を追加しやすい設計

### 5. テスト容易性
- UserDataManager経由でポーズ状態を直接制御可能
- タイムスケール変更のテストが容易

## 動作確認

### 診断ツール実行結果
- コンパイルエラー: なし
- ヒントのみ（読み取り専用フィールドなど）
- 機能的には問題なし

### 期待される動作
1. **ポーズ**: ESCキー押下でポーズ、再度押下で解除
2. **タイムスケール保存**: ポーズ前のタイムスケールが保存され、解除時に復元
3. **スローモーション**: GameTimeManager.StartSlowMotion()で実行可能
4. **購読**: UserData.IsPausedやCurrentTimeScaleを購読して、UI更新などが可能

## セットアップ手順

### Unityエディタでの設定
1. GameManagerオブジェクトのInspectorを開く
2. GameTimeManager参照を設定
3. GameTimeManagerオブジェクトのInspectorを開く
4. GameManager参照を設定
5. ポーズ時のタイムスケール（デフォルト: 0f）を確認
6. 通常時のタイムスケール（デフォルト: 1f）を確認

### Input Systemの設定
- ESCキーまたはゲームパッドのStartボタンを「OnTogglePause」アクションにバインド

## 関連ファイル

- Assets/Scripts/GameManager/GameTimeManager.cs (新規作成: 191行)
- Assets/Scripts/UserData/UserDataManager.cs (修正: IsPaused、CurrentTimeScale追加)
- Assets/Scripts/GameManager/GameInputManager.cs (修正: OnTogglePause実装)
- Assets/Scripts/GameManager/GameManager.cs (修正: TimeManagerへのgetter追加)

## 備考

- R3のReactivePropertyを活用したリアクティブな設計
- Time.timeScaleの変更はGameTimeManagerが一元管理
- ポーズ中はタイムスケール変更を無視する安全設計
- スローモーション、早送りなど、様々な時間操作に対応可能
