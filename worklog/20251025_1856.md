# ワークログ: GameUIManagerのコルーチンをUniTaskに置き換え

作成日時: 2025-10-25 18:56

## 変更した内容の概要

- GameUIManager.csのメッセージフェードイン/フェードアウト処理をCoroutineからUniTaskに置き換えました
- CancellationTokenSourceを使用した適切なキャンセル処理を実装しました
- OnDestroy時のリソース解放処理を追加しました

## なぜそのように変更しようと考えたか

- プロジェクト全体でUniTaskを導入しており、統一的な非同期処理の実装を目指すため
- CoroutineよりもUniTaskの方がキャンセル処理が明示的で安全に管理できるため
- UniTaskを使うことでasync/awaitの利点（例外処理の容易さ、デバッグのしやすさ）を活用できるため

## 実装詳細

### Assets/Scripts/GameManager/GameUIManager.cs の変更

#### 1. using追加（9-17行目）

**変更前:**
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using System.Linq;
using Cysharp.Text;
using R3;
```

**変更後:**
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using System.Linq;
using System.Threading;
using Cysharp.Text;
using Cysharp.Threading.Tasks;
using R3;
```

#### 2. コルーチン管理からCancellationTokenSourceに変更（51-53行目）

**変更前:**
```csharp
/// <summary>現在実行中のメッセージフェードコルーチン</summary>
private Coroutine currentMessageFadeCoroutine = null;
```

**変更後:**
```csharp
/// <summary>現在実行中のメッセージフェード処理のキャンセレーショントークン</summary>
private CancellationTokenSource messageFadeCts = null;
```

#### 3. OnDestroyでのリソース解放追加（125-130行目）

**変更前:**
```csharp
void OnDestroy()
{
    disposable?.Dispose();
}
```

**変更後:**
```csharp
void OnDestroy()
{
    disposable?.Dispose();
    messageFadeCts?.Cancel();
    messageFadeCts?.Dispose();
}
```

#### 4. ShowStaticMessage()の変更（145-167行目）

**変更前:**
```csharp
public void ShowStaticMessage(string message)
{
    if (staticMessageCanvasGroup == null || staticMessageTMP == null)
    {
        Debug.LogWarning("GameUIManager: staticMessageCanvasGroupまたはstaticMessageTMPが設定されていません。");
        return;
    }

    // テキスト内容を更新
    staticMessageTMP.text = message;

    // 既存のフェードを停止
    if (currentMessageFadeCoroutine != null)
    {
        StopCoroutine(currentMessageFadeCoroutine);
    }

    // フェードインを開始
    currentMessageFadeCoroutine = StartCoroutine(FadeInStaticMessage());
}
```

**変更後:**
```csharp
public void ShowStaticMessage(string message)
{
    if (staticMessageCanvasGroup == null || staticMessageTMP == null)
    {
        Debug.LogWarning("GameUIManager: staticMessageCanvasGroupまたはstaticMessageTMPが設定されていません。");
        return;
    }

    // テキスト内容を更新
    staticMessageTMP.text = message;

    // 既存のフェードを停止
    messageFadeCts?.Cancel();
    messageFadeCts?.Dispose();
    messageFadeCts = new CancellationTokenSource();

    // フェードインを開始
    FadeInStaticMessageAsync(messageFadeCts.Token).Forget();
}
```

#### 5. HideStaticMessage()の変更（169-186行目）

**変更前:**
```csharp
public void HideStaticMessage()
{
    if (staticMessageCanvasGroup == null)
    {
        return;
    }

    // 既存のフェードを停止
    if (currentMessageFadeCoroutine != null)
    {
        StopCoroutine(currentMessageFadeCoroutine);
    }

    // フェードアウトを開始
    currentMessageFadeCoroutine = StartCoroutine(FadeOutStaticMessage());
}
```

**変更後:**
```csharp
public void HideStaticMessage()
{
    if (staticMessageCanvasGroup == null)
    {
        return;
    }

    // 既存のフェードを停止
    messageFadeCts?.Cancel();
    messageFadeCts?.Dispose();
    messageFadeCts = new CancellationTokenSource();

    // フェードアウトを開始
    FadeOutStaticMessageAsync(messageFadeCts.Token).Forget();
}
```

#### 6. FadeInStaticMessage()をUniTaskに変更（188-213行目）

**変更前:**
```csharp
/// <summary>
/// 静的メッセージをフェードインさせるコルーチン
/// </summary>
private System.Collections.IEnumerator FadeInStaticMessage()
{
    float elapsedTime = 0f;
    float startAlpha = staticMessageCanvasGroup.alpha;

    while (elapsedTime < staticMessageFadeInDuration)
    {
        elapsedTime += Time.deltaTime;
        float t = Mathf.Clamp01(elapsedTime / staticMessageFadeInDuration);
        staticMessageCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
        yield return null;
    }

    staticMessageCanvasGroup.alpha = 1f;
    currentMessageFadeCoroutine = null;
}
```

**変更後:**
```csharp
/// <summary>
/// 静的メッセージをフェードインさせる
/// </summary>
/// <param name="ct">キャンセルトークン</param>
private async UniTaskVoid FadeInStaticMessageAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = staticMessageCanvasGroup.alpha;

        while (elapsedTime < staticMessageFadeInDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / staticMessageFadeInDuration);
            staticMessageCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
            await UniTask.Yield(ct);
        }

        staticMessageCanvasGroup.alpha = 1f;
    }
    catch (OperationCanceledException)
    {
        // キャンセル時は何もしない
    }
}
```

#### 7. FadeOutStaticMessage()をUniTaskに変更（215-240行目）

**変更前:**
```csharp
/// <summary>
/// 静的メッセージをフェードアウトさせるコルーチン
/// </summary>
private System.Collections.IEnumerator FadeOutStaticMessage()
{
    float elapsedTime = 0f;
    float startAlpha = staticMessageCanvasGroup.alpha;

    while (elapsedTime < staticMessageFadeOutDuration)
    {
        elapsedTime += Time.deltaTime;
        float t = Mathf.Clamp01(elapsedTime / staticMessageFadeOutDuration);
        staticMessageCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, t);
        yield return null;
    }

    staticMessageCanvasGroup.alpha = 0f;
    currentMessageFadeCoroutine = null;
}
```

**変更後:**
```csharp
/// <summary>
/// 静的メッセージをフェードアウトさせる
/// </summary>
/// <param name="ct">キャンセルトークン</param>
private async UniTaskVoid FadeOutStaticMessageAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = staticMessageCanvasGroup.alpha;

        while (elapsedTime < staticMessageFadeOutDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / staticMessageFadeOutDuration);
            staticMessageCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, t);
            await UniTask.Yield(ct);
        }

        staticMessageCanvasGroup.alpha = 0f;
    }
    catch (OperationCanceledException)
    {
        // キャンセル時は何もしない
    }
}
```

## 変更の利点

### 1. 統一された非同期処理
- プロジェクト全体でUniTaskを使用することで、非同期処理の実装が統一されます
- 将来的なメンテナンスが容易になります

### 2. 明示的なキャンセル処理
- CancellationTokenSourceを使用することで、キャンセル処理が明示的になります
- Coroutineの`StopCoroutine()`よりも安全で予測可能な動作になります

### 3. 例外処理の改善
- async/awaitパターンにより、例外処理がtry-catchで統一的に記述できます
- `OperationCanceledException`を適切にハンドリングできます

### 4. リソース管理の改善
- `OnDestroy()`でCancellationTokenSourceを適切にDispose()することで、リソースリークを防ぎます
- GameObjectが破棄された時に実行中のタスクを確実にキャンセルできます

### 5. デバッグの容易さ
- UniTaskはスタックトレースが見やすく、デバッグが容易です
- Coroutineよりも実行フローが追いやすくなります

## キャンセル処理のフロー

```
ShowStaticMessage() / HideStaticMessage() 呼び出し
    ↓
既存のmessageFadeCtsをCancel()
    ↓
既存のmessageFadeCtsをDispose()
    ↓
新しいCancellationTokenSourceを作成
    ↓
新しいトークンでFadeInStaticMessageAsync() / FadeOutStaticMessageAsync()を実行
    ↓ (途中で再度ShowStaticMessage()が呼ばれた場合)
実行中のタスクがOperationCanceledExceptionをcatch
    ↓
catchブロックで何もしない（正常なキャンセル処理）
    ↓
新しいフェード処理が開始される
```

## OnDestroy時のクリーンアップフロー

```
GameUIManager破棄
    ↓
OnDestroy()呼び出し
    ↓
disposable?.Dispose() (R3の購読解除)
    ↓
messageFadeCts?.Cancel() (実行中のフェード処理をキャンセル)
    ↓
messageFadeCts?.Dispose() (CancellationTokenSourceを解放)
```

## 動作確認

### 期待される動作
1. **メッセージ表示**: `ShowStaticMessage()`でメッセージがフェードイン
2. **メッセージ非表示**: `HideStaticMessage()`でメッセージがフェードアウト
3. **連続呼び出し**: 連続して`ShowStaticMessage()`が呼ばれた場合、前のフェードがキャンセルされて新しいフェードが開始
4. **破棄時の安全性**: GameObjectが破棄された時、実行中のフェード処理が適切にキャンセルされる

## 関連ファイル

- Assets/Scripts/GameManager/GameUIManager.cs (修正: Coroutine → UniTask)

## 備考

- UniTaskの`.Forget()`を使用して、戻り値を無視しています（fire-and-forget パターン）
- `UniTaskVoid`を返すことで、例外が発生した場合でもUnityのログに適切に記録されます
- Time.deltaTimeを使った経過時間計算のロジックは変更していません（既存の動作を保持）
