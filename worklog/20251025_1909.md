# ワークログ: ポーズメニュー表示機能の実装

作成日時: 2025-10-25 19:09

## 変更した内容の概要

- GameUIManager.csにポーズメニューの表示・非表示機能をUniTaskで実装しました
- GameInputManager.csにPキー入力時のポーズメニュー制御とマウスカーソル表示・非表示の切り替え機能を実装しました
- メニュー表示中はマウスカーソルを表示してOSに制御を戻し、非表示時はカーソルをロックして非表示にします

## なぜそのように変更しようと考えたか

- ゲームプレイ中にポーズメニューを表示する機能が必要だったため
- 既に実装済みのメッセージフェード機能と同様のパターンで、UniTaskを使った統一的な実装を行うため
- メニュー操作時にはマウスカーソルが必要だが、通常のゲームプレイ中は邪魔になるため、表示状態を自動で切り替える必要があったため

## 実装詳細

### 1. GameUIManager.cs の変更

#### 新規追加したフィールド（51-73行目）

```csharp
[Header("ポーズメニュー関連")]
[SerializeField] private GameObject pauseMenu;
[SerializeField] private CanvasGroup pauseMenuCanvasGroup;

[Tooltip("ポーズメニューのフェードイン時間（秒）")]
[SerializeField] private float pauseMenuFadeInDuration = 0.2f;

[Tooltip("ポーズメニューのフェードアウト時間（秒）")]
[SerializeField] private float pauseMenuFadeOutDuration = 0.2f;

/// <summary>現在実行中のポーズメニューフェード処理のキャンセレーショントークン</summary>
private CancellationTokenSource pauseMenuFadeCts = null;

/// <summary>ポーズメニューが表示されているかどうか</summary>
private bool isPauseMenuVisible = false;

/// <summary>ポーズメニューが表示されているかどうかを外部から参照可能にする</summary>
public bool IsPauseMenuVisible => isPauseMenuVisible;
```

- **pauseMenu**: ポーズメニューのGameObject（表示・非表示制御用）
- **pauseMenuCanvasGroup**: フェードイン・アウト制御用
- **pauseMenuFadeInDuration/FadeOutDuration**: フェード時間（デフォルト0.2秒）
- **pauseMenuFadeCts**: フェード処理のキャンセル管理
- **isPauseMenuVisible**: 表示状態の管理
- **IsPauseMenuVisible**: 外部からの表示状態参照用プロパティ

#### Start()での初期化追加（83-91行目）

```csharp
// ポーズメニューを初期状態で非表示
if (pauseMenuCanvasGroup != null)
{
    pauseMenuCanvasGroup.alpha = 0f;
}
if (pauseMenu != null)
{
    pauseMenu.SetActive(false);
}
```

#### OnDestroy()でのクリーンアップ追加（152-159行目）

```csharp
void OnDestroy()
{
    disposable?.Dispose();
    messageFadeCts?.Cancel();
    messageFadeCts?.Dispose();
    pauseMenuFadeCts?.Cancel();
    pauseMenuFadeCts?.Dispose();
}
```

#### 新規追加した公開メソッド

**ShowPauseMenu()** (274-299行目)
```csharp
/// <summary>
/// ポーズメニューを表示する
/// </summary>
public void ShowPauseMenu()
{
    if (pauseMenu == null || pauseMenuCanvasGroup == null)
    {
        Debug.LogWarning("GameUIManager: pauseMenuまたはpauseMenuCanvasGroupが設定されていません。");
        return;
    }

    if (isPauseMenuVisible)
    {
        return; // 既に表示中
    }

    isPauseMenuVisible = true;

    // ポーズメニューをアクティブ化
    pauseMenu.SetActive(true);

    // 既存のフェードを停止
    pauseMenuFadeCts?.Cancel();
    pauseMenuFadeCts?.Dispose();
    pauseMenuFadeCts = new CancellationTokenSource();

    // フェードインを開始
    FadeInPauseMenuAsync(pauseMenuFadeCts.Token).Forget();
}
```

**HidePauseMenu()** (301-325行目)
```csharp
/// <summary>
/// ポーズメニューを非表示にする
/// </summary>
public void HidePauseMenu()
{
    if (pauseMenu == null || pauseMenuCanvasGroup == null)
    {
        return;
    }

    if (!isPauseMenuVisible)
    {
        return; // 既に非表示
    }

    isPauseMenuVisible = false;

    // 既存のフェードを停止
    pauseMenuFadeCts?.Cancel();
    pauseMenuFadeCts?.Dispose();
    pauseMenuFadeCts = new CancellationTokenSource();

    // フェードアウトを開始
    FadeOutPauseMenuAsync(pauseMenuFadeCts.Token).Forget();
}
```

**TogglePauseMenu()** (327-340行目)
```csharp
/// <summary>
/// ポーズメニューの表示状態をトグルする
/// </summary>
public void TogglePauseMenu()
{
    if (isPauseMenuVisible)
    {
        HidePauseMenu();
    }
    else
    {
        ShowPauseMenu();
    }
}
```

#### 新規追加したプライベートメソッド（UniTask実装）

**FadeInPauseMenuAsync()** (342-367行目)
```csharp
/// <summary>
/// ポーズメニューをフェードインさせる
/// </summary>
/// <param name="ct">キャンセルトークン</param>
private async UniTaskVoid FadeInPauseMenuAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeInDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeInDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 1f;
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードイン中にエラーが発生しました: {ex}");
    }
}
```

**FadeOutPauseMenuAsync()** (369-397行目)
```csharp
/// <summary>
/// ポーズメニューをフェードアウトさせる
/// </summary>
/// <param name="ct">キャンセルトークン</param>
private async UniTaskVoid FadeOutPauseMenuAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeOutDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeOutDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 0f;

        // フェードアウト完了後、GameObjectを非アクティブ化
        pauseMenu.SetActive(false);
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードアウト中にエラーが発生しました: {ex}");
    }
}
```

### 2. GameInputManager.cs の変更

#### 新規追加したメソッド（112-152行目）

**OnTogglePauseMenu()** (112-138行目)
```csharp
/// <summary>
/// ポーズメニューの表示・非表示をトグルする（Pキー）
/// メニュー表示中はマウスカーソルを表示し、非表示時はマウスカーソルを隠す
/// </summary>
public void OnTogglePauseMenu(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        gameManager.UIManager.TogglePauseMenu();

        // ポーズメニューの表示状態に応じてマウスカーソルを制御
        // 表示中: カーソル表示、OSに制御を戻す
        // 非表示: カーソル非表示、ロック
        bool isMenuVisible = IsPauseMenuVisible();

        if (isMenuVisible)
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
        else
        {
            Cursor.lockState = CursorLockMode.Locked;
            Cursor.visible = false;
        }
    }
}
```

**IsPauseMenuVisible()** (140-152行目)
```csharp
/// <summary>
/// ポーズメニューが表示されているか確認する
/// </summary>
private bool IsPauseMenuVisible()
{
    // GameUIManagerのpauseMenuがアクティブかどうかで判定
    var uiManager = gameManager?.UIManager;
    if (uiManager == null) return false;

    // リフレクションを使わず、公開プロパティ経由で取得
    return gameManager.UIManager.IsPauseMenuVisible;
}
```

## マウスカーソル制御の詳細

### メニュー表示時
```csharp
Cursor.lockState = CursorLockMode.None;  // カーソルのロックを解除
Cursor.visible = true;                    // カーソルを表示
```
- カーソルがOSの制御に戻り、画面外にも移動可能
- UIボタンのクリックなどが可能

### メニュー非表示時（ゲームプレイ中）
```csharp
Cursor.lockState = CursorLockMode.Locked; // カーソルを画面中央にロック
Cursor.visible = false;                   // カーソルを非表示
```
- カーソルが画面中央に固定される
- カメラ制御などマウス移動入力は有効
- カーソルは非表示でゲームの邪魔にならない

## データフロー

```
Pキー入力
    ↓
GameInputManager.OnTogglePauseMenu()
    ↓
GameUIManager.TogglePauseMenu()
    ├→ isPauseMenuVisible を反転
    ├→ ShowPauseMenu() または HidePauseMenu() を呼び出し
    │   ├→ pauseMenu.SetActive(true/false)
    │   ├→ CancellationTokenSource作成
    │   └→ FadeInPauseMenuAsync() または FadeOutPauseMenuAsync()
    │       ├→ CanvasGroup.alpha を0→1 または 1→0にアニメーション
    │       └→ UniTask.Yield() で毎フレーム待機
    ↓
GameInputManager.IsPauseMenuVisible()
    ├→ GameUIManager.IsPauseMenuVisible プロパティを参照
    └→ メニュー表示状態を取得
    ↓
マウスカーソル制御
    ├→ 表示中: Cursor.lockState = None, Cursor.visible = true
    └→ 非表示: Cursor.lockState = Locked, Cursor.visible = false
```

## 利点

### 1. UniTaskによる統一的な実装
- 既存のメッセージフェード機能と同じパターンで実装
- CancellationTokenによる安全なキャンセル処理
- async/awaitによる可読性の高いコード

### 2. 適切なマウスカーソル制御
- メニュー表示中は自動的にカーソルが表示される
- ゲームプレイ中は自動的にカーソルが非表示になる
- ユーザーが手動で切り替える必要がない

### 3. 重複制御の防止
- `isPauseMenuVisible`フラグで表示状態を管理
- 既に表示中の場合は再度表示処理を行わない
- 既に非表示の場合は再度非表示処理を行わない

### 4. 安全なリソース管理
- OnDestroy()で`pauseMenuFadeCts`を適切に破棄
- フェード処理の重複実行時は既存の処理をキャンセル

### 5. 例外処理
- `catch (Exception ex) when (ex is not OperationCanceledException)`
- OperationCanceledExceptionは正常なキャンセルとして無視
- その他の例外はログに記録

## セットアップ手順

### 1. Unityエディタでの設定

#### GameUIManagerの設定
1. GameUIManagerオブジェクトのInspectorを開く
2. 「ポーズメニュー関連」セクションに以下を設定:
   - Pause Menu: ポーズメニューのGameObject
   - Pause Menu Canvas Group: ポーズメニューのCanvasGroup
   - Pause Menu Fade In Duration: フェードイン時間（デフォルト: 0.2秒）
   - Pause Menu Fade Out Duration: フェードアウト時間（デフォルト: 0.2秒）

### 2. Input Systemの設定

#### InputSystem_Actions.inputactionsファイルの編集
1. Unityエディタで `Assets/GameManager/InputSystem_Actions.inputactions` を開く
2. 「Player」アクションマップに新しいアクションを追加:
   - **Action Name**: `TogglePauseMenu`
   - **Action Type**: `Button`
   - **Binding**: `P` (Keyboard)

3. ファイルを保存すると、自動的に `InputSystem_Actions.cs` が再生成されます

4. 再生成後、`IPlayerActions`インターフェースに`OnTogglePauseMenu()`が追加されます

### 3. UIの準備

#### ポーズメニューのGameObject構造
```
PauseMenu (GameObject)
├─ CanvasGroup (Component) ← pauseMenuCanvasGroup に設定
└─ Panel
    ├─ Title (TextMeshPro)
    ├─ ResumeButton (Button)
    ├─ SettingsButton (Button)
    └─ QuitButton (Button)
```

## 動作確認

### 期待される動作
1. **Pキー押下**: ポーズメニューがフェードインして表示される
2. **マウスカーソル表示**: メニュー表示と同時にマウスカーソルが表示される
3. **再度Pキー押下**: ポーズメニューがフェードアウトして非表示になる
4. **マウスカーソル非表示**: メニュー非表示と同時にマウスカーソルが非表示になる
5. **連続押下**: 連続してPキーを押した場合、前のフェード処理がキャンセルされて新しいフェードが開始

## 関連ファイル

- Assets/Scripts/GameManager/GameUIManager.cs (修正: ポーズメニュー機能追加)
- Assets/Scripts/GameManager/GameInputManager.cs (修正: Pキー入力処理とマウスカーソル制御追加)
- Assets/GameManager/InputSystem_Actions.inputactions (要編集: TogglePauseMenuアクション追加)

## 備考

### パターンマッチング構文の使用
- `catch (Exception ex) when (ex is not OperationCanceledException)`
- C# 9.0の`is not`パターンを使用（より読みやすい）
- 従来の`!(ex is OperationCanceledException)`と同じ意味

### Input Systemアクションの追加について
- `InputSystem_Actions.cs`は自動生成ファイルのため、直接編集しない
- 必ず`.inputactions`ファイルをUnityエディタで編集してから再生成する
- 再生成後、GameInputManagerの`OnTogglePauseMenu()`が自動的にインターフェースメソッドとして認識される

### 既存のOnTogglePause()との違い
- **OnTogglePause()**: ゲーム時間の停止・再開（Time.timeScale制御）
- **OnTogglePauseMenu()**: ポーズメニューUIの表示・非表示
- 両者は独立して動作し、必要に応じて組み合わせて使用可能
