# ワークログ: カーソルロック状態監視によるポーズ状態の自動連動

作成日時: 2025-10-25 19:18

## 変更した内容の概要

- GameInputManager.csにカーソルロック状態（Cursor.lockState）の変化を監視する機能を追加しました
- ESCキーなどでカーソルがロック解除された際、自動的にゲームをポーズしてポーズメニューを表示するようになりました
- カーソルが再ロックされた際、自動的にポーズを解除してメニューを非表示にするようになりました

## なぜそのように変更しようと考えたか

- ゲーム中にESCキーを押すとマウスカーソルがOS制御に戻るが、ゲームが進行したままになる問題があったため
- カーソルのロック状態とゲームのポーズ状態が不一致になると、操作体験が悪化するため
- ユーザーがESCキーを押した際の期待動作（ゲームが一時停止してメニューが表示される）を実現するため

## 実装詳細

### GameInputManager.cs の変更

#### 新規追加したフィールド（27-28行目）

```csharp
/// <summary>前フレームのカーソルロック状態</summary>
private CursorLockMode previousCursorLockMode;
```

- 前フレームのカーソルロック状態を保持
- 状態変化の検知に使用

#### Start()での初期化追加（77-78行目）

```csharp
// 初期カーソル状態を記録
previousCursorLockMode = Cursor.lockState;
```

- ゲーム開始時のカーソルロック状態を記録
- 最初のフレームで誤検知しないための初期化

#### Update()の追加（81-85行目）

```csharp
void Update()
{
    // カーソルロック状態の変化を監視
    MonitorCursorLockState();
}
```

- 毎フレーム、カーソルロック状態の変化を監視

#### MonitorCursorLockState()の追加（87-122行目）

```csharp
/// <summary>
/// カーソルロック状態の変化を監視し、ポーズ状態と連動させる
/// </summary>
private void MonitorCursorLockState()
{
    CursorLockMode currentLockMode = Cursor.lockState;

    // カーソルロック状態が変化した場合
    if (currentLockMode != previousCursorLockMode)
    {
        // ESCキーなどでカーソルがロック解除された場合、ポーズメニューを表示
        if (previousCursorLockMode == CursorLockMode.Locked && currentLockMode == CursorLockMode.None)
        {
            // ポーズメニューが非表示の場合のみ表示する
            if (!gameManager.UIManager.IsPauseMenuVisible)
            {
                gameManager.TimeManager.Pause();
                gameManager.UIManager.ShowPauseMenu();
                Cursor.visible = true;
            }
        }
        // カーソルがロックされた場合、ポーズメニューを非表示
        else if (previousCursorLockMode == CursorLockMode.None && currentLockMode == CursorLockMode.Locked)
        {
            // ポーズメニューが表示中の場合のみ非表示にする
            if (gameManager.UIManager.IsPauseMenuVisible)
            {
                gameManager.TimeManager.Unpause();
                gameManager.UIManager.HidePauseMenu();
                Cursor.visible = false;
            }
        }

        previousCursorLockMode = currentLockMode;
    }
}
```

## 動作フロー

### ESCキー押下時（カーソルロック解除）

```
ユーザーがESCキーを押下
    ↓
Unity内部でCursor.lockStateが自動的にCursorLockMode.Noneに変更
    ↓
MonitorCursorLockState()が変化を検知
    ├→ previousCursorLockMode: Locked
    └→ currentLockMode: None
    ↓
ポーズメニューが非表示の場合
    ├→ gameManager.TimeManager.Pause() （ゲーム時間を停止）
    ├→ gameManager.UIManager.ShowPauseMenu() （メニューをフェードイン表示）
    └→ Cursor.visible = true （カーソルを表示）
    ↓
previousCursorLockMode = CursorLockMode.None に更新
```

### カーソル再ロック時（ゲーム再開）

```
ユーザーまたはコードがカーソルをロック
    ↓
Cursor.lockStateがCursorLockMode.Lockedに変更
    ↓
MonitorCursorLockState()が変化を検知
    ├→ previousCursorLockMode: None
    └→ currentLockMode: Locked
    ↓
ポーズメニューが表示中の場合
    ├→ gameManager.TimeManager.Unpause() （ゲーム時間を再開）
    ├→ gameManager.UIManager.HidePauseMenu() （メニューをフェードアウト非表示）
    └→ Cursor.visible = false （カーソルを非表示）
    ↓
previousCursorLockMode = CursorLockMode.Locked に更新
```

## 安全機能

### 1. 二重実行の防止

**カーソルロック解除時:**
```csharp
if (!gameManager.UIManager.IsPauseMenuVisible)
{
    gameManager.TimeManager.Pause();
    gameManager.UIManager.ShowPauseMenu();
    Cursor.visible = true;
}
```
- 既にポーズメニューが表示されている場合は何もしない
- 重複したポーズ処理を防止

**カーソルロック時:**
```csharp
if (gameManager.UIManager.IsPauseMenuVisible)
{
    gameManager.TimeManager.Unpause();
    gameManager.UIManager.HidePauseMenu();
    Cursor.visible = false;
}
```
- 既にポーズメニューが非表示の場合は何もしない
- 重複したアンポーズ処理を防止

### 2. 状態の一貫性

- カーソルロック状態とポーズ状態が常に連動
- ユーザーの期待通りの動作を保証

## OnTogglePause()との連携

既存の`OnTogglePause()`メソッド（キーバインド経由のトグル）と、新しい`MonitorCursorLockState()`（ESCキー自動検知）が協調動作します。

```
OnTogglePause() (例: Tabキー)
    ├→ gameManager.TimeManager.TogglePause()
    ├→ gameManager.UIManager.TogglePauseMenu()
    └→ Cursor.lockState = Locked/None に変更
        ↓
次のフレーム
        ↓
MonitorCursorLockState() が変化を検知
    ├→ 既にポーズメニューが表示/非表示済み
    └→ IsPauseMenuVisible チェックで二重実行を防止
```

## 利点

### 1. ユーザーエクスペリエンスの向上
- ESCキーを押すと、期待通りにゲームが一時停止してメニューが表示される
- カーソルのロック状態とゲームの状態が一致する

### 2. 操作の直感性
- ユーザーがESCキーを押した際の一般的な期待動作（一時停止）を実現
- PC ゲームの標準的な操作体験

### 3. 状態管理の一貫性
- カーソルロック状態を単一の真実の源（Single Source of Truth）として扱う
- ポーズ状態がカーソル状態に自動的に追従

### 4. 拡張性
- 他のコードからCursor.lockStateを変更した場合も、自動的にポーズ状態が連動
- 将来的な機能追加にも対応しやすい

## 既知の動作

### ESCキーの標準動作
Unityでは、カーソルがロックされている状態でESCキーを押すと、自動的に`Cursor.lockState`が`CursorLockMode.None`に変更されます。これはUnity Engineの標準動作です。

### 本実装の役割
この標準動作を活用し、カーソルロック状態の変化を検知してゲームのポーズ状態を連動させることで、ユーザーの期待に沿った動作を実現しています。

## テストケース

### ケース1: ゲーム中にESCキーを押す
1. ゲームプレイ中（カーソルロック中）
2. ESCキーを押す
3. **期待結果**: ゲームが一時停止し、ポーズメニューが表示され、カーソルが表示される

### ケース2: ポーズ中にゲームを再開
1. ポーズメニュー表示中
2. 何らかの方法でカーソルを再ロック（例: OnTogglePause()でトグル）
3. **期待結果**: ゲームが再開し、ポーズメニューが非表示になり、カーソルが非表示になる

### ケース3: 既にポーズ中にESCキーを押す
1. ポーズメニュー表示中
2. ESCキーを押す（カーソルは既にロック解除済み）
3. **期待結果**: 何も起こらない（二重実行を防止）

### ケース4: OnTogglePause()との併用
1. ゲームプレイ中
2. OnTogglePause()でポーズ（例: Tabキー）
3. **期待結果**: ポーズメニューが表示され、カーソルが表示される。MonitorCursorLockState()も検知するが、IsPauseMenuVisibleチェックで二重実行を防止

## 関連ファイル

- Assets/Scripts/GameManager/GameInputManager.cs (修正: カーソルロック状態監視機能追加)

## 備考

### Update()のパフォーマンス
- 毎フレームCursor.lockStateを取得していますが、軽量なプロパティアクセスのため、パフォーマンスへの影響は無視できます
- 状態変化時のみ処理が実行されるため、ほとんどのフレームでは条件分岐のみで終了します

### カーソル状態の優先度
この実装により、カーソルロック状態がゲームのポーズ状態を決定する「マスター状態」となります。これにより、カーソル状態とゲーム状態の不一致を防ぎます。
