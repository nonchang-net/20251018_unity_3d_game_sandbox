# ワークログ: ポーズメニューフェードイン処理が途中で止まる問題の修正

作成日時: 2025-10-26 16:09

## 変更した内容の概要

- ポーズメニュー表示のフェードイン処理が途中でキャンセルされる問題を調査し、修正しました
- フェードアニメーション中の連続入力を防ぐため、`isPauseMenuFading` フラグを追加しました
- `FadeInPauseMenuAsync()` と `FadeOutPauseMenuAsync()` にフェード中フラグの設定処理を追加しました
- `TogglePauseMenu()` でフェード中かどうかをチェックし、フェード中は入力を無視するようにしました

## なぜそのように変更しようと考えたか

- ユーザーから「ポーズメニュー表示フェードイン処理が途中で止まることがある」との報告があったため
- 「途中でキャンセルされているような挙動」という説明から、連続入力によるキャンセル処理が疑われたため
- フェードアニメーション完了前にユーザーが再度ポーズキーを押すと、既存のフェードがキャンセルされて新しいフェードが開始される問題を解決するため

## 原因の詳細分析

### 問題の発生メカニズム

**GameUIManager.cs の問題点:**

1. **isPauseMenuVisible フラグの更新タイミングが早すぎる**
   - `ShowPauseMenu()` (329行目) で即座に `isPauseMenuVisible = true` を設定
   - `HidePauseMenu()` (358行目) で即座に `isPauseMenuVisible = false` を設定
   - フェードアニメーション完了前にフラグが変わるため、連続入力で状態が不安定になる

2. **フェード中の入力を制御する仕組みがなかった**
   - `TogglePauseMenu()` はフェード中かどうかを判定せず、即座に処理を実行
   - 連続でキーを押すと、フェードがキャンセルされて逆方向のフェードが開始される

### 具体的な問題シナリオ

```
1. ユーザーがポーズキーを押す
   ↓
2. ShowPauseMenu() が呼ばれる
   - isPauseMenuVisible = true
   - pauseMenuFadeCts をキャンセル & 新規作成
   - FadeInPauseMenuAsync() 開始（0.2秒間のフェードイン）
   ↓
3. フェード中（0.2秒以内）にユーザーが再度ポーズキーを押す
   ↓
4. TogglePauseMenu() が呼ばれる
   - isPauseMenuVisible == true
   - HidePauseMenu() が呼ばれる
   ↓
5. HidePauseMenu() の処理
   - isPauseMenuVisible = false
   - pauseMenuFadeCts?.Cancel() ← ★既存のフェードインをキャンセル
   - 新しい pauseMenuFadeCts を作成
   - FadeOutPauseMenuAsync() 開始
   ↓
6. 結果: フェードインが途中で止まり、フェードアウトが開始される
```

### ShowPauseMenu() のコード（修正前）

```csharp
public void ShowPauseMenu()
{
    if (pauseMenu == null || pauseMenuCanvasGroup == null)
    {
        Debug.LogWarning("GameUIManager: pauseMenuまたはpauseMenuCanvasGroupが設定されていません。");
        return;
    }

    if (isPauseMenuVisible)
    {
        return; // 既に表示中
    }

    isPauseMenuVisible = true;  // ★即座にフラグを更新

    // ポーズメニューをアクティブ化
    pauseMenu.SetActive(true);

    // 既存のフェードを停止
    pauseMenuFadeCts?.Cancel();  // ★既存のフェードをキャンセル
    pauseMenuFadeCts?.Dispose();
    pauseMenuFadeCts = new CancellationTokenSource();

    // フェードインを開始
    FadeInPauseMenuAsync(pauseMenuFadeCts.Token).Forget();
}
```

### TogglePauseMenu() のコード（修正前）

```csharp
public void TogglePauseMenu()
{
    // ★フェード中かどうかのチェックがない
    if (isPauseMenuVisible)
    {
        HidePauseMenu();
    }
    else
    {
        ShowPauseMenu();
    }
}
```

## 実装した修正内容

### 1. フェード中フラグの追加

**GameUIManager.cs (107-108行目):**

```csharp
/// <summary>ポーズメニューのフェード処理中かどうか</summary>
private bool isPauseMenuFading = false;
```

フェードアニメーション実行中かどうかを示すフラグを追加しました。

### 2. TogglePauseMenu() の修正

**GameUIManager.cs (375-391行目):**

**修正前:**
```csharp
public void TogglePauseMenu()
{
    if (isPauseMenuVisible)
    {
        HidePauseMenu();
    }
    else
    {
        ShowPauseMenu();
    }
}
```

**修正後:**
```csharp
public void TogglePauseMenu()
{
    // フェード中は入力を無視
    if (isPauseMenuFading)
    {
        return;
    }

    if (isPauseMenuVisible)
    {
        HidePauseMenu();
    }
    else
    {
        ShowPauseMenu();
    }
}
```

**効果:**
- フェード中に入力があっても無視されるため、フェードがキャンセルされない
- ユーザーが連続でキーを押しても、アニメーションが最後まで完了する

### 3. FadeInPauseMenuAsync() の修正

**GameUIManager.cs (397-423行目):**

**修正前:**
```csharp
private async UniTaskVoid FadeInPauseMenuAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeInDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeInDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 1f;
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードイン中にエラーが発生しました: {ex}");
    }
}
```

**修正後:**
```csharp
private async UniTaskVoid FadeInPauseMenuAsync(CancellationToken ct)
{
    isPauseMenuFading = true;  // ★フェード開始
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeInDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeInDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 1f;
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードイン中にエラーが発生しました: {ex}");
    }
    finally
    {
        isPauseMenuFading = false;  // ★フェード終了（正常終了・キャンセル両方）
    }
}
```

**効果:**
- フェード開始時に `isPauseMenuFading = true` を設定
- フェード終了時（正常終了・キャンセル・エラー問わず）に `isPauseMenuFading = false` を設定
- `finally` ブロックで確実にフラグをリセット

### 4. FadeOutPauseMenuAsync() の修正

**GameUIManager.cs (429-458行目):**

**修正前:**
```csharp
private async UniTaskVoid FadeOutPauseMenuAsync(CancellationToken ct)
{
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeOutDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeOutDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 0f;

        // フェードアウト完了後、GameObjectを非アクティブ化
        pauseMenu.SetActive(false);
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードアウト中にエラーが発生しました: {ex}");
    }
}
```

**修正後:**
```csharp
private async UniTaskVoid FadeOutPauseMenuAsync(CancellationToken ct)
{
    isPauseMenuFading = true;  // ★フェード開始
    try
    {
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeOutDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeOutDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 0f;

        // フェードアウト完了後、GameObjectを非アクティブ化
        pauseMenu.SetActive(false);
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードアウト中にエラーが発生しました: {ex}");
    }
    finally
    {
        isPauseMenuFading = false;  // ★フェード終了（正常終了・キャンセル両方）
    }
}
```

**効果:**
- フェードイン処理と同様に、フェード中フラグを適切に管理
- フェードアウト中も連続入力を防止

## 修正の利点

### 1. フェードアニメーションの安定性向上
- フェード中の連続入力を無視することで、アニメーションが途中でキャンセルされなくなった
- ユーザーがキーを連打しても、アニメーションが最後まで完了する

### 2. ユーザーエクスペリエンスの向上
- ポーズメニューの表示・非表示が確実に完了するようになった
- 「途中で止まる」問題が解消され、UI挙動が予測可能になった

### 3. 安全なフラグ管理
- `finally` ブロックでフラグをリセットすることで、例外発生時やキャンセル時も確実にフラグがリセットされる
- フラグの不整合によるUI操作不能状態を防ぐ

## 動作フロー（修正後）

### 正常なフェードインフロー

```
1. ユーザーがポーズキーを押す
   ↓
2. TogglePauseMenu() が呼ばれる
   - isPauseMenuFading == false （フェード中でない）
   - ShowPauseMenu() を呼ぶ
   ↓
3. ShowPauseMenu()
   - isPauseMenuVisible = true
   - FadeInPauseMenuAsync() 開始
   ↓
4. FadeInPauseMenuAsync()
   - isPauseMenuFading = true （フェード開始）
   - 0.2秒かけてフェードイン
   - finally: isPauseMenuFading = false （フェード終了）
   ↓
5. フェード完了
```

### フェード中に連続入力があった場合

```
1. フェードイン中（isPauseMenuFading == true）
   ↓
2. ユーザーが再度ポーズキーを押す
   ↓
3. TogglePauseMenu() が呼ばれる
   - isPauseMenuFading == true （フェード中）
   - 早期リターン ★入力を無視
   ↓
4. 既存のフェードがそのまま継続
   ↓
5. フェード完了後、isPauseMenuFading = false
   ↓
6. 次の入力が受け付けられる
```

## 関連ファイル

- Assets/Scripts/GameManager/GameUIManager.cs (修正)

## テストケース

### ケース1: 通常のフェードイン・アウト
1. ポーズキーを押す
2. **期待結果**: フェードインが完了する
3. ポーズキーを押す
4. **期待結果**: フェードアウトが完了する

### ケース2: フェード中の連続入力
1. ポーズキーを押す
2. フェード中（0.2秒以内）に再度ポーズキーを押す
3. **期待結果**: 最初のフェードインが途中で止まらず、最後まで完了する
4. フェード完了後、次の入力が受け付けられる

### ケース3: フェード中の連打
1. ポーズキーを連打する
2. **期待結果**: 最初のフェード処理が完了するまで、後続の入力は無視される
3. フェード完了後、次の入力が受け付けられる

## 備考

### finally ブロックの重要性

`finally` ブロックを使用することで、以下のすべてのケースで確実に `isPauseMenuFading` フラグがリセットされます：

1. **正常終了**: フェードが最後まで完了した場合
2. **キャンセル**: `OperationCanceledException` が発生した場合
3. **エラー**: その他の例外が発生した場合

これにより、フラグの不整合によるUI操作不能状態を確実に防ぎます。

### フェード時間の考慮

現在のフェード時間は `pauseMenuFadeInDuration = 0.2f` 秒です。ユーザーがキーを連打した場合でも、0.2秒間は入力を無視することで、安定したアニメーションを実現しています。

### 既存の ShowPauseMenu() / HidePauseMenu() の重複チェック

`ShowPauseMenu()` と `HidePauseMenu()` には既に `isPauseMenuVisible` フラグによる重複チェックが実装されています。今回追加した `isPauseMenuFading` フラグは、これを補完する役割を果たします：

- `isPauseMenuVisible`: 最終的な表示状態を示す
- `isPauseMenuFading`: アニメーション実行中かどうかを示す

この2つのフラグにより、より堅牢な状態管理が実現されています。
