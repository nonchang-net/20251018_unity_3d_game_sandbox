# ワークログ: ポーズメニュー制御の設計見直しと状態管理の一元化

作成日時: 2025-10-26 16:26

## 変更した内容の概要

- ポーズメニューの状態管理を一元化し、GameStateManager.IsPausedを真実の情報源としました
- GameUIManagerの内部状態フラグ（isPauseMenuVisible, isPauseMenuFading）を削除しました
- GameUIManagerでIsPausedを購読し、UI表示を自動的に更新するように変更しました
- 入力制御の責務をUIからInputManagerに移動しました
- ポーズ解除時の状態不整合問題を解決しました

## なぜそのように変更しようと考えたか

- 「ポーズメニュー解除時に操作がポーズ状態でメニューが消えている」という状態不整合が発生していたため
- GameStateManagerがIsPausedを管理しているのに、GameUIManagerが独自にisPauseMenuVisibleを持っていたことで、状態の二重管理による不整合が発生していたため
- UIの責務として「isPauseMenuFading」で入力を無視するのは不適切であり、入力制御はGameInputManagerで行うべきと判断したため
- コードが混乱してきており、設計を見直す必要があったため

## 問題の詳細分析

### 元の設計の問題点

1. **状態管理の分散**
   - GameStateManager.IsPaused: ポーズ状態を管理
   - GameUIManager.isPauseMenuVisible: UI表示状態を独自に管理
   - 2つの状態が同期していない場合、不整合が発生

2. **責務の混乱**
   - GameUIManagerがisPauseMenuFadingで入力制御を行っていた
   - 入力制御はGameInputManagerの責務であるべき
   - UIは表示だけに専念すべき

3. **状態の不整合シナリオ**
   ```
   1. ユーザーがポーズキーを押す
   2. isPauseMenuVisible = true, IsPaused = true
   3. フェードイン開始
   4. OnResumeClicked()が呼ばれる
   5. HidePauseMenu()が呼ばれ、isPauseMenuVisible = false
   6. しかしIsPaused = trueのまま
   7. 結果: メニューは消えているが、ゲームはポーズ状態
   ```

## 新しい設計方針

### 単一の真実の情報源（Single Source of Truth）

**GameStateManager.IsPaused**をポーズ状態の唯一の真実の情報源とし、他のすべてのコンポーネントはこれを購読します。

### 責務の明確化

1. **GameStateManager**: ポーズ状態を管理（IsPaused ReactiveProperty）
2. **GameTimeManager**: IsPausedを購読してTime.timeScaleを制御
3. **GameUIManager**: IsPausedを購読してポーズメニューの表示/非表示を制御
4. **GameInputManager**: ポーズキー入力を受け取り、GameStateManager.TogglePause()を呼ぶ

### データフロー

```
ユーザー入力（ポーズキー）
  ↓
GameInputManager.OnTogglePause()
  ↓
GameTimeManager.TogglePause()
  ↓
GameStateManager.TogglePause()
  ↓
IsPaused.Value = !IsPaused.Value
  ↓
購読者に通知
  ├→ GameTimeManager: Time.timeScaleを更新
  └→ GameUIManager: ポーズメニューを表示/非表示
```

## 実装した修正内容

### 1. GameUIManager.cs の修正

#### 1-1. 内部状態フラグの削除

**削除したフラグ:**
```csharp
// 削除: private bool isPauseMenuVisible = false;
// 削除: private bool isPauseMenuFading = false;
```

**IsPauseMenuVisibleプロパティの変更:**
```csharp
// 修正前:
public bool IsPauseMenuVisible => isPauseMenuVisible;

// 修正後:
public bool IsPauseMenuVisible => gameManager?.StateManager?.State?.IsPaused?.CurrentValue ?? false;
```

GameStateManager.IsPausedを直接参照するようになりました。

#### 1-2. IsPaused購読の追加（Start()メソッド）

**追加したコード（167-178行目）:**
```csharp
// ポーズ状態変動購読（ポーズメニュー表示制御）
var pauseSubscriber = gameManager.StateManager.State.IsPaused.Subscribe(isPaused =>
{
    if (isPaused)
    {
        ShowPauseMenuInternal();
    }
    else
    {
        HidePauseMenuInternal();
    }
});
```

**disposableに追加（180-187行目）:**
```csharp
disposable = Disposable.Combine(
    coinSubscriber,
    totalCoinSubscriber,
    hitpointSubscriber,
    damageSubscriber,
    pauseSubscriber  // ★追加
);
```

IsPausedの変動を購読し、trueになったらポーズメニューを表示、falseになったら非表示にします。

#### 1-3. ShowPauseMenu() / HidePauseMenu() の再実装

**修正前:**
```csharp
public void ShowPauseMenu()
{
    if (isPauseMenuVisible) return;  // 重複チェック
    isPauseMenuVisible = true;        // フラグ更新
    // ...
}

public void HidePauseMenu()
{
    if (!isPauseMenuVisible) return;  // 重複チェック
    isPauseMenuVisible = false;       // フラグ更新
    // ...
}
```

**修正後:**
```csharp
/// <summary>
/// ポーズメニューを表示する（内部用：IsPaused購読から呼ばれる）
/// </summary>
private void ShowPauseMenuInternal()
{
    if (pauseMenu == null || pauseMenuCanvasGroup == null)
    {
        Debug.LogWarning("GameUIManager: pauseMenuまたはpauseMenuCanvasGroupが設定されていません。");
        return;
    }

    // ポーズメニューをアクティブ化
    pauseMenu.SetActive(true);

    // 既存のフェードを停止
    pauseMenuFadeCts?.Cancel();
    pauseMenuFadeCts?.Dispose();
    pauseMenuFadeCts = new CancellationTokenSource();

    // フェードインを開始
    FadeInPauseMenuAsync(pauseMenuFadeCts.Token).Forget();
}

/// <summary>
/// ポーズメニューを非表示にする（内部用：IsPaused購読から呼ばれる）
/// </summary>
private void HidePauseMenuInternal()
{
    if (pauseMenu == null || pauseMenuCanvasGroup == null)
    {
        return;
    }

    // 既存のフェードを停止
    pauseMenuFadeCts?.Cancel();
    pauseMenuFadeCts?.Dispose();
    pauseMenuFadeCts = new CancellationTokenSource();

    // フェードアウトを開始
    FadeOutPauseMenuAsync(pauseMenuFadeCts.Token).Forget();
}
```

**変更点:**
- メソッド名を`ShowPauseMenuInternal()` / `HidePauseMenuInternal()`に変更（内部専用であることを明示）
- プライベートメソッドに変更
- isPauseMenuVisibleフラグの更新を削除
- 重複チェックを削除（IsPaused購読から呼ばれるため不要）

#### 1-4. TogglePauseMenu() の簡素化

**修正前:**
```csharp
public void TogglePauseMenu()
{
    // フェード中は入力を無視
    if (isPauseMenuFading)
    {
        return;
    }

    if (isPauseMenuVisible)
    {
        HidePauseMenu();
    }
    else
    {
        ShowPauseMenu();
    }
}
```

**修正後:**
```csharp
/// <summary>
/// ポーズメニューの表示状態をトグルする（GameStateManager.TogglePause()を呼ぶ）
/// </summary>
public void TogglePauseMenu()
{
    gameManager.StateManager.TogglePause();
}
```

**変更点:**
- 単純にGameStateManager.TogglePause()を呼ぶだけに変更
- UI表示制御はIsPaused購読が自動的に行う
- isPauseMenuFadingによる入力制御を削除

#### 1-5. FadeInPauseMenuAsync() / FadeOutPauseMenuAsync() の修正

**修正前:**
```csharp
private async UniTaskVoid FadeInPauseMenuAsync(CancellationToken ct)
{
    isPauseMenuFading = true;  // フェード開始フラグ
    try
    {
        // フェード処理
    }
    finally
    {
        isPauseMenuFading = false;  // フェード終了フラグ
    }
}
```

**修正後:**
```csharp
private async UniTaskVoid FadeInPauseMenuAsync(CancellationToken ct)
{
    try
    {
        // フェード処理（フラグ管理を削除）
        float elapsedTime = 0f;
        float startAlpha = pauseMenuCanvasGroup.alpha;

        while (elapsedTime < pauseMenuFadeInDuration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / pauseMenuFadeInDuration);
            pauseMenuCanvasGroup.alpha = Mathf.Lerp(startAlpha, 1f, t);
            await UniTask.Yield(ct);
        }

        pauseMenuCanvasGroup.alpha = 1f;
    }
    catch (Exception ex) when (ex is not OperationCanceledException)
    {
        Debug.LogError($"GameUIManager: ポーズメニューフェードイン中にエラーが発生しました: {ex}");
    }
}
```

**変更点:**
- isPauseMenuFadingフラグの設定・リセットを削除
- UIの責務として、入力制御は行わない

FadeOutPauseMenuAsync()も同様の修正を実施しました。

#### 1-6. OnResumeClicked() の修正

**修正前:**
```csharp
private void OnResumeClicked()
{
    gameManager.TimeManager.Unpause();
    // note: GameInputManager.csに一元管理させた方が良いかもしれない? (OnTogglePauseとメソッドを分ける？)
    Cursor.lockState = CursorLockMode.Locked;
    Cursor.visible = false;
    HidePauseMenu();  // ★手動でUIを非表示
}
```

**修正後:**
```csharp
private void OnResumeClicked()
{
    // ポーズ解除（UIは自動的に非表示になる）
    gameManager.TimeManager.Unpause();

    // マウスカーソルをロック
    Cursor.lockState = CursorLockMode.Locked;
    Cursor.visible = false;
}
```

**変更点:**
- HidePauseMenu()の呼び出しを削除
- Unpause()によってIsPausedがfalseになり、IsPaused購読が自動的にUIを非表示にする

### 2. GameInputManager.cs の修正

#### OnTogglePause() の修正

**修正前:**
```csharp
public void OnTogglePause(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() < 0.5f) return;

    gameManager.TimeManager.TogglePause();
    gameManager.UIManager.TogglePauseMenu();  // ★UIを手動で制御

    // マウスカーソル制御
    bool isMenuVisible = gameManager.UIManager.IsPauseMenuVisible;

    if (isMenuVisible)
    {
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
    }
    else
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }
}
```

**修正後:**
```csharp
public void OnTogglePause(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() < 0.5f) return;

    // ポーズ状態をトグル（UIは自動的に更新される）
    gameManager.TimeManager.TogglePause();

    // マウスカーソル制御（IsPausedの状態を直接参照）
    bool isPaused = gameManager.StateManager.State.IsPaused.CurrentValue;

    if (isPaused)
    {
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
    }
    else
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }
}
```

**変更点:**
- `gameManager.UIManager.TogglePauseMenu()`の呼び出しを削除
- マウスカーソル制御をIsPausedの状態を直接参照するように変更
- UI表示はIsPaused購読が自動的に行う

## 修正後のデータフロー

### ポーズメニュー表示フロー

```
ユーザーがポーズキーを押す
  ↓
GameInputManager.OnTogglePause()
  ↓
GameTimeManager.TogglePause()
  ↓
GameStateManager.TogglePause()
  ↓
IsPaused.Value = true（ReactiveProperty）
  ↓
購読者に通知
  ├→ GameTimeManager: Time.timeScale = 0
  └→ GameUIManager: ShowPauseMenuInternal()
      ↓
      FadeInPauseMenuAsync() 開始
      ↓
      0.2秒かけてフェードイン
```

### ポーズメニュー非表示フロー

```
ユーザーが再開ボタンをクリック または ポーズキーを再度押す
  ↓
OnResumeClicked() または OnTogglePause()
  ↓
GameTimeManager.Unpause() または TogglePause()
  ↓
GameStateManager.Unpause() または TogglePause()
  ↓
IsPaused.Value = false（ReactiveProperty）
  ↓
購読者に通知
  ├→ GameTimeManager: Time.timeScale = 元の値
  └→ GameUIManager: HidePauseMenuInternal()
      ↓
      FadeOutPauseMenuAsync() 開始
      ↓
      0.2秒かけてフェードアウト
```

## 利点

### 1. 状態の一貫性

- IsPausedが唯一の真実の情報源となり、状態の不整合が発生しない
- どのコンポーネントからポーズ状態を変更しても、すべてのUIが自動的に同期される

### 2. 責務の明確化

- GameUIManager: UI表示のみに専念
- GameInputManager: 入力処理のみに専念
- GameStateManager: 状態管理のみに専念

### 3. コードの簡潔化

- 内部状態フラグ（isPauseMenuVisible, isPauseMenuFading）を削除
- ShowPauseMenu() / HidePauseMenu()の呼び出しが不要に
- コードの見通しが良くなった

### 4. 拡張性の向上

- 新しいコンポーネントがIsPausedを購読するだけで、ポーズ状態に応じた処理を追加できる
- 例: ポーズ中にBGMをフェードアウトさせる、など

## 関連ファイル

- Assets/Scripts/GameManager/GameUIManager.cs (修正)
- Assets/Scripts/GameManager/GameInputManager.cs (修正)

## 解決された問題

### 問題1: ポーズ解除時の状態不整合

**症状:** ポーズメニュー解除時に操作がポーズ状態でメニューが消えている

**原因:** isPauseMenuVisibleとIsPausedの状態が同期していなかった

**解決:** IsPausedを唯一の真実の情報源とし、UI表示はIsPausedを購読して自動的に更新されるようになった

### 問題2: フェードアニメーション中の入力制御

**症状:** フェード中の入力を無視するためにisPauseMenuFadingフラグを使用していた

**原因:** UIの責務として入力制御を行っていた（設計上の誤り）

**解決:** 入力制御の責務をGameInputManagerに移動（今後必要に応じて実装可能）

## 今後の検討事項

### 1. フェード中の入力制御（オプション）

現在の実装では、フェードアニメーション中でもポーズキーを受け付けます。もし必要であれば、GameInputManagerで以下のような実装を検討できます：

```csharp
// GameInputManagerに追加
private bool isProcessingPauseToggle = false;

public void OnTogglePause(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() < 0.5f) return;

    // フェード処理中は入力を無視
    if (isProcessingPauseToggle) return;

    isProcessingPauseToggle = true;

    gameManager.TimeManager.TogglePause();

    // 0.2秒後にフラグをリセット（フェード時間と同期）
    UniTask.Delay(TimeSpan.FromSeconds(0.2f))
        .ContinueWith(() => isProcessingPauseToggle = false)
        .Forget();

    // マウスカーソル制御
    // ...
}
```

ただし、現状では連続入力を許容しても問題ない設計になっているため、この実装は必要に応じて検討してください。

### 2. マウスカーソル制御の一元化

現在、マウスカーソル制御はGameInputManagerとOnResumeClicked()の両方で行われています。将来的には、IsPausedを購読してマウスカーソル制御を行う専用のコンポーネントを作成することも検討できます。

## テストケース

### ケース1: 通常のポーズ・解除
1. ポーズキーを押す
2. **期待結果**: IsPaused = true, ポーズメニューがフェードイン
3. 再度ポーズキーを押す
4. **期待結果**: IsPaused = false, ポーズメニューがフェードアウト

### ケース2: 再開ボタンによる解除
1. ポーズキーを押す
2. **期待結果**: ポーズメニュー表示
3. 再開ボタンをクリック
4. **期待結果**: IsPaused = false, ポーズメニューがフェードアウト、マウスカーソルロック

### ケース3: 状態の一貫性確認
1. ポーズキーを押す
2. IsPaused.CurrentValueを確認 → true
3. IsPauseMenuVisibleを確認 → true
4. **期待結果**: すべての状態が一致

## 備考

### ReactivePropertyの利点

R3のReactivePropertyを使用することで、Observerパターンを簡潔に実装できました。状態の変更を購読するだけで、自動的にUIが更新されるリアクティブな設計が実現できています。

### Single Source of Truthパターン

今回の修正は、「Single Source of Truth（単一の真実の情報源）」というデザインパターンに従っています。これにより、状態の不整合を防ぎ、コードの見通しを良くすることができました。

### 旧worklogとの関係

worklog/20251026_1609.mdで実装した「isPauseMenuFadingフラグ」は、今回の設計見直しによって削除されました。これは、UIの責務として入力制御を行うべきではないという判断に基づいています。
