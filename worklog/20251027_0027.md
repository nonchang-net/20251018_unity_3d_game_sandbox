# ワークログ: 水中表現機能の実装

作成日時: 2025-10-27 00:27

## 変更した内容の概要

- GameManagerに水面の高さ設定を追加し、Transformまたはデフォルト値（Y=0）で水面の高さを管理できるようにしました
- GameStateManagerにカメラの状態を表すenum（Normal, WhiteOut, BlackOut, InWater）を追加し、ReactivePropertyで状態を管理できるようにしました
- GameCameraManagerに水中判定機能を実装し、カメラの位置が水面以下にあるかを毎フレーム判定してGameStateManagerに通知するようにしました
- GamePostProcessManagerに水中表現用のポストプロセス効果を実装し、カラー変化、ビネット効果、時間経過で揺らぐ表現を追加しました

## なぜそのように変更しようと考えたか

- カメラが「水の中」にいる時の視覚的表現を実装することで、ゲームの没入感を高めるため
- 水面の高さを設定できるようにすることで、レベルデザインの柔軟性を確保するため
- カメラの状態を一元管理することで、将来的に他の状態（WhiteOut、BlackOut等）も追加しやすくするため

## 実装詳細

### 1. GameManager.cs の変更

#### 水面設定の追加（45-55行目）

```csharp
[Header("水面設定")]
[Tooltip("水面の高さを示すTransform（未設定の場合はY=0以下を水面とする）")]
[SerializeField] private Transform waterSurfaceTransform;

/// <summary>水面の高さを取得（未設定の場合は0を返す）</summary>
public float WaterSurfaceHeight => waterSurfaceTransform != null ? waterSurfaceTransform.position.y : 0f;
```

**機能:**
- インスペクターから水面の高さを示すTransformを設定可能
- 未設定の場合はY=0を水面として扱う
- 他のコンポーネントからプロパティで簡単にアクセス可能

**使用例:**
- 海のオブジェクトのTransformを設定すれば、その高さを自動的に水面として扱える
- 動的に水面の高さを変えたい場合は、Transformの位置を変更するだけで対応可能

### 2. GameStateManager.cs の変更

#### CameraState enumの追加（1-17行目）

```csharp
/// <summary>
/// カメラの状態を表すenum
/// </summary>
public enum CameraState
{
    /// <summary>通常状態</summary>
    Normal,
    /// <summary>ホワイトアウト状態</summary>
    WhiteOut,
    /// <summary>ブラックアウト状態</summary>
    BlackOut,
    /// <summary>水中状態</summary>
    InWater
}
```

**設計意図:**
- 将来的に様々なカメラ状態に対応できるよう、拡張可能なenumを定義
- Normal: 通常状態
- WhiteOut: ホワイトアウト状態（将来実装）
- BlackOut: ブラックアウト状態（将来実装）
- InWater: 水中状態（今回実装）

#### GameStateクラスへのCurrentCameraState追加（367-370行目）

```csharp
/// <summary>
/// 現在のカメラ状態
/// </summary>
public ReactiveProperty<CameraState> CurrentCameraState { get; private set; }
```

#### コンストラクタでの初期化（388行目）

```csharp
CurrentCameraState = new ReactiveProperty<CameraState>(CameraState.Normal);
```

#### SetCameraState()メソッドの追加（185-192行目）

```csharp
/// <summary>
/// カメラの状態を設定する
/// </summary>
/// <param name="cameraState">設定するカメラ状態</param>
public void SetCameraState(CameraState cameraState)
{
    state.CurrentCameraState.Value = cameraState;
}
```

**設計パターン:**
- R3のReactivePropertyを使用することで、状態変更を他のコンポーネントが購読可能
- Single Source of Truth（単一の真実の情報源）パターンを採用
- SetCameraState()を呼ぶだけで、購読しているすべてのコンポーネントに通知される

### 3. GameCameraManager.cs の実装

#### 完全実装（1-67行目）

```csharp
using UnityEngine;

/// <summary>
/// ゲーム中のカメラを管理するクラス
/// - カメラの状態管理（水中判定など）
/// - CharacterTrackerとは異なり、ゲーム中のカメラの状態を集約的に管理
/// </summary>
public class GameCameraManager : MonoBehaviour
{
    [Header("GameManager")]
    [SerializeField] private GameManager gameManager;

    [Header("Camera Management")]
    [SerializeField] private Camera currentCamera;

    /// <summary>前フレームのカメラ状態</summary>
    private CameraState previousCameraState = CameraState.Normal;

    void Start()
    {
        // 参照確認
        if (gameManager == null)
        {
            Debug.LogError("GameCameraManager: GameManager が設定されていません。");
            return;
        }

        if (currentCamera == null)
        {
            Debug.LogError("GameCameraManager: currentCamera が設定されていません。");
            return;
        }
    }

    void Update()
    {
        // 水中判定を行い、カメラ状態を更新
        CheckWaterState();
    }

    /// <summary>
    /// カメラが水中にいるかどうかを判定し、状態を更新
    /// </summary>
    private void CheckWaterState()
    {
        if (gameManager == null || currentCamera == null) return;

        // カメラの現在位置を取得
        float cameraY = currentCamera.transform.position.y;

        // 水面の高さを取得
        float waterSurfaceHeight = gameManager.WaterSurfaceHeight;

        // カメラが水面以下にいるか判定
        bool isUnderWater = cameraY <= waterSurfaceHeight;

        // 現在のカメラ状態を判定
        CameraState currentState = isUnderWater ? CameraState.InWater : CameraState.Normal;

        // 状態が変わった場合のみGameStateManagerに通知
        if (currentState != previousCameraState)
        {
            gameManager.StateManager.SetCameraState(currentState);
            previousCameraState = currentState;
        }
    }
}
```

**責務:**
- カメラの状態を監視
- 水中判定を毎フレーム実行
- 状態が変わった場合のみGameStateManagerに通知（不要な通知を削減）

**CharacterTrackerとの違い:**
- CharacterTracker: カメラの追従処理を担当
- GameCameraManager: カメラの状態管理を担当

### 4. GamePostProcessManager.cs の変更

#### 水中効果設定の追加（65-76行目）

```csharp
[Header("水中効果設定")]
[SerializeField] private bool enableWaterEffect = true;
[Tooltip("水中時のカラーフィルター色（青緑色）")]
[SerializeField] private Color waterColor = new Color(0.4f, 0.8f, 0.9f, 1f);
[Tooltip("水中時のカラーフィルター強度")]
[SerializeField] private float waterColorIntensity = 0.4f;
[Tooltip("水中時のビネット強度")]
[SerializeField] private float waterVignetteIntensity = 0.35f;
[Tooltip("水中効果の揺らぎ周期（秒）")]
[SerializeField] private float waterWaveCycle = 2.5f;
[Tooltip("水中効果の揺らぎ強度")]
[SerializeField] private float waterWaveIntensity = 0.15f;
```

**設定値の説明:**
- enableWaterEffect: 水中効果のON/OFF
- waterColor: 水中時のカラーフィルター色（デフォルト: 青緑色）
- waterColorIntensity: カラーフィルター強度（0.0〜1.0）
- waterVignetteIntensity: 水中時のビネット強度（0.35 = 通常より暗い）
- waterWaveCycle: 揺らぎの周期（2.5秒）
- waterWaveIntensity: 揺らぎの強度（0.15 = 15%の揺らぎ）

#### 水中効果制御フラグの追加（103-105行目）

```csharp
// 水中効果制御
private bool isInWater = false;
private float waterEffectTime = 0f;
```

#### R3購読管理の追加（111行目）

```csharp
private IDisposable cameraStateSubscription;
```

#### Start()での購読開始（119行目）

```csharp
SubscribeCameraStateEvents();
```

#### SubscribeCameraStateEvents()の実装（168-190行目）

```csharp
/// <summary>
/// カメラ状態変更イベントを購読
/// </summary>
void SubscribeCameraStateEvents()
{
    cameraStateSubscription = gameManager.StateManager.State.CurrentCameraState.Subscribe(cameraState =>
    {
        // 水中状態の更新
        isInWater = (cameraState == CameraState.InWater);

        // 水中状態から抜けた場合は、効果をリセット
        if (!isInWater && enableWaterEffect && colorAdjustments != null && vignette != null)
        {
            // ダメージフラッシュや警告点滅中でない場合のみリセット
            if (!isDamageFlashing && !isCautionMode && !isDeadFading)
            {
                colorAdjustments.colorFilter.value = Color.white;
                vignette.intensity.value = normalVignetteIntensity;
            }
            waterEffectTime = 0f;
        }
    });
}
```

**機能:**
- CurrentCameraStateを購読し、InWater状態になったらisInWaterフラグをtrue
- 水中状態から抜けた場合は、カラーフィルターとビネットをリセット
- 他のエフェクト（ダメージフラッシュ等）実行中はリセットしない

#### Update()での水中効果更新（259行目）

```csharp
UpdateWaterEffect();
```

#### UpdateWaterEffect()の実装（505-531行目）

```csharp
/// <summary>
/// 水中効果を更新
/// </summary>
void UpdateWaterEffect()
{
    if (!enableWaterEffect || !isInWater || colorAdjustments == null || vignette == null) return;

    // ダメージフラッシュ中、警告点滅中、死亡フェード中は水中効果を適用しない
    if (isDamageFlashing || isCautionMode || isDeadFading) return;

    // 時間を更新
    waterEffectTime += Time.deltaTime;

    // サイン波で揺らぎを作成（0〜1の範囲）
    float wave = Mathf.Sin(waterEffectTime * Mathf.PI * 2f / waterWaveCycle);
    wave = (wave + 1f) * 0.5f; // -1〜1 を 0〜1 に変換

    // 揺らぎ強度を計算
    float waveEffect = Mathf.Lerp(1f - waterWaveIntensity, 1f + waterWaveIntensity, wave);

    // カラーフィルターを適用（水の色）
    Color currentWaterColor = Color.Lerp(Color.white, waterColor, waterColorIntensity * waveEffect);
    colorAdjustments.colorFilter.value = currentWaterColor;

    // ビネット強度を適用（水中の暗さ）
    vignette.intensity.value = Mathf.Lerp(normalVignetteIntensity, waterVignetteIntensity, waveEffect);
}
```

**実装ポイント:**
1. **優先度制御**: ダメージフラッシュ等の重要なエフェクト実行中は水中効果を適用しない
2. **サイン波による揺らぎ**: `Mathf.Sin()`を使用して周期的な揺らぎを実装
3. **カラーフィルター**: 青緑色を適用することで水中の色合いを再現
4. **ビネット効果**: 画面周辺を暗くすることで水中の視界制限を表現
5. **揺らぎのスケーリング**: waveEffectを使用して揺らぎの強弱をリアルタイムで変化

#### OnDestroy()での購読解放（268行目）

```csharp
cameraStateSubscription?.Dispose();
```

#### SetEffectEnabled()への水中効果追加（562-564行目）

```csharp
case "watereffect":
    enableWaterEffect = enabled;
    break;
```

## データフロー

### 水中表現のデータフロー

```
カメラが水面以下に移動
  ↓
GameCameraManager.CheckWaterState()
  ├→ カメラのY座標を取得
  ├→ GameManager.WaterSurfaceHeightを取得
  └→ 水中判定（cameraY <= waterSurfaceHeight）
  ↓
GameStateManager.SetCameraState(CameraState.InWater)
  ↓
CurrentCameraState.Value = CameraState.InWater（ReactiveProperty）
  ↓
購読者に通知
  ↓
GamePostProcessManager.SubscribeCameraStateEvents()
  ├→ isInWater = true
  └→ waterEffectTime = 0f（リセット）
  ↓
GamePostProcessManager.UpdateWaterEffect()（毎フレーム）
  ├→ サイン波で揺らぎを計算
  ├→ カラーフィルターを適用（青緑色）
  └→ ビネット強度を適用（暗さ）
  ↓
画面に水中表現が適用される
```

### 水面から出た時のフロー

```
カメラが水面より上に移動
  ↓
GameCameraManager.CheckWaterState()
  └→ 水面上判定（cameraY > waterSurfaceHeight）
  ↓
GameStateManager.SetCameraState(CameraState.Normal)
  ↓
CurrentCameraState.Value = CameraState.Normal
  ↓
GamePostProcessManager.SubscribeCameraStateEvents()
  ├→ isInWater = false
  ├→ colorAdjustments.colorFilter.value = Color.white（リセット）
  ├→ vignette.intensity.value = normalVignetteIntensity（リセット）
  └→ waterEffectTime = 0f（リセット）
  ↓
画面が通常状態に戻る
```

## 設定方法

### 1. GameManagerの設定

**Inspector設定:**
1. GameManagerオブジェクトを選択
2. 「水面設定」セクションで「Water Surface Transform」に水面のTransformを設定
3. 未設定の場合はY=0が水面として扱われる

**動的な水面の高さ:**
```csharp
// 水面Transformを動的に設定する例
Transform waterTransform = GameObject.Find("WaterSurface").transform;
// GameManagerのserializeFieldを直接変更はできないが、
// Transformの位置を変えるだけで水面の高さが変わる
waterTransform.position = new Vector3(0f, 5f, 0f);
```

### 2. GameCameraManagerの設定

**Inspector設定:**
1. メインカメラに GameCameraManager コンポーネントを追加（または専用のGameObjectに追加）
2. 「Game Manager」に GameManager オブジェクトを設定
3. 「Current Camera」に Main Camera を設定

**注意:**
- GameCameraManagerは毎フレームUpdate()で水中判定を行うため、パフォーマンスへの影響は軽微です

### 3. GamePostProcessManagerの設定

**Inspector設定（水中効果）:**
1. GamePostProcessManager オブジェクトを選択
2. 「水中効果設定」セクションで以下を調整:
   - Enable Water Effect: チェックを入れる/外す（デフォルト: ON）
   - Water Color: 水中時の色（デフォルト: 青緑色 R:0.4, G:0.8, B:0.9）
   - Water Color Intensity: 色の強度（デフォルト: 0.4）
   - Water Vignette Intensity: ビネット強度（デフォルト: 0.35）
   - Water Wave Cycle: 揺らぎの周期（デフォルト: 2.5秒）
   - Water Wave Intensity: 揺らぎの強度（デフォルト: 0.15）

## 技術的なポイント

### 1. ReactivePropertyによる状態管理

R3のReactivePropertyを使用することで、カメラ状態の変更を自動的に通知する仕組みを実装しました。

**利点:**
- 状態変更を監視するコードを書く必要がない
- 複数のコンポーネントが同じ状態を購読可能
- 状態の変更が即座にすべての購読者に伝わる

### 2. 状態が変わった場合のみ通知

GameCameraManagerでは、前フレームの状態（previousCameraState）を保持し、状態が変わった場合のみGameStateManagerに通知します。

**利点:**
- 不要な通知を削減し、パフォーマンスを向上
- ReactivePropertyのSubscribeが毎フレーム発火しない

### 3. エフェクトの優先度制御

GamePostProcessManagerでは、ダメージフラッシュ、HP警告点滅、死亡フェードなどの重要なエフェクト実行中は水中効果を適用しません。

```csharp
// ダメージフラッシュ中、警告点滅中、死亡フェード中は水中効果を適用しない
if (isDamageFlashing || isCautionMode || isDeadFading) return;
```

**利点:**
- 重要なゲームプレイフィードバック（ダメージ等）を優先
- エフェクトが混ざって見づらくなることを防ぐ

### 4. サイン波による揺らぎ

水中効果の揺らぎには、サイン波を使用して滑らかな周期的変化を実現しています。

```csharp
float wave = Mathf.Sin(waterEffectTime * Mathf.PI * 2f / waterWaveCycle);
wave = (wave + 1f) * 0.5f; // -1〜1 を 0〜1 に変換
```

**利点:**
- 自然な揺らぎ表現
- 周期と強度を簡単に調整可能
- パフォーマンスが高い（単純な数学関数）

### 5. カラーフィルターとビネットの組み合わせ

水中表現には、ColorAdjustmentsのcolorFilterとVignetteを組み合わせて使用しています。

- **colorFilter**: 画面全体に青緑色のフィルターを適用
- **vignette**: 画面周辺を暗くして視界制限を表現

**利点:**
- 既存のポストプロセス機能を再利用
- 他のエフェクトとの共存が可能
- 設定値の調整が簡単

## 今後の拡張案

### 1. 水面突入時のエフェクト

水面に突入した瞬間に、水しぶきや波紋のエフェクトを追加することで、より没入感を高めることができます。

```csharp
// GameCameraManager.CheckWaterState()に追加
if (currentState != previousCameraState)
{
    if (currentState == CameraState.InWater)
    {
        // 水面突入エフェクト
        PlayWaterSplashEffect();
    }
    else
    {
        // 水面離脱エフェクト
        PlayWaterExitEffect();
    }
    gameManager.StateManager.SetCameraState(currentState);
    previousCameraState = currentState;
}
```

### 2. 水深による効果の変化

カメラの深さに応じて、水中効果の強度を変化させることができます。

```csharp
// 水深を計算
float waterDepth = waterSurfaceHeight - cameraY;
float depthIntensity = Mathf.Clamp01(waterDepth / maxWaterDepth);

// 深さに応じてカラーフィルター強度を変更
float adjustedIntensity = waterColorIntensity * depthIntensity;
```

### 3. 水中サウンド

水中にいる間、サウンドにローパスフィルターを適用することで、水中の音響効果を再現できます。

```csharp
// GameSoundManagerに追加
if (isInWater)
{
    ApplyLowPassFilter();
}
else
{
    RemoveLowPassFilter();
}
```

### 4. 他のカメラ状態の実装

現在はInWaterのみ実装していますが、WhiteOutやBlackOutも簡単に追加できます。

```csharp
// WhiteOut実装例
case CameraState.WhiteOut:
    colorAdjustments.colorFilter.value = Color.white;
    colorAdjustments.postExposure.value = 10f;
    break;

// BlackOut実装例
case CameraState.BlackOut:
    colorAdjustments.colorFilter.value = Color.black;
    colorAdjustments.postExposure.value = -10f;
    break;
```

### 5. パーティクルエフェクトの追加

水中にいる間、気泡や浮遊物のパーティクルを追加することで、より臨場感のある表現が可能です。

## テストケース

### ケース1: 水面より上から下に移動

1. カメラをY=5の位置に配置
2. 水面をY=2.8に設定
3. カメラをY=2の位置に移動
4. **期待結果**: 水中効果が適用される（青緑色のフィルター、ビネット、揺らぎ）

### ケース2: 水面より下から上に移動

1. カメラをY=2の位置に配置
2. 水面をY=2.8に設定
3. カメラをY=5の位置に移動
4. **期待結果**: 水中効果が解除される（通常の画面に戻る）

### ケース3: 水面をちょうど通過

1. カメラをY=2.8の位置に配置（水面と同じ高さ）
2. **期待結果**: 水中効果が適用される（cameraY <= waterSurfaceHeightなので水中と判定）

### ケース4: 水中でダメージを受ける

1. カメラを水中に移動
2. ダメージを受ける
3. **期待結果**: ダメージフラッシュが優先され、水中効果は一時的に非表示

### ケース5: 水中でHPが1以下になる

1. カメラを水中に移動
2. HPを1以下にする
3. **期待結果**: HP警告点滅が優先され、水中効果は一時的に非表示

### ケース6: 水面の高さ未設定

1. GameManagerのwaterSurfaceTransformを未設定のままにする
2. カメラをY=-1の位置に移動
3. **期待結果**: Y=0が水面として扱われ、水中効果が適用される

## 利点

### 1. 視覚的フィードバックの向上

- プレイヤーがカメラの状態を直感的に理解できる
- 水中にいることが明確にわかる

### 2. 没入感の向上

- 揺らぎ効果により、水中の動的な表現が可能
- ビネット効果により、水中の視界制限を再現

### 3. 拡張性

- CameraStateに他の状態を追加しやすい
- 水中以外の表現（WhiteOut、BlackOut等）も簡単に実装可能

### 4. パフォーマンス

- 状態が変わった場合のみ通知するため、不要な処理を削減
- 既存のポストプロセス機能を再利用しているため、追加のパフォーマンス負荷は軽微

### 5. レベルデザインの柔軟性

- 水面の高さをTransformで指定できるため、レベルごとに簡単に調整可能
- 動的に水面の高さを変更することも可能

## 関連ファイル

- Assets/Scripts/GameManager/GameManager.cs (修正: 水面設定追加)
- Assets/Scripts/GameManager/GameStateManager.cs (修正: CameraState enum追加、CurrentCameraState追加)
- Assets/Scripts/Camera/GameCameraManager.cs (新規実装: 水中判定機能)
- Assets/Scripts/Character/GamePostProcessManager.cs (修正: 水中効果実装)

## 備考

### 水面の高さの扱い

現在の実装では、カメラのY座標が水面の高さ以下（`cameraY <= waterSurfaceHeight`）の場合に水中と判定しています。これにより、ちょうど水面と同じ高さにいる場合も水中として扱われます。

この判定ロジックは、必要に応じて以下のように変更できます：

```csharp
// ちょうど水面にいる場合は水中としない場合
bool isUnderWater = cameraY < waterSurfaceHeight;
```

### エフェクトのチューニング

水中効果のパラメータ（色、強度、揺らぎ等）は、ゲームの雰囲気に応じて調整してください。以下は推奨値の例です：

**リアル志向:**
- waterColor: `(0.2f, 0.6f, 0.8f)` - より深い青
- waterColorIntensity: `0.6f` - 強めの色
- waterVignetteIntensity: `0.5f` - 強めの暗さ

**ファンタジー志向:**
- waterColor: `(0.4f, 0.8f, 1.0f)` - 明るい水色
- waterColorIntensity: `0.3f` - 控えめの色
- waterVignetteIntensity: `0.25f` - 控えめの暗さ

### 既存エフェクトとの整合性

GamePostProcessManagerには、既にダメージフラッシュ、HP警告点滅、死亡フェードなどのエフェクトが実装されています。今回実装した水中効果は、これらのエフェクトと共存できるよう、優先度制御を実装しています。

優先度（高い順）:
1. 死亡フェード（isDeadFading）
2. ダメージフラッシュ（isDamageFlashing）
3. HP警告点滅（isCautionMode）
4. 水中効果（isInWater）

### 将来的な改善点

- 水面突入/離脱時のトランジション効果（フェードイン/アウト）
- 水深に応じた効果の変化
- 水中サウンドエフェクト
- 水中パーティクル（気泡、浮遊物等）
