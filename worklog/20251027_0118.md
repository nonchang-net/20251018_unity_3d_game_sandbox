# ワークログ: カメラ距離切り替え機能の実装

作成日時: 2025-10-27 01:18

## 変更した内容の概要

- TrackingSettingというScriptableObjectを新規作成し、CharacterTrackerの設定項目（Target Transform以外）を移動しました
- CharacterTrackerをリファクタリングし、TrackingSettingから設定を読み込むように変更しました
- GameStateManagerにカメラビュー切り替えイベント（OnCameraViewChangeRequested）を追加しました
- GameInputManagerのOnZoomToggle()を実装し、Zキーでカメラ切り替えをリクエストできるようにしました
- GameCameraManagerにTogglableTrackingSettings配列を追加し、複数のカメラ設定を切り替えられる機能を実装しました

## なぜそのように変更しようと考えたか

- Zキーを押すたびにカメラ距離を切り替える機能を実装することで、プレイヤーが状況に応じて視点を変更できるようにするため
- カメラ設定をScriptableObjectに分離することで、複数のプリセットを簡単に作成・管理できるようにするため
- 設定をコードから分離することで、デザイナーやプランナーがコードを変更せずにカメラパラメータを調整できるようにするため

## 実装詳細

### 1. TrackingSetting.cs の新規作成

#### ScriptableObjectの定義

```csharp
[CreateAssetMenu(fileName = "TrackingSetting", menuName = "Game/Camera/Tracking Setting", order = 1)]
public class TrackingSetting : ScriptableObject
{
    // カメラ設定
    private float cameraDistance = 6f;
    private float cameraHeight = 2f;
    private bool invertVerticalAxis = false;
    private float mouseSensitivityMultiplier = 1f;

    // カメラ制限
    private float minPitch = -30f;
    private float maxPitch = 70f;
    private float initialPitch = -40f;

    // 障害物回避
    private bool enableCollisionAvoidance = true;
    private float cameraRadius = 0.3f;
    private LayerMask collisionLayers = -1;
    private float collisionSmoothSpeed = 10f;

    // カメラスムージング
    private float positionSmoothSpeed = 15f;
    private float minDistanceThreshold = 0.5f;

    // カメラリセット設定
    private bool resetPitchOnReset = true;
    private float resetPitchAngle = -40f;
}
```

**設計意図:**
- CharacterTrackerで使用していた全てのパラメータをScriptableObjectに移動
- 各パラメータにプロパティを用意し、外部から読み取り専用でアクセス可能
- CreateAssetMenuアトリビュートでUnityエディタから簡単に作成可能

**利点:**
- 複数のカメラプリセット（近距離、中距離、遠距離など）を簡単に作成可能
- 実行時にコードを変更せずにパラメータを調整可能
- プロジェクト間でカメラ設定を再利用可能

### 2. CharacterTracker.cs のリファクタリング

#### 設定項目の移動（CharacterTracker.cs:12-31）

**修正前:**
```csharp
[Header("カメラ設定")]
[SerializeField] private float cameraDistance = 6f;
[SerializeField] private float cameraHeight = 2f;
[SerializeField] private bool invertVerticalAxis = false;
[SerializeField] private float mouseSensitivityMultiplier = 1f;
// ... 他の設定項目も同様
```

**修正後:**
```csharp
[Header("トラッキング設定")]
[Tooltip("カメラトラッキングの設定（ScriptableObject）")]
[SerializeField] private TrackingSetting trackingSetting;

// TrackingSettingから取得するプロパティ
private float cameraDistance => trackingSetting != null ? trackingSetting.CameraDistance : 6f;
private float cameraHeight => trackingSetting != null ? trackingSetting.CameraHeight : 2f;
// ... 他の設定項目も同様にプロパティ化
```

**設計パターン:**
- プロパティを使用して、TrackingSettingから設定値を動的に取得
- TrackingSettingがnullの場合はデフォルト値を返す（フェールセーフ）
- 既存のコードロジックは変更せず、設定の読み込み元のみ変更

#### 新しいメソッドの追加（CharacterTracker.cs:209-230）

```csharp
/// <summary>
/// トラッキング設定を変更
/// </summary>
public void SetTrackingSetting(TrackingSetting newSetting)
{
    trackingSetting = newSetting;

    // 設定変更時にカメラ距離を再初期化
    if (trackingSetting != null)
    {
        currentCameraDistance = trackingSetting.CameraDistance;
    }
}

/// <summary>
/// 現在のトラッキング設定を取得
/// </summary>
public TrackingSetting GetTrackingSetting()
{
    return trackingSetting;
}
```

**機能:**
- SetTrackingSetting(): 実行時にトラッキング設定を変更可能
- 設定変更時にカメラ距離を再初期化することで、スムーズな切り替えを実現
- GetTrackingSetting(): 現在の設定を取得可能

#### 削除したメソッド

以下のメソッドは、TrackingSettingに設定が移動したため削除しました:
- SetCameraDistance()
- SetCameraInvertY()
- SetMouseSensitivity()

### 3. GameStateManager.cs の変更

#### OnCameraViewChangeRequestedの追加（GameStateManager.cs:380-383）

```csharp
/// <summary>
/// カメラビュー切り替えがリクエストされたときに発火するSubject
/// </summary>
public Subject<Unit> OnCameraViewChangeRequested { get; private set; }
```

#### コンストラクタでの初期化（GameStateManager.cs:398）

```csharp
OnCameraViewChangeRequested = new Subject<Unit>();
```

#### RequestNextCameraView()メソッドの追加（GameStateManager.cs:194-200）

```csharp
/// <summary>
/// カメラ切り替えをリクエストする
/// </summary>
public void RequestNextCameraView()
{
    state.OnCameraViewChangeRequested.OnNext(Unit.Default);
}
```

**設計意図:**
- R3のSubjectを使用してイベント駆動型の設計を採用
- カメラ切り替えのリクエストを一元管理
- 複数のコンポーネントがこのイベントを購読可能

### 4. GameInputManager.cs の変更

#### OnZoomToggle()の実装（GameInputManager.cs:148-155）

**修正前:**
```csharp
public void OnZoomToggle(InputAction.CallbackContext context)
{
}
```

**修正後:**
```csharp
public void OnZoomToggle(InputAction.CallbackContext context)
{
    if (context.ReadValue<float>() > 0.5f)
    {
        // カメラビュー切り替えをリクエスト
        gameManager.StateManager.RequestNextCameraView();
    }
}
```

**機能:**
- Zキー（ZoomToggle）の入力を検出
- GameStateManager.RequestNextCameraView()を呼び出し
- 0.5f以上の値でトリガー（キーが押された瞬間のみ反応）

### 5. GameCameraManager.cs の変更

#### 新しいフィールドの追加（GameCameraManager.cs:19-30）

```csharp
[Header("Tracking Settings")]
[Tooltip("切り替え可能なトラッキング設定の配列")]
[SerializeField] private TrackingSetting[] togglableTrackingSettings;

/// <summary>現在のトラッキング設定インデックス</summary>
private int currentTrackingSettingIndex = 0;

/// <summary>R3購読管理</summary>
private IDisposable cameraViewChangeSubscription;
```

**設計:**
- togglableTrackingSettings: 切り替え可能なTrackingSettingの配列
- currentTrackingSettingIndex: 現在適用されている設定のインデックス
- cameraViewChangeSubscription: R3のSubject購読を管理

#### Start()メソッドの拡張（GameCameraManager.cs:47-60）

```csharp
// トラッキング設定の検証
if (togglableTrackingSettings == null || togglableTrackingSettings.Length == 0)
{
    Debug.LogWarning("GameCameraManager: togglableTrackingSettings が設定されていません。カメラ切り替え機能は無効化されます。");
}
else
{
    // 初期設定を適用
    ApplyTrackingSetting(0);
}

// カメラビュー切り替えイベントを購読
SubscribeCameraViewChangeEvents();
```

**機能:**
- 起動時にトラッキング設定配列を検証
- 配列の最初の設定を初期設定として適用
- カメラビュー切り替えイベントを購読

#### OnDestroy()の追加（GameCameraManager.cs:62-66）

```csharp
void OnDestroy()
{
    // R3購読の解放
    cameraViewChangeSubscription?.Dispose();
}
```

**重要性:**
- R3のSubscriptionを適切に破棄してメモリリークを防止

#### SubscribeCameraViewChangeEvents()の実装（GameCameraManager.cs:101-110）

```csharp
/// <summary>
/// カメラビュー切り替えイベントを購読
/// </summary>
private void SubscribeCameraViewChangeEvents()
{
    cameraViewChangeSubscription = gameManager.StateManager.State.OnCameraViewChangeRequested.Subscribe(_ =>
    {
        SwitchToNextTrackingSetting();
    });
}
```

**機能:**
- OnCameraViewChangeRequestedを購読
- イベントが発火したらSwitchToNextTrackingSetting()を呼び出し

#### SwitchToNextTrackingSetting()の実装（GameCameraManager.cs:112-128）

```csharp
/// <summary>
/// 次のトラッキング設定に切り替える
/// </summary>
private void SwitchToNextTrackingSetting()
{
    if (togglableTrackingSettings == null || togglableTrackingSettings.Length == 0)
    {
        Debug.LogWarning("GameCameraManager: togglableTrackingSettings が設定されていないため、カメラ切り替えできません。");
        return;
    }

    // 次のインデックスに進む（ループ）
    currentTrackingSettingIndex = (currentTrackingSettingIndex + 1) % togglableTrackingSettings.Length;

    // 新しい設定を適用
    ApplyTrackingSetting(currentTrackingSettingIndex);
}
```

**ロジック:**
- 配列が空の場合は警告を表示して早期リターン
- インデックスを1つ進める（配列の最後まで行ったらループして0に戻る）
- ApplyTrackingSetting()を呼び出して新しい設定を適用

#### ApplyTrackingSetting()の実装（GameCameraManager.cs:130-159）

```csharp
/// <summary>
/// 指定されたインデックスのトラッキング設定を適用
/// </summary>
private void ApplyTrackingSetting(int index)
{
    if (togglableTrackingSettings == null || index < 0 || index >= togglableTrackingSettings.Length)
    {
        Debug.LogError($"GameCameraManager: 無効なトラッキング設定インデックス {index}");
        return;
    }

    TrackingSetting newSetting = togglableTrackingSettings[index];
    if (newSetting == null)
    {
        Debug.LogError($"GameCameraManager: トラッキング設定 [{index}] が null です。");
        return;
    }

    // CharacterTrackerに新しい設定を適用
    if (gameManager.CharacterTracker != null)
    {
        gameManager.CharacterTracker.SetTrackingSetting(newSetting);
        Debug.Log($"GameCameraManager: トラッキング設定を '{newSetting.name}' に切り替えました。");
    }
    else
    {
        Debug.LogError("GameCameraManager: CharacterTracker が見つかりません。");
    }
}
```

**エラーハンドリング:**
- インデックスの範囲チェック
- TrackingSettingがnullでないかチェック
- CharacterTrackerの存在確認
- 各エラー時に適切なログメッセージを出力

## データフロー

### カメラ切り替えのフロー

```
ユーザーがZキーを押す
  ↓
GameInputManager.OnZoomToggle()
  ↓
GameStateManager.RequestNextCameraView()
  ↓
OnCameraViewChangeRequested.OnNext(Unit.Default)（ReactiveProperty）
  ↓
購読者に通知
  ↓
GameCameraManager.SubscribeCameraViewChangeEvents()
  ↓
SwitchToNextTrackingSetting()
  ├→ currentTrackingSettingIndex++（ループ）
  └→ ApplyTrackingSetting(currentTrackingSettingIndex)
      ↓
      CharacterTracker.SetTrackingSetting(newSetting)
      ↓
      カメラ設定が切り替わる
```

### TrackingSettingの読み込みフロー

```
CharacterTracker.Update()
  ↓
UpdateCameraPosition()
  ├→ cameraDistance プロパティを参照
  │   └→ trackingSetting?.CameraDistance ?? 6f
  ├→ cameraHeight プロパティを参照
  │   └→ trackingSetting?.CameraHeight ?? 2f
  └→ 他のプロパティも同様に参照
      ↓
      TrackingSettingから動的に値を取得
```

## 使用方法

### 1. TrackingSettingの作成

**Unityエディタでの作成:**
1. Project ウィンドウで右クリック
2. Create → Game → Camera → Tracking Setting を選択
3. 名前を設定（例: "TrackingSetting_Near", "TrackingSetting_Far"）
4. Inspector で各パラメータを設定

**プリセット例:**

**近距離カメラ:**
- Camera Distance: 3.0
- Camera Height: 1.5
- Initial Pitch: -20.0

**通常カメラ:**
- Camera Distance: 6.0
- Camera Height: 2.0
- Initial Pitch: -40.0

**遠距離カメラ:**
- Camera Distance: 10.0
- Camera Height: 3.0
- Initial Pitch: -45.0

### 2. GameCameraManagerの設定

**Inspector設定:**
1. GameCameraManager オブジェクトを選択
2. 「Tracking Settings」セクションで「Togglable Tracking Settings」の Size を設定（例: 3）
3. 作成した TrackingSetting をドラッグ＆ドロップで配列に追加
4. 配列の順序が切り替え順序になる

**設定例:**
```
Togglable Tracking Settings:
  [0] TrackingSetting_Near   (近距離)
  [1] TrackingSetting_Normal (通常)
  [2] TrackingSetting_Far    (遠距離)
```

Zキーを押すたびに、近距離 → 通常 → 遠距離 → 近距離 とループします。

### 3. CharacterTrackerの設定

**Inspector設定:**
1. CharacterTracker コンポーネントを選択
2. 「Tracking Setting」に初期設定の TrackingSetting を設定
3. （GameCameraManagerが初期化時に上書きするため、ここでの設定は任意）

## 技術的なポイント

### 1. ScriptableObjectの利点

**再利用性:**
- 一度作成したTrackingSettingを複数のシーンやプロジェクトで再利用可能

**パラメータ調整の容易さ:**
- コードを変更せずに、Inspectorでパラメータを調整可能
- 実行時にパラメータ変更を確認可能

**デザイナーフレンドリー:**
- プログラマーでなくてもカメラパラメータを調整可能

### 2. イベント駆動型設計

**疎結合:**
- GameInputManagerとGameCameraManagerが直接依存しない
- GameStateManagerを介してイベントを伝達

**拡張性:**
- 新しいコンポーネントが簡単にカメラ切り替えイベントを購読可能
- 例: UIにカメラ切り替えボタンを追加する場合も簡単

### 3. フェールセーフ設計

**TrackingSettingがnullの場合:**
```csharp
private float cameraDistance => trackingSetting != null ? trackingSetting.CameraDistance : 6f;
```
- デフォルト値を返すことでエラーを防止

**配列が空の場合:**
```csharp
if (togglableTrackingSettings == null || togglableTrackingSettings.Length == 0)
{
    Debug.LogWarning("...");
    return;
}
```
- 警告を表示して早期リターン

### 4. ループインデックス

```csharp
currentTrackingSettingIndex = (currentTrackingSettingIndex + 1) % togglableTrackingSettings.Length;
```
- モジュロ演算子（%）を使用して、配列の最後まで行ったら0に戻る
- 無限にループ可能

## 追加実装: スムーズなカメラトランジション機能

### 概要

カメラ設定切り替え時に即座に切り替わるのではなく、スムーズにトランジションするアニメーション機能を実装しました。この機能はインスペクタでオン/オフ可能です。

### 1. CharacterTracker.cs のオーバーライドシステム

#### オーバーライドフィールドの追加（CharacterTracker.cs:22-36）

```csharp
// トランジション用のオーバーライド値
private bool useOverrideValues = false;
private float overrideCameraDistance;
private float overrideCameraHeight;
private float overrideMinPitch;
private float overrideMaxPitch;
private float overrideInitialPitch;
private bool overrideEnableCollisionAvoidance;
private float overrideCameraRadius;
private LayerMask overrideCollisionLayers;
private float overrideCollisionSmoothSpeed;
private float overridePositionSmoothSpeed;
private float overrideMinDistanceThreshold;
private bool overrideResetPitchOnReset;
private float overrideResetPitchAngle;
```

**設計意図:**
- トランジション中は補間された値を一時的に使用
- TrackingSettingを直接変更せず、オーバーライド値で動作

#### プロパティの修正（CharacterTracker.cs:38-51）

```csharp
private float cameraDistance => useOverrideValues ? overrideCameraDistance :
    (trackingSetting != null ? trackingSetting.CameraDistance : 6f);
private float cameraHeight => useOverrideValues ? overrideCameraHeight :
    (trackingSetting != null ? trackingSetting.CameraHeight : 2f);
// 他のプロパティも同様
```

**動作:**
- useOverrideValuesがtrueの場合、オーバーライド値を返す
- falseの場合、TrackingSettingから値を読み取る（通常動作）

#### トランジション用メソッドの追加

**SetTransitionValues()メソッド（CharacterTracker.cs:258-290）:**

```csharp
public void SetTransitionValues(
    float distance,
    float height,
    float minPitchValue,
    float maxPitchValue,
    float initialPitchValue,
    bool collisionAvoidance,
    float radius,
    LayerMask layers,
    float collisionSmooth,
    float positionSmooth,
    float minDistance,
    bool resetPitch,
    float resetPitchValue)
{
    useOverrideValues = true;
    overrideCameraDistance = distance;
    overrideCameraHeight = height;
    // ... 全てのオーバーライド値を設定
    currentCameraDistance = distance;
}
```

**機能:**
- トランジション中にGameCameraManagerから補間された値を受け取る
- useOverrideValuesをtrueにして、オーバーライドモードに切り替え

**ClearTransitionOverride()メソッド（CharacterTracker.cs:295-298）:**

```csharp
public void ClearTransitionOverride()
{
    useOverrideValues = false;
}
```

**機能:**
- トランジション完了時にオーバーライドモードを解除
- TrackingSettingから直接値を読み取る通常モードに戻る

### 2. GameCameraManager.cs のトランジション実装

#### トランジション設定フィールドの追加（GameCameraManager.cs:23-28, 38-42）

```csharp
[Header("Transition Settings")]
[Tooltip("設定切り替え時にスムージングを有効にする")]
[SerializeField] private bool enableTransitionAnimation = true;
[Tooltip("設定切り替えのアニメーション時間（秒）")]
[SerializeField] private float transitionDuration = 0.5f;

/// <summary>トランジション制御</summary>
private bool isTransitioning = false;
private TrackingSetting transitionFromSetting;
private TrackingSetting transitionToSetting;
private float transitionProgress = 0f;
```

**Inspector設定:**
- enableTransitionAnimation: トランジションのオン/オフ
- transitionDuration: トランジションの所要時間（デフォルト0.5秒）

#### Update()メソッドの拡張（GameCameraManager.cs:80-90）

```csharp
void Update()
{
    // 水中判定を行い、カメラ状態を更新
    CheckWaterState();

    // トランジション処理
    if (isTransitioning)
    {
        UpdateTransition();
    }
}
```

**機能:**
- 毎フレームトランジション状態をチェック
- トランジション中の場合、UpdateTransition()を呼び出し

#### ApplyTrackingSetting()の修正（GameCameraManager.cs:159-203）

```csharp
private void ApplyTrackingSetting(int index)
{
    // ... エラーチェック ...

    // トランジションアニメーションが有効な場合
    if (enableTransitionAnimation && transitionDuration > 0f)
    {
        TrackingSetting currentSetting = togglableTrackingSettings[currentTrackingSettingIndex];
        if (currentSetting == null)
        {
            // 現在の設定がnullの場合は即座に切り替え
            gameManager.CharacterTracker.SetTrackingSetting(newSetting);
            currentTrackingSettingIndex = index;
            return;
        }

        // トランジション開始
        StartTransition(currentSetting, newSetting);
        currentTrackingSettingIndex = index;
    }
    else
    {
        // トランジションなしで即座に切り替え
        gameManager.CharacterTracker.SetTrackingSetting(newSetting);
        currentTrackingSettingIndex = index;
    }
}
```

**ロジック:**
- enableTransitionAnimationがtrueの場合、トランジションを開始
- falseの場合、即座に切り替え（従来の動作）

#### StartTransition()メソッド（GameCameraManager.cs:208-214）

```csharp
private void StartTransition(TrackingSetting fromSetting, TrackingSetting toSetting)
{
    isTransitioning = true;
    transitionFromSetting = fromSetting;
    transitionToSetting = toSetting;
    transitionProgress = 0f;
}
```

**機能:**
- トランジション状態フラグをtrueに設定
- 開始設定と終了設定を保存
- 進行度を0にリセット

#### UpdateTransition()メソッド（GameCameraManager.cs:219-267）

```csharp
private void UpdateTransition()
{
    if (!isTransitioning) return;

    // 進行度を更新
    transitionProgress += Time.deltaTime / transitionDuration;

    if (transitionProgress >= 1f)
    {
        // トランジション完了
        CompleteTransition();
        return;
    }

    // 数値パラメータを線形補間
    float lerpedDistance = Mathf.Lerp(
        transitionFromSetting.CameraDistance,
        transitionToSetting.CameraDistance,
        transitionProgress
    );
    float lerpedHeight = Mathf.Lerp(
        transitionFromSetting.CameraHeight,
        transitionToSetting.CameraHeight,
        transitionProgress
    );
    // ... 他の数値パラメータも同様に補間 ...

    // bool値とLayerMaskは補間せず、中間点で切り替え
    bool useToSettingBools = transitionProgress >= 0.5f;
    bool lerpedEnableCollisionAvoidance = useToSettingBools ?
        transitionToSetting.EnableCollisionAvoidance :
        transitionFromSetting.EnableCollisionAvoidance;
    LayerMask lerpedCollisionLayers = useToSettingBools ?
        transitionToSetting.CollisionLayers :
        transitionFromSetting.CollisionLayers;

    // CharacterTrackerに補間された値を適用
    gameManager.CharacterTracker.SetTransitionValues(
        lerpedDistance,
        lerpedHeight,
        lerpedMinPitch,
        lerpedMaxPitch,
        lerpedInitialPitch,
        lerpedEnableCollisionAvoidance,
        lerpedCameraRadius,
        lerpedCollisionLayers,
        lerpedCollisionSmoothSpeed,
        lerpedPositionSmoothSpeed,
        lerpedMinDistanceThreshold,
        lerpedResetPitchOnReset,
        lerpedResetPitchAngle
    );
}
```

**補間ロジック:**

1. **数値パラメータ（float）**:
   - Mathf.Lerpで線形補間
   - cameraDistance, cameraHeight, minPitch, maxPitch, initialPitch, cameraRadius, collisionSmoothSpeed, positionSmoothSpeed, minDistanceThreshold, resetPitchAngle

2. **bool値とLayerMask**:
   - 補間できないため、進行度50%で切り替え
   - enableCollisionAvoidance, collisionLayers, resetPitchOnReset

3. **進行度更新**:
   - `transitionProgress += Time.deltaTime / transitionDuration`
   - デルタタイムを使用してフレームレート非依存

#### CompleteTransition()メソッド（GameCameraManager.cs:272-282）

```csharp
private void CompleteTransition()
{
    isTransitioning = false;
    transitionProgress = 1f;

    // 最終的な設定を適用
    if (gameManager.CharacterTracker != null && transitionToSetting != null)
    {
        gameManager.CharacterTracker.SetTrackingSetting(transitionToSetting);
    }
}
```

**機能:**
- トランジション状態フラグをfalseに設定
- オーバーライドモードを解除し、目標のTrackingSettingを正式に適用
- これにより、useOverrideValuesがfalseになり通常モードに戻る

#### SwitchToNextTrackingSetting()の修正（GameCameraManager.cs:133-153）

```csharp
private void SwitchToNextTrackingSetting()
{
    // ... エラーチェック ...

    // トランジション中の場合は、現在のトランジションをキャンセルして新しいトランジションを開始
    if (isTransitioning && enableTransitionAnimation)
    {
        // 現在のトランジションを完了させる
        CompleteTransition();
    }

    // 次のインデックスに進む（ループ）
    int nextIndex = (currentTrackingSettingIndex + 1) % togglableTrackingSettings.Length;

    // 新しい設定を適用
    ApplyTrackingSetting(nextIndex);
}
```

**ロジック:**
- トランジション中にZキーを連打された場合、現在のトランジションを即座に完了
- その後、新しいトランジションを開始

### トランジションフローの全体像

```
ユーザーがZキーを押す
  ↓
SwitchToNextTrackingSetting()
  ↓
トランジション中か?
  ├─ Yes → CompleteTransition()（現在のトランジションを即座に完了）
  └─ No → 次へ
  ↓
ApplyTrackingSetting(nextIndex)
  ↓
enableTransitionAnimationがtrue?
  ├─ Yes → StartTransition(currentSetting, newSetting)
  │         ├─ isTransitioning = true
  │         ├─ transitionProgress = 0f
  │         └─ Update()で毎フレームUpdateTransition()を呼び出し
  │             ├─ transitionProgress += Time.deltaTime / transitionDuration
  │             ├─ 各パラメータをMathf.Lerpで補間
  │             ├─ CharacterTracker.SetTransitionValues()で補間値を適用
  │             └─ transitionProgress >= 1f → CompleteTransition()
  │                 └─ CharacterTracker.SetTrackingSetting(toSetting)
  │                     └─ useOverrideValues = false（通常モードに戻る）
  └─ No → SetTrackingSetting(newSetting)（即座に切り替え）
```

### 設定方法

**Inspector設定:**

1. GameCameraManagerを選択
2. 「Transition Settings」セクション:
   - **Enable Transition Animation**: トランジションを有効にする（チェック推奨）
   - **Transition Duration**: トランジションの所要時間（秒）
     - デフォルト: 0.5秒
     - 推奨範囲: 0.3～1.0秒

**動作確認:**

1. enableTransitionAnimation = true, transitionDuration = 0.5f で設定
2. ゲームを開始
3. Zキーを押す
4. **期待結果**: カメラが0.5秒かけてスムーズに切り替わる

5. enableTransitionAnimation = false で設定
6. Zキーを押す
7. **期待結果**: カメラが即座に切り替わる（従来の動作）

### 技術的なポイント

#### 1. オーバーライドパターンの利点

**TrackingSettingを保護:**
- ScriptableObjectを直接変更しない
- 複数のインスタンスで同じTrackingSettingを共有可能

**一時的な値の適用:**
- トランジション中のみオーバーライド値を使用
- 完了後は正式なTrackingSettingに戻る

#### 2. 線形補間（Mathf.Lerp）

```csharp
float lerpedDistance = Mathf.Lerp(start, end, progress);
```

**動作:**
- progress = 0.0 → startの値
- progress = 0.5 → startとendの中間値
- progress = 1.0 → endの値

**メリット:**
- フレームレート非依存（Time.deltaTimeを使用）
- 自然なイージング効果

#### 3. bool/LayerMaskの切り替えロジック

**なぜ50%で切り替えるか:**
- bool値とLayerMaskは補間できない
- 0.49で突然切り替わるよりも、中間点での切り替えが自然

```csharp
bool useToSettingBools = transitionProgress >= 0.5f;
```

#### 4. トランジション連打対策

```csharp
if (isTransitioning && enableTransitionAnimation)
{
    CompleteTransition();
}
```

**理由:**
- Zキー連打時に複数のトランジションが重なるのを防止
- 現在のトランジションを即座に完了させてから次のトランジションを開始

## 今後の拡張案

### 2. カメラ切り替えUI表示

Zキーを押したときに、現在のカメラモードを画面に表示することで、ユーザビリティを向上できます。

```csharp
// GameUIManagerに追加
public void ShowCameraModeSwitchUI(string modeName)
{
    // 画面に "カメラモード: 近距離" などを表示
    // 2秒後に自動的にフェードアウト
}
```

### 3. カメラモードの制限

特定の状況（例: 狭い場所、イベント中）では遠距離カメラを無効化するなどの制限を追加できます。

```csharp
// GameCameraManagerに追加
private bool[] enabledTrackingSettings;

public void SetTrackingSettingEnabled(int index, bool enabled)
{
    if (index >= 0 && index < enabledTrackingSettings.Length)
    {
        enabledTrackingSettings[index] = enabled;
    }
}

private void SwitchToNextTrackingSetting()
{
    // 有効な設定のみをスキップ
    do
    {
        currentTrackingSettingIndex = (currentTrackingSettingIndex + 1) % togglableTrackingSettings.Length;
    }
    while (!enabledTrackingSettings[currentTrackingSettingIndex]);
}
```

### 4. ショートカットキーのカスタマイズ

現在はZキーのみですが、設定でカスタマイズ可能にすることも検討できます。

### 5. カメラプリセットのホットリロード

実行中にTrackingSettingの値を変更すると即座に反映されるため、ゲームプレイ中にパラメータをチューニング可能です。

## テストケース

### ケース1: 通常のカメラ切り替え

1. TrackingSettingを3つ作成して配列に設定
2. ゲームを開始
3. Zキーを3回押す
4. **期待結果**: 設定が順番に切り替わる（近 → 通常 → 遠 → 近）

### ケース2: TrackingSetting配列が空の場合

1. togglableTrackingSettingsを空にする
2. ゲームを開始
3. Zキーを押す
4. **期待結果**: 警告ログが表示され、何も起こらない

### ケース3: TrackingSettingがnullの場合

1. CharacterTrackerのtrackingSettingをnullにする
2. ゲームを開始
3. **期待結果**: デフォルト値が使用され、カメラが正常に動作

### ケース4: 配列の最後から最初へのループ

1. TrackingSettingを2つ設定
2. Zキーを3回押す
3. **期待結果**: 設定0 → 設定1 → 設定0 とループ

## 利点

### 1. ゲームプレイの向上

- プレイヤーが状況に応じてカメラ距離を変更可能
- 戦闘時は近距離、探索時は遠距離など、柔軟な視点変更

### 2. 開発効率の向上

- ScriptableObjectでカメラプリセットを管理することで、調整が容易
- コードを変更せずにパラメータを調整可能

### 3. 拡張性

- 新しいカメラモードを簡単に追加可能
- 他のコンポーネントがカメラ切り替えイベントを購読可能

### 4. 保守性

- 設定とロジックが分離されているため、コードが読みやすい
- イベント駆動型設計により、コンポーネント間の依存関係が明確

## 関連ファイル

- Assets/Scripts/Camera/TrackingSetting.cs (新規作成: ScriptableObject)
- Assets/Scripts/Camera/CharacterTracker.cs (修正: TrackingSettingを使用するようリファクタリング)
- Assets/Scripts/GameManager/GameStateManager.cs (修正: カメラ切り替えイベント追加)
- Assets/Scripts/GameManager/GameInputManager.cs (修正: OnZoomToggle実装)
- Assets/Scripts/Camera/GameCameraManager.cs (修正: 切り替え機能実装)

## 備考

### InputSystemのZoomToggleアクション

OnZoomToggle()メソッドは、InputSystem_Actions の IPlayerActions インターフェースで定義されている必要があります。もし存在しない場合は、Input Actionアセットに "ZoomToggle" アクションを追加してください。

### TrackingSettingのパラメータ設計

TrackingSettingには全てのカメラパラメータが含まれていますが、実際には以下のパラメータのみを変更するケースが多いでしょう：
- cameraDistance: カメラ距離
- cameraHeight: カメラ高さ
- initialPitch: 初期ピッチ角度

他のパラメータ（障害物回避、スムージングなど）は通常、全てのプリセットで同じ値を使用します。

### ScriptableObjectの保存場所

TrackingSettingは以下の場所に保存することを推奨します：
```
Assets/Settings/Camera/
  ├─ TrackingSetting_Near.asset
  ├─ TrackingSetting_Normal.asset
  └─ TrackingSetting_Far.asset
```

### デバッグログ

ApplyTrackingSetting()では、切り替え時にログを出力しています：
```csharp
Debug.Log($"GameCameraManager: トラッキング設定を '{newSetting.name}' に切り替えました。");
```

リリースビルドでは、このログを無効化することを検討してください。
