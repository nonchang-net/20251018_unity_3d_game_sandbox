# ワークログ: VRM読み込み時のAnimatorControllerとPhysics Material設定の一元化

作成日時: 2025-10-28 18:23

## 変更した内容の概要

- GameCharacterManagerにAnimatorControllerとPhysics Materialの公開プロパティを追加しました
- VRMUtility.csにPhysics Material引数を追加し、CapsuleColliderに自動適用するように実装しました
- VrmLoadManagerとPlayableCharacterRepositoryの重複していたvrmAnimatorController参照を削除し、GameCharacterManager経由で取得するように統一しました

## なぜそのように変更しようと考えたか

- VRM読み込み時に動的生成されるキャラクターにもPhysics Material（摩擦ゼロ設定）を適用する必要がありました
- VrmLoadManagerとPlayableCharacterRepositoryで重複してvrmAnimatorControllerを保持していたため、管理が煩雑でした
- GameCharacterManagerを設定の一元管理場所とすることで、保守性が向上し、設定漏れを防げます

## 実装詳細

### 1. GameCharacterManager.cs の変更

#### 公開プロパティの追加（GameCharacterManager.cs:59-67）

**追加したプロパティ:**
```csharp
/// <summary>
/// 操作キャラクター用AnimatorControllerを取得
/// </summary>
public RuntimeAnimatorController CharacterAnimatorController => characterAnimatorController;

/// <summary>
/// 操作キャラクター用Physics Materialを取得
/// </summary>
public PhysicMaterial CharacterPhysicsMaterial => characterPhysicsMaterial;
```

**設計意図:**
- 既存のSerializeField（characterAnimatorController, characterPhysicsMaterial）を外部から参照可能に
- 読み取り専用プロパティとして実装（getterのみ）
- VrmLoadManagerとPlayableCharacterRepositoryから参照される

**利点:**
- 設定の一元管理
- InspectorでGameCharacterManagerに設定するだけで、全てのVRM読み込み処理に適用される
- 重複を排除し、保守性向上

### 2. VRMUtility.cs の変更

#### LoadAndSetupVrmFromPathの引数追加（VRMUtility.cs:27-33）

**修正前:**
```csharp
public static IEnumerator LoadAndSetupVrmFromPath(
    string vrmPath,
    Vector3 spawnPosition,
    RuntimeAnimatorController animatorController = null,
    System.Action<GameObject> onComplete = null,
    System.Action<string> onError = null)
```

**修正後:**
```csharp
public static IEnumerator LoadAndSetupVrmFromPath(
    string vrmPath,
    Vector3 spawnPosition,
    RuntimeAnimatorController animatorController = null,
    PhysicMaterial physicsMaterial = null,
    System.Action<GameObject> onComplete = null,
    System.Action<string> onError = null)
```

**変更点:**
- `PhysicMaterial physicsMaterial = null`引数を追加
- デフォルト引数はnull（後方互換性を維持）

#### LoadAndSetupVrmFromBytesの引数追加（VRMUtility.cs:95-102）

同様にPhysicMaterial引数を追加。

#### SetupVrmCharacterの引数追加（VRMUtility.cs:277-281）

**修正前:**
```csharp
public static void SetupVrmCharacter(
    GameObject vrmCharacter,
    Vector3 spawnPosition,
    RuntimeAnimatorController animatorController = null)
```

**修正後:**
```csharp
public static void SetupVrmCharacter(
    GameObject vrmCharacter,
    Vector3 spawnPosition,
    RuntimeAnimatorController animatorController = null,
    PhysicMaterial physicsMaterial = null)
```

#### SetupCapsuleColliderの修正（VRMUtility.cs:399-466）

**引数追加:**
```csharp
private static void SetupCapsuleCollider(GameObject vrmCharacter, PhysicMaterial physicsMaterial = null)
```

**Physics Material適用処理の追加（VRMUtility.cs:453-465）:**
```csharp
// Physics Materialを設定
if (physicsMaterial != null)
{
    capsule.material = physicsMaterial;
    if (EnableVerboseLog)
    {
        Debug.Log($"VRMUtility: Physics Material '{physicsMaterial.name}' をCapsuleColliderに適用しました。");
    }
}
else
{
    Debug.LogError("VRMUtility: Physics Materialが設定されていません。CapsuleColliderに摩擦が残るため、引っかかる可能性があります。");
}
```

**動作:**
1. CapsuleColliderのサイズをボーン情報から自動計算（既存処理）
2. Physics Materialが指定されている場合、`capsule.material`に設定
3. Physics Materialがnullの場合、エラーログを出力（設定漏れを防止）

**重要性:**
- エラーログにより、設定漏れが即座に検出可能
- 動的生成されるVRMキャラクターにも確実にPhysics Materialが適用される

### 3. VrmLoadManager.cs の変更

#### vrmAnimatorControllerフィールドの削除（VRMLoadManager.cs:23-25）

**削除したコード:**
```csharp
[Header("VRM設定")]
[Tooltip("VRMキャラクターに適用するアニメーションコントローラー")]
[SerializeField] private RuntimeAnimatorController vrmAnimatorController;
```

**理由:**
- GameCharacterManagerに統一するため
- 重複を排除

#### VRMUtility呼び出しの修正（3箇所）

**修正箇所:**
1. LoadVrmFromFileDialog() - 143行目付近
2. LoadVrmFromUrl() - 251行目付近
3. LoadVrmFromPathCoroutine() - 336行目付近

**共通の修正パターン:**
```csharp
// GameCharacterManagerから設定を取得
RuntimeAnimatorController animatorController = gameManager?.CharacterManager?.CharacterAnimatorController;
PhysicMaterial physicsMaterial = gameManager?.CharacterManager?.CharacterPhysicsMaterial;

if (animatorController == null)
{
    Debug.LogError("VRMLoadManager: GameCharacterManagerのCharacterAnimatorControllerが設定されていません。");
}

if (physicsMaterial == null)
{
    Debug.LogError("VRMLoadManager: GameCharacterManagerのCharacterPhysicsMaterialが設定されていません。");
}

// VRMを読み込んでセットアップ
yield return VRMUtility.LoadAndSetupVrmFromPath(
    vrmPath,
    spawnPosition,
    animatorController,
    physicsMaterial,  // 追加
    onComplete: (vrmCharacter) => { ... },
    onError: (errorMessage) => { ... }
);
```

**動作フロー:**
1. GameManager経由でGameCharacterManagerを取得
2. CharacterAnimatorControllerとCharacterPhysicsMaterialプロパティから値を取得
3. nullチェックを行い、設定されていない場合はエラーログ出力
4. VRMUtility.LoadAndSetupVrmFromPathに両方の引数を渡す

**エラーハンドリング:**
- 設定されていない場合でも処理は継続（nullのまま渡す）
- VRMUtility側でもnullチェックとエラーログが出力される（二重チェック）

### 4. PlayableCharacterRepository.cs の変更

#### vrmAnimatorControllerフィールドの削除（PlayableCharacterRepository.cs:29-31）

**削除したコード:**
```csharp
[Header("VRM設定")]
[Tooltip("VRMキャラクターに適用するアニメーションコントローラー")]
[SerializeField] private RuntimeAnimatorController vrmAnimatorController;
```

#### VRMUtility呼び出しの修正（PlayableCharacterRepository.cs:113-158）

VrmLoadManagerと同様の修正パターン:
- GameCharacterManagerから設定を取得
- nullチェック
- VRMUtility.LoadAndSetupVrmFromPathに両方の引数を渡す

## データフロー

### VRM読み込み時の設定適用フロー

```
Unity Inspector
  ↓
GameCharacterManager
  ├─ characterAnimatorController [SerializeField]
  └─ characterPhysicsMaterial [SerializeField]
  ↓
公開プロパティ
  ├─ CharacterAnimatorController (getter)
  └─ CharacterPhysicsMaterial (getter)
  ↓
VrmLoadManager / PlayableCharacterRepository
  ├─ gameManager.CharacterManager.CharacterAnimatorController
  └─ gameManager.CharacterManager.CharacterPhysicsMaterial
  ↓
VRMUtility.LoadAndSetupVrmFromPath()
  ↓
VRMUtility.SetupVrmCharacter()
  ↓
VRMUtility.SetupCapsuleCollider()
  ↓
CapsuleCollider.material = physicsMaterial
```

### 設定確認フロー（エラー検出）

```
VrmLoadManager / PlayableCharacterRepository
  ↓
animatorController == null ?
  ├─ Yes → Debug.LogError() (1回目)
  └─ No → 次へ
  ↓
physicsMaterial == null ?
  ├─ Yes → Debug.LogError() (1回目)
  └─ No → 次へ
  ↓
VRMUtility.SetupCapsuleCollider()
  ↓
physicsMaterial == null ?
  ├─ Yes → Debug.LogError() (2回目) ← 二重チェック
  └─ No → capsule.material = physicsMaterial
```

## 技術的なポイント

### 1. Null条件演算子の活用

```csharp
RuntimeAnimatorController animatorController = gameManager?.CharacterManager?.CharacterAnimatorController;
PhysicMaterial physicsMaterial = gameManager?.CharacterManager?.CharacterPhysicsMaterial;
```

**利点:**
- NullReferenceExceptionを防止
- gameManagerやCharacterManagerがnullの場合、変数もnullになる
- 安全なチェーン呼び出し

### 2. 読み取り専用プロパティの使用

```csharp
public RuntimeAnimatorController CharacterAnimatorController => characterAnimatorController;
public PhysicMaterial CharacterPhysicsMaterial => characterPhysicsMaterial;
```

**利点:**
- 外部から値を変更されない（カプセル化）
- 式形式のプロパティで簡潔
- SerializeFieldの値を直接返すだけ

### 3. デフォルト引数による後方互換性

```csharp
public static IEnumerator LoadAndSetupVrmFromPath(
    string vrmPath,
    Vector3 spawnPosition,
    RuntimeAnimatorController animatorController = null,
    PhysicMaterial physicsMaterial = null,  // デフォルト引数
    System.Action<GameObject> onComplete = null,
    System.Action<string> onError = null)
```

**利点:**
- 既存のコードを破壊しない
- physicsMaterial引数を省略可能（nullになる）
- 段階的な移行が可能

### 4. エラーログによる設定漏れ検出

**VrmLoadManager / PlayableCharacterRepository:**
```csharp
if (animatorController == null)
{
    Debug.LogError("VRMLoadManager: GameCharacterManagerのCharacterAnimatorControllerが設定されていません。");
}

if (physicsMaterial == null)
{
    Debug.LogError("VRMLoadManager: GameCharacterManagerのCharacterPhysicsMaterialが設定されていません。");
}
```

**VRMUtility.SetupCapsuleCollider:**
```csharp
else
{
    Debug.LogError("VRMUtility: Physics Materialが設定されていません。CapsuleColliderに摩擦が残るため、引っかかる可能性があります。");
}
```

**利点:**
- 二重チェック体制
- 設定漏れが即座に検出される
- エラーメッセージが具体的で、修正方法が明確

## 使用方法

### Unity Editorでの設定手順

1. **Physics Materialの作成**
   - Project → 右クリック → Create → Physics Material
   - 名前: "FrictionlessCharacter"
   - Dynamic Friction: 0
   - Static Friction: 0
   - Bounciness: 0

2. **AnimatorControllerの準備**
   - 既存のキャラクター用AnimatorControllerを用意
   - 例: "PlayerAnimatorController"

3. **GameCharacterManagerに設定**
   - Hierarchy → GameCharacterManager を選択
   - Inspector → "キャラクター生成時に必要なデータ"
   - Character Animator Controller: PlayerAnimatorController をドラッグ＆ドロップ
   - Character Physics Material: FrictionlessCharacter をドラッグ＆ドロップ

4. **VrmLoadManagerとPlayableCharacterRepositoryの設定削除**
   - Inspector から "VRM設定" セクションが削除されていることを確認
   - （もし残っていれば、手動で削除）

5. **動作確認**
   - VRMファイルを読み込む
   - Consoleにエラーログが出ていないか確認
   - 生成されたVRMキャラクターのCapsuleColliderを確認
   - Material: FrictionlessCharacter が設定されているか確認

## テストケース

### ケース1: 正常動作（全て設定済み）

**前提条件:**
- GameCharacterManager.CharacterAnimatorController が設定済み
- GameCharacterManager.CharacterPhysicsMaterial が設定済み

**手順:**
1. VRMファイルを読み込む

**期待結果:**
- エラーログなし
- VRMキャラクターが正常に生成される
- CapsuleColliderにPhysics Materialが適用されている
- 横から衝突しても引っかからず滑り落ちる

### ケース2: AnimatorControllerが未設定

**前提条件:**
- GameCharacterManager.CharacterAnimatorController が未設定（null）
- GameCharacterManager.CharacterPhysicsMaterial が設定済み

**手順:**
1. VRMファイルを読み込む

**期待結果:**
- エラーログ: "GameCharacterManagerのCharacterAnimatorControllerが設定されていません。"
- VRMキャラクターは生成されるが、アニメーションが動作しない
- Physics Materialは正常に適用される

### ケース3: Physics Materialが未設定

**前提条件:**
- GameCharacterManager.CharacterAnimatorController が設定済み
- GameCharacterManager.CharacterPhysicsMaterial が未設定（null）

**手順:**
1. VRMファイルを読み込む

**期待結果:**
- エラーログ: "GameCharacterManagerのCharacterPhysicsMaterialが設定されていません。"
- エラーログ: "VRMUtility: Physics Materialが設定されていません。CapsuleColliderに摩擦が残るため、引っかかる可能性があります。"
- VRMキャラクターは生成されるが、CapsuleColliderにPhysics Materialが適用されない
- 横から衝突すると引っかかる可能性がある

### ケース4: 両方とも未設定

**前提条件:**
- GameCharacterManager.CharacterAnimatorController が未設定（null）
- GameCharacterManager.CharacterPhysicsMaterial が未設定（null）

**手順:**
1. VRMファイルを読み込む

**期待結果:**
- エラーログ: "GameCharacterManagerのCharacterAnimatorControllerが設定されていません。"
- エラーログ: "GameCharacterManagerのCharacterPhysicsMaterialが設定されていません。"
- エラーログ: "VRMUtility: Physics Materialが設定されていません。CapsuleColliderに摩擦が残るため、引っかかる可能性があります。"
- VRMキャラクターは生成されるが、アニメーションとPhysics Materialが未適用

## 利点

### 1. 設定の一元管理

**変更前:**
- VrmLoadManager.vrmAnimatorController
- PlayableCharacterRepository.vrmAnimatorController
- Physics Materialは未設定

**変更後:**
- GameCharacterManager.characterAnimatorController
- GameCharacterManager.characterPhysicsMaterial

**メリット:**
- 設定場所が1箇所のみ
- 重複を排除
- 設定漏れを防止

### 2. 保守性の向上

- AnimatorControllerやPhysics Materialを変更する場合、GameCharacterManagerのInspectorで1箇所変更するだけ
- VrmLoadManagerやPlayableCharacterRepositoryのコードを変更する必要がない

### 3. エラー検出の強化

- 設定漏れが即座に検出される
- エラーメッセージが具体的で、修正方法が明確
- 二重チェック体制で確実

### 4. 動的生成キャラクターへの対応

- VRMファイルから動的に生成されるキャラクターにも自動的にPhysics Materialが適用される
- 手作業で配置したキャラクターと同じ物理挙動

## 注意点

### 1. GameCharacterManagerの設定必須

**問題:**
- GameCharacterManager.CharacterAnimatorControllerが未設定の場合、VRMキャラクターはアニメーションしない
- GameCharacterManager.CharacterPhysicsMaterialが未設定の場合、引っかかり問題が発生する

**対策:**
- エラーログが出力される
- 起動時のチェックリストに追加

### 2. 既存のVrmLoadManagerとPlayableCharacterRepositoryの設定

**問題:**
- 既存のプロジェクトでは、Inspector に "VRM設定" セクションが残っている可能性

**対策:**
- Inspectorから削除されていることを確認
- もし残っていれば、手動で削除（データ損失なし）

### 3. Null条件演算子のチェーン

**問題:**
- gameManager?.CharacterManager?.CharacterAnimatorController が長い

**対策:**
- 可読性のため、一時変数に代入
- null チェックで安全性を確保

## 関連ファイル

- Assets/Scripts/GameManager/GameCharacterManager.cs (修正: 公開プロパティ追加)
- Assets/Scripts/Utilities/VRMUtility.cs (修正: Physics Material引数追加、CapsuleCollider設定)
- Assets/Scripts/Utilities/VRMLoadManager.cs (修正: vrmAnimatorController削除、GameCharacterManager経由で取得)
- Assets/Scripts/Character/PlayableCharacterRepository.cs (修正: vrmAnimatorController削除、GameCharacterManager経由で取得)

## 今後の拡張案

### 1. 複数のPhysics Materialプリセット

地形タイプ別にPhysics Materialを切り替え:

```csharp
[Header("キャラクター生成時に必要なデータ")]
[SerializeField] private PhysicsMaterial characterPhysicsMaterial; // 通常
[SerializeField] private PhysicsMaterial characterIcePhysicsMaterial; // 氷上
[SerializeField] private PhysicsMaterial characterMudPhysicsMaterial; // 泥地

public PhysicMaterial GetPhysicsMaterial(TerrainType terrainType)
{
    return terrainType switch
    {
        TerrainType.Normal => characterPhysicsMaterial,
        TerrainType.Ice => characterIcePhysicsMaterial,
        TerrainType.Mud => characterMudPhysicsMaterial,
        _ => characterPhysicsMaterial
    };
}
```

### 2. AnimatorControllerのバリエーション

キャラクタータイプ別にAnimatorControllerを切り替え:

```csharp
[Header("キャラクター生成時に必要なデータ")]
[SerializeField] private RuntimeAnimatorController humanoidAnimatorController;
[SerializeField] private RuntimeAnimatorController quadrupedAnimatorController;

public RuntimeAnimatorController GetAnimatorController(CharacterType characterType)
{
    return characterType switch
    {
        CharacterType.Humanoid => humanoidAnimatorController,
        CharacterType.Quadruped => quadrupedAnimatorController,
        _ => humanoidAnimatorController
    };
}
```

### 3. ScriptableObjectによる設定管理

複数の設定をまとめて管理:

```csharp
[CreateAssetMenu(fileName = "CharacterSetupConfig", menuName = "Game/Character/Setup Config")]
public class CharacterSetupConfig : ScriptableObject
{
    public RuntimeAnimatorController animatorController;
    public PhysicsMaterial physicsMaterial;
    public float walkSpeed;
    public float runSpeed;
    // ... 他の設定
}

// GameCharacterManager
[SerializeField] private CharacterSetupConfig setupConfig;
public CharacterSetupConfig SetupConfig => setupConfig;
```

## まとめ

今回の変更により、以下が実現されました：

1. **GameCharacterManagerへの設定一元化**
   - AnimatorControllerとPhysics Materialを1箇所で管理
   - VrmLoadManagerとPlayableCharacterRepositoryの重複を排除

2. **動的生成キャラクターへのPhysics Material自動適用**
   - VRM読み込み時にCapsuleColliderに自動設定
   - 引っかかり問題を防止

3. **エラー検出の強化**
   - 設定漏れが即座に検出される
   - 二重チェック体制で確実

4. **保守性の向上**
   - 設定変更が1箇所で完結
   - コードの重複を排除

これにより、VRMキャラクターの読み込みと設定が統一され、保守性が大幅に向上しました。
