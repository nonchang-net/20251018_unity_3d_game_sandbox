# ワークログ: Rigidbody Interpolation対応のリスポーンとワープ処理の実装

作成日時: 2025-10-28 18:40

## 変更した内容の概要

- GameCharacterManagerに物理状態をリセットする`ResetPhysicsState()`メソッドを追加しました
- GameCharacterManagerに安全なテレポート機能`TeleportTo()`メソッドを追加しました
- GameManagerのリスポーン処理を`TeleportTo()`を使用するように修正しました
- DebugCommandsのワープ処理を`TeleportTo()`を使用するように修正しました
- コメントアウトされていた`ContinuousDynamic`と`Interpolate`設定を有効化しました

## なぜそのように変更しようと考えたか

- `CollisionDetectionMode.ContinuousDynamic`と`RigidbodyInterpolation.Interpolate`を有効化すると、リスポーンやワープ時に座標が正しくリセットされない問題が発生しました
- Rigidbodyの内部状態（velocity、angularVelocity、Interpolationの前フレーム位置）がリセットされていないことが原因でした
- これらの設定は物理挙動の精度と滑らかさを向上させる有益な設定なので、物理状態を適切にリセットする仕組みを実装して有効化しました

## 問題の原因

### Rigidbody Interpolationの仕組み

`RigidbodyInterpolation.Interpolate`は、前フレームと現在フレームのRigidbody位置を補間して、滑らかな動きを実現します：

```
描画フレーム = Lerp(前フレームの位置, 現在フレームの位置, 補間率)
```

### リスポーン/ワープ時の問題

**従来の実装（問題あり）:**
```csharp
activeCharacter.transform.position = newPosition;
```

**問題点:**
1. `transform.position`を変更しても、Rigidbodyの内部状態はリセットされない
2. `linearVelocity`（速度）が残っている
3. `angularVelocity`（角速度）が残っている
4. Interpolationの「前フレーム位置」が死亡時の位置のまま

**結果:**
```
リスポーン直後の描画位置 = Lerp(死亡時の位置, リスポーン位置, 補間率)
→ 死亡時の位置に引き戻される！
```

## 実装詳細

### 1. GameCharacterManager.cs の変更

#### ResetPhysicsState()メソッドの追加（GameCharacterManager.cs:851-871）

```csharp
/// <summary>
/// Rigidbodyの物理状態をリセット（速度、角速度をゼロにする）
/// リスポーンやワープ時に使用
/// </summary>
public void ResetPhysicsState()
{
    if (implementationType == CharacterImplementationType.RigidbodyAndCollider && characterRigidbody != null)
    {
        // 速度をゼロにする
        characterRigidbody.linearVelocity = Vector3.zero;
        characterRigidbody.angularVelocity = Vector3.zero;

        // 物理エンジンの状態を即座に同期（Interpolation対策）
        Physics.SyncTransforms();

        if (EnableVerboseLog)
        {
            Debug.Log("GameCharacterManager: Rigidbodyの物理状態をリセットしました。");
        }
    }
}
```

**機能:**
1. **linearVelocityをゼロにする**: 移動速度をリセット
2. **angularVelocityをゼロにする**: 回転速度をリセット
3. **Physics.SyncTransforms()を呼び出し**: 物理エンジンの内部状態を即座に同期

**Physics.SyncTransforms()の役割:**
- 通常、物理エンジンは次のFixedUpdate時に状態を同期
- `Physics.SyncTransforms()`を呼び出すと、即座に同期される
- Interpolationの「前フレーム位置」もリセットされる

#### TeleportTo()メソッドの追加（GameCharacterManager.cs:873-918）

```csharp
/// <summary>
/// キャラクターを指定位置にテレポート
/// CharacterControllerとRigidbody両方に対応し、物理状態も適切にリセット
/// </summary>
/// <param name="position">テレポート先の位置</param>
/// <param name="rotation">テレポート先の回転</param>
public void TeleportTo(Vector3 position, Quaternion rotation)
{
    if (targetCharacter == null)
    {
        Debug.LogWarning("GameCharacterManager: targetCharacterがnullです。テレポートできません。");
        return;
    }

    if (implementationType == CharacterImplementationType.CharacterController && characterController != null)
    {
        // CharacterControllerの場合は無効化してから移動
        characterController.enabled = false;
        targetCharacter.transform.position = position;
        targetCharacter.transform.rotation = rotation;
        characterController.enabled = true;

        if (EnableVerboseLog)
        {
            Debug.Log($"GameCharacterManager: CharacterControllerをテレポートしました。位置: {position}");
        }
    }
    else if (implementationType == CharacterImplementationType.RigidbodyAndCollider && characterRigidbody != null)
    {
        // Rigidbodyの位置を直接設定（transform.positionではなくRigidbody.positionを使用）
        characterRigidbody.position = position;
        characterRigidbody.rotation = rotation;

        // 物理状態をリセット
        ResetPhysicsState();

        if (EnableVerboseLog)
        {
            Debug.Log($"GameCharacterManager: Rigidbodyをテレポートしました。位置: {position}");
        }
    }
    else
    {
        Debug.LogWarning("GameCharacterManager: 実装タイプが不明、またはコンポーネントがnullです。");
    }
}
```

**CharacterController実装の場合:**
1. `characterController.enabled = false`で一時的に無効化
2. `transform.position`と`transform.rotation`を設定
3. `characterController.enabled = true`で再有効化

**Rigidbody実装の場合:**
1. **`rigidbody.position`を使用**（重要！`transform.position`ではない）
2. **`rigidbody.rotation`を使用**
3. `ResetPhysicsState()`で物理状態をリセット

**なぜRigidbody.positionを使うのか:**
- `transform.position`を変更すると、物理エンジンが次のFixedUpdateまで認識しない
- `Rigidbody.position`を変更すると、物理エンジンが即座に認識する
- Interpolationも正しく動作する

#### ContinuousDynamicとInterpolateの有効化（GameCharacterManager.cs:233-235）

**修正前:**
```csharp
characterRigidbody.freezeRotation = true; // 回転を凍結
// characterRigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic; // 衝突検出精度を向上
// characterRigidbody.interpolation = RigidbodyInterpolation.Interpolate; // 移動を滑らかに
```

**修正後:**
```csharp
characterRigidbody.freezeRotation = true; // 回転を凍結
characterRigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic; // 衝突検出精度を向上
characterRigidbody.interpolation = RigidbodyInterpolation.Interpolate; // 移動を滑らかに
```

**効果:**
- **ContinuousDynamic**: 高速移動時の衝突も正確に検出、すり抜け防止
- **Interpolate**: カメラ追従時の動きが滑らか、カクカクしない

### 2. GameManager.cs の変更

#### RespawnSequence()の修正（GameManager.cs:358-368）

**修正前:**
```csharp
// キャラクターをリスポーン地点に移動
if (activeCharacter != null && defaultSpawnPoint != null)
{
    CharacterController controller = activeCharacter.GetComponent<CharacterController>();
    if (controller != null)
    {
        // CharacterControllerの場合は無効化してから移動
        controller.enabled = false;
        activeCharacter.transform.position = defaultSpawnPoint.position;
        activeCharacter.transform.rotation = defaultSpawnPoint.rotation;
        controller.enabled = true;
    }
    else
    {
        // CharacterController以外の場合は直接移動
        activeCharacter.transform.position = defaultSpawnPoint.position;
        activeCharacter.transform.rotation = defaultSpawnPoint.rotation;
    }
}
```

**修正後:**
```csharp
// キャラクターをリスポーン地点に移動
if (activeCharacter != null && defaultSpawnPoint != null)
{
    // GameCharacterManager.TeleportTo()を使用して物理状態も適切にリセット
    characterManager.TeleportTo(defaultSpawnPoint.position, defaultSpawnPoint.rotation);

    if (enableVerboseLog)
    {
        Debug.Log($"GameManager: キャラクターをリスポーン地点に移動しました。位置: {defaultSpawnPoint.position}");
    }
}
```

**変更点:**
- 実装タイプに応じた分岐を削除
- `TeleportTo()`を使用して一元化
- 物理状態のリセットが自動的に行われる

### 3. DebugCommands.cs の変更

#### ExecuteWarp()の修正（DebugCommands.cs:125-138）

**修正前:**
```csharp
GameObject activeCharacter = gameManager.GetActiveCharacter();
if (activeCharacter == null)
{
    Debug.LogWarning("DebugCommands: アクティブキャラクターが見つかりません。ワープできません。");
    return;
}

// CharacterControllerを取得
CharacterController characterController = activeCharacter.GetComponent<CharacterController>();
if (characterController != null)
{
    // CharacterControllerの場合は無効化してから移動
    characterController.enabled = false;
    activeCharacter.transform.position = command.warpTarget.position;
    activeCharacter.transform.rotation = command.warpTarget.rotation;
    characterController.enabled = true;
}
else
{
    // CharacterController以外の場合は直接移動
    activeCharacter.transform.position = command.warpTarget.position;
    activeCharacter.transform.rotation = command.warpTarget.rotation;
}
```

**修正後:**
```csharp
GameObject activeCharacter = gameManager.GetActiveCharacter();
if (activeCharacter == null)
{
    Debug.LogWarning("DebugCommands: アクティブキャラクターが見つかりません。ワープできません。");
    return;
}

// GameCharacterManager.TeleportTo()を使用して物理状態も適切にリセット
gameManager.CharacterManager.TeleportTo(command.warpTarget.position, command.warpTarget.rotation);
```

**変更点:**
- GameManagerと同様に`TeleportTo()`を使用
- コードが大幅に簡潔に
- Rigidbody実装でも正しく動作

## データフロー

### リスポーン時のフロー

```
死亡イベント発火
  ↓
GameManager.RespawnSequence()
  ├─ yield return new WaitForSeconds(respawnDelay)
  ├─ StateManager.Respawn() (HP回復)
  └─ characterManager.TeleportTo(spawnPoint.position, spawnPoint.rotation)
      ↓
      [Rigidbody実装の場合]
      ├─ characterRigidbody.position = position
      ├─ characterRigidbody.rotation = rotation
      └─ ResetPhysicsState()
          ├─ linearVelocity = Vector3.zero
          ├─ angularVelocity = Vector3.zero
          └─ Physics.SyncTransforms()
              ↓
              物理エンジンの状態が即座に同期
              Interpolationの前フレーム位置もリセット
```

### ワープ時のフロー（デバッグコマンド）

```
ユーザーがワープキーを押す
  ↓
DebugCommands.ExecuteWarp()
  ↓
gameManager.CharacterManager.TeleportTo(warpTarget.position, warpTarget.rotation)
  ↓
  [同上のテレポート処理]
```

## 技術的なポイント

### 1. Rigidbody.positionとtransform.positionの違い

| プロパティ | 変更タイミング | Interpolation | 物理エンジン認識 |
|-----------|--------------|--------------|----------------|
| transform.position | 即座 | ❌ 正しく動作しない | ⏱️ 次のFixedUpdate |
| Rigidbody.position | 即座 | ✅ 正しく動作する | ✅ 即座 |

**Rigidbody実装の場合、必ずRigidbody.positionを使用すべき理由:**
- transform.positionはTransformコンポーネントの位置
- Rigidbody.positionは物理エンジンが管理する位置
- Rigidbodyがアタッチされている場合、物理エンジンが優先される
- Interpolation機能も正しく動作する

### 2. Physics.SyncTransforms()の重要性

**Physics.SyncTransforms()が行うこと:**
1. Transform変更を即座に物理エンジンに反映
2. Interpolationの内部状態をリセット
3. 「前フレーム位置」を現在位置に更新

**呼び出さない場合の問題:**
```
TeleportTo()呼び出し
  ↓
Rigidbody.position = newPosition （物理エンジンは次のFixedUpdateで認識）
  ↓
Interpolation計算
  描画位置 = Lerp(古い前フレーム位置, newPosition, 補間率)
  ↓
  古い位置に引き戻される！
```

**呼び出した場合:**
```
TeleportTo()呼び出し
  ↓
Rigidbody.position = newPosition
  ↓
Physics.SyncTransforms() （即座に同期）
  ├─ 前フレーム位置 = newPosition
  └─ 現在フレーム位置 = newPosition
  ↓
Interpolation計算
  描画位置 = Lerp(newPosition, newPosition, 補間率) = newPosition
  ↓
  正しい位置に表示される！
```

### 3. velocityとangularVelocityのリセット

**なぜゼロにするのか:**
- リスポーン/ワープは瞬間移動
- 移動前の速度を引き継ぐべきではない
- 速度が残っていると、テレポート後に勝手に移動してしまう

**例:**
```
死亡時: linearVelocity = (5, -20, 3) （落下中）
  ↓
TeleportTo()でリスポーン
  ↓
linearVelocity = Vector3.zero （速度をリセット）
  ↓
リスポーン地点で静止した状態でスタート
```

### 4. CharacterControllerの場合

CharacterController実装では物理エンジンを使用しないため：
- `transform.position`を直接変更してOK
- ただし、CharacterControllerを一時的に無効化する必要がある
- 無効化しないと、内部の移動履歴が残る可能性がある

## テストケース

### ケース1: Rigidbody実装でリスポーン

**前提条件:**
- Rigidbody + CapsuleCollider実装のキャラクター
- ContinuousDynamicとInterpolateが有効

**手順:**
1. 高所から落下中に死亡
2. リスポーン処理が実行される

**期待結果:**
- リスポーン地点に正確に配置される
- 落下速度が残らない
- 死亡時の位置に引き戻されない
- 滑らかに表示される

### ケース2: デバッグワープ（Rigidbody実装）

**前提条件:**
- Rigidbody + CapsuleCollider実装のキャラクター
- ContinuousDynamicとInterpolateが有効
- 高速移動中

**手順:**
1. キャラクターを全速力で移動
2. ワープキーを押す

**期待結果:**
- ワープ先に正確に配置される
- 移動速度が残らない
- 元の位置に引き戻されない

### ケース3: CharacterController実装でリスポーン

**前提条件:**
- CharacterController実装のキャラクター

**手順:**
1. 死亡してリスポーン

**期待結果:**
- 従来通りリスポーン地点に配置される
- CharacterControllerの内部状態もリセットされる

## 利点

### 1. Interpolation有効化による滑らかさ

**Before（Interpolationなし）:**
- カメラ追従時にカクカクする
- フレームレートの変動が目立つ

**After（Interpolation有効）:**
- 滑らかな動き
- フレームレート変動が目立たない

### 2. ContinuousDynamic有効化による精度向上

**Before（Discrete）:**
- 高速移動時に壁をすり抜ける可能性
- 薄い床を突き抜けることがある

**After（ContinuousDynamic）:**
- 高速移動でも正確に衝突検出
- すり抜けがほぼゼロ

### 3. コードの一元化

**Before:**
```csharp
// GameManager.csで実装タイプごとに分岐
// DebugCommands.csでも同じ分岐
// VRMUtility.csでも同じ分岐...
```

**After:**
```csharp
// 全てGameCharacterManager.TeleportTo()に統一
characterManager.TeleportTo(position, rotation);
```

**メリット:**
- コードの重複を排除
- バグ修正が1箇所で完結
- 保守性が大幅に向上

### 4. 拡張性

新しいテレポート機能を追加する場合：
```csharp
// ポータル機能
public void OnPortalEnter(Portal portal)
{
    gameManager.CharacterManager.TeleportTo(portal.DestinationPosition, portal.DestinationRotation);
}

// チェックポイント復帰
public void ReturnToCheckpoint(CheckPoint checkpoint)
{
    gameManager.CharacterManager.TeleportTo(checkpoint.SpawnPosition, checkpoint.SpawnRotation);
}
```

すべて`TeleportTo()`を使用するだけで、物理状態も正しくリセットされる。

## 注意点

### 1. Physics.SyncTransforms()のコスト

**問題:**
- `Physics.SyncTransforms()`は物理エンジン全体を同期するため、コストが高い

**対策:**
- リスポーンやワープは頻繁には発生しない
- このコストは許容範囲

### 2. VRMUtilityのRigidbody設定

**注意:**
- VRMUtility.SetupRigidbody()では、まだInterpolateとContinuousDynamicが設定されていない
- 手動配置キャラクターと設定を統一すべき

**今後の対応:**
```csharp
// VRMUtility.SetupRigidbody()
rb.interpolation = RigidbodyInterpolation.Interpolate;
rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
```

### 3. CharacterController実装

CharacterController実装の場合、Interpolation機能は不要：
- CharacterController.Move()は既に滑らかな移動を提供
- 物理エンジンを使用しない

## 関連ファイル

- Assets/Scripts/GameManager/GameCharacterManager.cs (修正: ResetPhysicsState(), TeleportTo()追加、ContinuousDynamic/Interpolate有効化)
- Assets/Scripts/GameManager/GameManager.cs (修正: RespawnSequence()でTeleportTo()を使用)
- Assets/Scripts/Utilities/DebugCommands.cs (修正: ExecuteWarp()でTeleportTo()を使用)

## 今後の拡張案

### 1. VRMキャラクターへの統一設定

VRMUtility.SetupRigidbody()を修正：
```csharp
rb.interpolation = RigidbodyInterpolation.Interpolate;
rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
```

### 2. テレポートエフェクト

TeleportTo()にエフェクトを追加：
```csharp
public void TeleportTo(Vector3 position, Quaternion rotation, bool playEffect = true)
{
    if (playEffect)
    {
        // テレポート元にエフェクト
        PlayTeleportEffect(targetCharacter.transform.position);
    }

    // テレポート処理
    // ...

    if (playEffect)
    {
        // テレポート先にエフェクト
        PlayTeleportEffect(position);
    }
}
```

### 3. テレポート中の無敵時間

```csharp
public void TeleportTo(Vector3 position, Quaternion rotation)
{
    // テレポート処理
    // ...

    // 無敵時間を設定（0.5秒）
    StartCoroutine(InvincibilityAfterTeleport(0.5f));
}
```

### 4. テレポート制限

特定の状況ではテレポートを無効化：
```csharp
public bool CanTeleport()
{
    // 死亡中はテレポート不可
    if (gameManager.StateManager.State.IsDead.CurrentValue) return false;

    // ノックバック中はテレポート不可
    if (isKnockback) return false;

    return true;
}

public void TeleportTo(Vector3 position, Quaternion rotation)
{
    if (!CanTeleport())
    {
        Debug.LogWarning("GameCharacterManager: 現在テレポートできません。");
        return;
    }

    // テレポート処理
    // ...
}
```

## まとめ

今回の実装により、以下が実現されました：

1. **Interpolation有効化による滑らかな動き**
   - カメラ追従時のカクカク解消
   - フレームレート変動の影響軽減

2. **ContinuousDynamic有効化による衝突精度向上**
   - 高速移動時のすり抜け防止
   - より正確な衝突検出

3. **リスポーンとワープ時の物理状態リセット**
   - velocity、angularVelocityをゼロに
   - Interpolation前フレーム位置をリセット
   - Physics.SyncTransforms()で即座に同期

4. **テレポート機能の一元化**
   - GameCharacterManager.TeleportTo()に統一
   - 実装タイプの違いを吸収
   - コードの重複を排除

これにより、Rigidbody Interpolationの恩恵を受けながら、リスポーンとワープも正しく動作するようになりました。
