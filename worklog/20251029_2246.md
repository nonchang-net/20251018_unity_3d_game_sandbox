# ワークログ: CameraLockArea機能の実装（イベント駆動設計）

作成日時: 2025-10-29 22:46
更新日時: 2025-10-29 23:00

## 変更した内容の概要

- マップ上の特定領域でカメラを固定する「CameraLockArea」機能を実装しました
- TrackingSettingに「カメラ向き固定」と「垂直入力無効化」のフラグを追加し、2Dゲーム風の操作に対応しました
- CameraLockerコンポーネントを新規作成し、エリアごとに複数のカメラ設定を保持できるようにしました
- **責務分離**: コリジョン検出をGameCharacterCollisionTriggerに集約し、イベント駆動設計でGameCameraManagerが処理を行う形に変更しました

## なぜそのように変更しようと考えたか

- 特定のマップ領域で視点を固定することで、2Dゲームのようなプレイ体験や演出を実現するため
- カメラ固定時は上下移動入力を無効化することで、2D横スクロールゲームのような直感的な操作を提供するため
- エリアごとに異なるカメラ設定を簡単に切り替えられるようにし、ゲームデザインの自由度を向上させるため
- **責務を適切に分離**: コリジョン検出はGameCharacterCollisionTriggerで、カメラ制御はGameCameraManagerで行い、GameStateManagerのイベント経由で疎結合に通信するため

## 実装詳細

### 1. TrackingSetting.cs の変更

#### カメラロック設定の追加 (TrackingSetting.cs:67-74)

```csharp
[Header("カメラロック設定")]
[Tooltip("カメラの向きを固定する（2Dゲーム風の操作）")]
[SerializeField] private bool lockCameraRotation = false;
public bool LockCameraRotation => lockCameraRotation;

[Tooltip("カメラ固定時に上下方向の入力を無効化する（2Dゲーム風の操作）")]
[SerializeField] private bool disableVerticalInput = false;
public bool DisableVerticalInput => disableVerticalInput;
```

**設計意図:**
- `lockCameraRotation`: カメラの回転を完全に固定し、プレイヤーの視点操作を無効化
- `disableVerticalInput`: 上下方向の移動入力を無効化し、2D横スクロールゲームのような操作感を実現

### 2. CameraLocker.cs の新規作成

#### CameraLockerコンポーネント (CameraLocker.cs)

```csharp
public class CameraLocker : MonoBehaviour
{
    [Header("カメラロック設定")]
    [Tooltip("このエリアで使用するカメラ設定のリスト（複数設定可能、Zキーで切り替え）")]
    [SerializeField] private TrackingSetting[] trackingSettings;

    public TrackingSetting[] GetTrackingSettings()
    {
        return trackingSettings;
    }

    void OnValidate()
    {
        // Inspectorで変更時の検証（null設定の警告など）
    }
}
```

**設計意図:**
- CameraLockAreaタグを持つコリジョンと一緒に使用
- TrackingSetting配列を保持し、エリア内でZキーによる複数カメラ切り替えに対応
- OnValidate()でInspector設定のミスを早期検出

### 3. CharacterTracker.cs の変更

#### カメラロックフラグの追加 (CharacterTracker.cs:52-53)

```csharp
private bool lockCameraRotation => trackingSetting != null ? trackingSetting.LockCameraRotation : false;
private bool disableVerticalInput => trackingSetting != null ? trackingSetting.DisableVerticalInput : false;
```

#### DisableVerticalInputプロパティの公開 (CharacterTracker.cs:66-69)

```csharp
/// <summary>
/// 垂直方向の入力を無効化するかどうかを取得
/// </summary>
public bool DisableVerticalInput => disableVerticalInput;
```

#### HandleCameraRotation()の修正 (CharacterTracker.cs:100-120)

```csharp
void HandleCameraRotation()
{
    // カメラ回転がロックされている場合は入力を無視
    if (lockCameraRotation)
    {
        return;
    }

    // ... 既存の回転処理
}
```

**設計意図:**
- lockCameraRotationがtrueの場合、カメラ回転入力を完全に無視
- disableVerticalInputフラグを外部から参照可能にし、GameInputManagerが入力制御に使用

### 4. GameCameraManager.cs の変更

#### 一時的なトラッキング設定の管理 (GameCameraManager.cs:35-38)

```csharp
/// <summary>CameraLockArea用の一時的なトラッキング設定</summary>
private TrackingSetting[] temporaryTrackingSettings = null;
/// <summary>一時設定を使用する前のオリジナル設定のインデックス</summary>
private int originalTrackingSettingIndex = 0;
```

#### SwitchToNextTrackingSetting()の修正 (GameCameraManager.cs:138-161)

```csharp
private void SwitchToNextTrackingSetting()
{
    // 一時設定があればそれを優先使用
    TrackingSetting[] activeSettings = temporaryTrackingSettings != null ? temporaryTrackingSettings : togglableTrackingSettings;

    if (activeSettings == null || activeSettings.Length == 0)
    {
        Debug.LogWarning("GameCameraManager: トラッキング設定が設定されていないため、カメラ切り替えできません。");
        return;
    }

    // ... 切り替え処理
}
```

#### SetTemporaryTrackingSettings()の追加 (GameCameraManager.cs:300-319)

```csharp
public void SetTemporaryTrackingSettings(TrackingSetting[] settings)
{
    if (settings == null || settings.Length == 0)
    {
        Debug.LogWarning("GameCameraManager: SetTemporaryTrackingSettings() に null または空の配列が渡されました。");
        return;
    }

    // 現在のインデックスを保存
    originalTrackingSettingIndex = currentTrackingSettingIndex;

    // 一時設定を設定
    temporaryTrackingSettings = settings;

    // インデックスをリセットして最初の設定を適用
    currentTrackingSettingIndex = 0;
    ApplyTrackingSetting(0);

    Debug.Log($"GameCameraManager: CameraLockArea用の一時トラッキング設定を適用しました（{settings.Length}個）。");
}
```

#### ClearTemporaryTrackingSettings()の追加 (GameCameraManager.cs:325-345)

```csharp
public void ClearTemporaryTrackingSettings()
{
    if (temporaryTrackingSettings == null)
    {
        // 一時設定が設定されていない場合は何もしない
        return;
    }

    // 一時設定をクリア
    temporaryTrackingSettings = null;

    // 元のインデックスに戻す
    currentTrackingSettingIndex = originalTrackingSettingIndex;

    // 元の設定を適用
    if (togglableTrackingSettings != null && togglableTrackingSettings.Length > 0)
    {
        ApplyTrackingSetting(currentTrackingSettingIndex);
        Debug.Log("GameCameraManager: 一時トラッキング設定をクリアし、元の設定に戻しました。");
    }
}
```

**設計意図:**
- CameraLockAreaに入った際、通常のtogglableTrackingSettingsを一時的にtemporaryTrackingSettingsに差し替え
- Zキーによる切り替え対象が自動的にtemporaryTrackingSettingsになる
- エリアを出たら元の設定とインデックスに復帰

### 5. GameManager.cs の変更

#### GameCameraManager参照の追加 (GameManager.cs:49-51)

```csharp
[Tooltip("カメラ管理マネージャー")]
[SerializeField] private GameCameraManager cameraManager;
public GameCameraManager CameraManager => cameraManager;
```

**設計意図:**
- GameCharacterManagerからGameCameraManagerにアクセスできるようにする
- 他のマネージャーと同様の参照パターンを維持

### 6. GameStateManager.cs の変更（イベント追加）

#### CameraLockArea進入/退出イベントの追加 (GameStateManager.cs:385-395)

```csharp
/// <summary>
/// CameraLockAreaに進入したときに発火するSubject
/// CameraLockerコンポーネント、TrackingSetting配列、エリア名を通知
/// </summary>
public Subject<CameraLockAreaEnterInfo> OnCameraLockAreaEnter { get; private set; }

/// <summary>
/// CameraLockAreaから退出したときに発火するSubject
/// エリア名を通知
/// </summary>
public Subject<CameraLockAreaExitInfo> OnCameraLockAreaExit { get; private set; }
```

#### イベント情報構造体の追加 (GameStateManager.cs:310-348)

```csharp
/// <summary>
/// CameraLockArea進入情報
/// </summary>
public readonly struct CameraLockAreaEnterInfo
{
    /// <summary>TrackingSetting配列</summary>
    public readonly TrackingSetting[] TrackingSettings;

    /// <summary>エリア名</summary>
    public readonly string AreaName;

    /// <summary>エリアのGameObject</summary>
    public readonly GameObject AreaObject;

    public CameraLockAreaEnterInfo(TrackingSetting[] trackingSettings, string areaName, GameObject areaObject)
    {
        TrackingSettings = trackingSettings;
        AreaName = areaName;
        AreaObject = areaObject;
    }
}

/// <summary>
/// CameraLockArea退出情報
/// </summary>
public readonly struct CameraLockAreaExitInfo
{
    /// <summary>エリア名</summary>
    public readonly string AreaName;

    /// <summary>エリアのGameObject</summary>
    public readonly GameObject AreaObject;

    public CameraLockAreaExitInfo(string areaName, GameObject areaObject)
    {
        AreaName = areaName;
        AreaObject = areaObject;
    }
}
```

#### イベント発火メソッドの追加 (GameStateManager.cs:202-221)

```csharp
/// <summary>
/// CameraLockAreaに進入したことを通知する
/// </summary>
public void EnterCameraLockArea(TrackingSetting[] trackingSettings, string areaName, GameObject areaObject)
{
    state.OnCameraLockAreaEnter.OnNext(new CameraLockAreaEnterInfo(trackingSettings, areaName, areaObject));
}

/// <summary>
/// CameraLockAreaから退出したことを通知する
/// </summary>
public void ExitCameraLockArea(string areaName, GameObject areaObject)
{
    state.OnCameraLockAreaExit.OnNext(new CameraLockAreaExitInfo(areaName, areaObject));
}
```

**設計意図:**
- R3のSubjectを使用してイベント駆動型の設計を採用
- CameraLockAreaの進入/退出を一元管理
- GameCharacterCollisionTriggerとGameCameraManagerを疎結合に連携

### 7. GameCharacterCollisionTrigger.cs の変更（コリジョン検出）

#### OnTriggerEnter/Exitへの分岐追加 (GameCharacterCollisionTrigger.cs:86-90, 103-107)

```csharp
void OnTriggerEnter(Collider other)
{
    // ... 他のタグチェック ...

    // CameraLockAreaタグのオブジェクトに触れたかチェック
    else if (other.CompareTag("CameraLockArea"))
    {
        EnterCameraLockArea(other.gameObject);
    }
}

void OnTriggerExit(Collider other)
{
    // ... 他のタグチェック ...

    // CameraLockAreaタグのオブジェクトから離れたかチェック
    else if (other.CompareTag("CameraLockArea"))
    {
        ExitCameraLockArea(other.gameObject);
    }
}
```

#### EnterCameraLockArea()の実装 (GameCharacterCollisionTrigger.cs:260-280)

```csharp
void EnterCameraLockArea(GameObject cameraLockAreaObject)
{
    // CameraLockerコンポーネントを取得
    CameraLocker cameraLocker = cameraLockAreaObject.GetComponent<CameraLocker>();
    if (cameraLocker == null)
    {
        Debug.LogError($"GameCharacterCollisionTrigger: CameraLockAreaタグのオブジェクト '{cameraLockAreaObject.name}' にCameraLockerコンポーネントがありません。", cameraLockAreaObject);
        return;
    }

    // TrackingSetting配列を取得
    TrackingSetting[] trackingSettings = cameraLocker.GetTrackingSettings();
    if (trackingSettings == null || trackingSettings.Length == 0)
    {
        Debug.LogError($"GameCharacterCollisionTrigger: CameraLocker '{cameraLockAreaObject.name}' のTrackingSettingsが空です。", cameraLockAreaObject);
        return;
    }

    // gameManager.StateManagerを通じてCameraLockAreaに進入したことを通知
    gameManager.StateManager.EnterCameraLockArea(trackingSettings, cameraLockAreaObject.name, cameraLockAreaObject);
}
```

#### ExitCameraLockArea()の実装 (GameCharacterCollisionTrigger.cs:286-290)

```csharp
void ExitCameraLockArea(GameObject cameraLockAreaObject)
{
    // gameManager.StateManagerを通じてCameraLockAreaから退出したことを通知
    gameManager.StateManager.ExitCameraLockArea(cameraLockAreaObject.name, cameraLockAreaObject);
}
```

**設計意図:**
- GameCharacterCollisionTriggerにコリジョン検出の責務を集約
- CheckPoint、HighJumperなどと同様のパターンで実装
- CameraLockerコンポーネントからTrackingSettingを取得
- GameStateManagerを経由してイベント発火（疎結合）

### 8. GameCameraManager.cs の変更（イベント購読）

#### R3購読管理の追加 (GameCameraManager.cs:41-43)

```csharp
/// <summary>R3購読管理</summary>
private IDisposable cameraViewChangeSubscription;
private IDisposable cameraLockAreaEnterSubscription;
private IDisposable cameraLockAreaExitSubscription;
```

#### Start()でのイベント購読開始 (GameCameraManager.cs:77-81)

```csharp
// カメラビュー切り替えイベントを購読
SubscribeCameraViewChangeEvents();

// CameraLockAreaイベントを購読
SubscribeCameraLockAreaEvents();
```

#### OnDestroy()での購読解放 (GameCameraManager.cs:84-90)

```csharp
void OnDestroy()
{
    // R3購読の解放
    cameraViewChangeSubscription?.Dispose();
    cameraLockAreaEnterSubscription?.Dispose();
    cameraLockAreaExitSubscription?.Dispose();
}
```

#### SubscribeCameraLockAreaEvents()の実装 (GameCameraManager.cs:142-158)

```csharp
/// <summary>
/// CameraLockAreaイベントを購読
/// </summary>
private void SubscribeCameraLockAreaEvents()
{
    // CameraLockArea進入イベント
    cameraLockAreaEnterSubscription = gameManager.StateManager.State.OnCameraLockAreaEnter.Subscribe(info =>
    {
        SetTemporaryTrackingSettings(info.TrackingSettings);
    });

    // CameraLockArea退出イベント
    cameraLockAreaExitSubscription = gameManager.StateManager.State.OnCameraLockAreaExit.Subscribe(info =>
    {
        ClearTemporaryTrackingSettings();
    });
}
```

**設計意図:**
- GameStateManagerのイベントを購読し、疎結合に連携
- SetTemporaryTrackingSettings()とClearTemporaryTrackingSettings()は既存のメソッドをそのまま使用
- R3のDisposableパターンでメモリリークを防止

### 9. GameCharacterManager.cs からの削除

以前は GameCharacterManager.cs に OnTriggerEnter/Exit と HandleCameraLockAreaEnter/Exit を実装していましたが、責務分離のため削除しました。

**削除した内容:**
- OnTriggerEnter(Collider other)
- OnTriggerExit(Collider other)
- HandleCameraLockAreaEnter(Collider areaCollider)
- HandleCameraLockAreaExit(Collider areaCollider)

**理由:**
- GameCharacterManagerはキャラクターの移動・アニメーション制御に専念すべき
- コリジョン検出はGameCharacterCollisionTriggerが既に担当している
- 責務を適切に分離し、各クラスの役割を明確にするため

## アーキテクチャ設計

### イベント駆動フロー

```
プレイヤーがCameraLockAreaに進入
  ↓
GameCharacterCollisionTrigger.OnTriggerEnter()
  ↓
CameraLockerコンポーネントからTrackingSetting[]を取得
  ↓
GameStateManager.EnterCameraLockArea()
  ↓
OnCameraLockAreaEnter.OnNext()（R3 Subject）
  ↓
【イベント購読者に通知】
  ↓
GameCameraManager.SubscribeCameraLockAreaEvents()
  ↓
GameCameraManager.SetTemporaryTrackingSettings()
  ↓
最初のTrackingSettingを適用（lockCameraRotation, disableVerticalInputも含む）
  ↓
【エリア内での操作】
- カメラ回転がロック（CharacterTracker.HandleCameraRotation()で入力無視）
- 上下移動が無効化（GameInputManager.OnMove()でinput.y = 0）
- Zキーでエリア専用のTrackingSettings間を切り替え
  ↓
プレイヤーがCameraLockAreaから退出
  ↓
GameCharacterCollisionTrigger.OnTriggerExit()
  ↓
GameStateManager.ExitCameraLockArea()
  ↓
OnCameraLockAreaExit.OnNext()（R3 Subject）
  ↓
【イベント購読者に通知】
  ↓
GameCameraManager.SubscribeCameraLockAreaEvents()
  ↓
GameCameraManager.ClearTemporaryTrackingSettings()
  ↓
元のカメラ設定に復帰（通常の3D操作に戻る）
```

### 責務分離の明確化

| クラス | 責務 |
|--------|------|
| **GameCharacterCollisionTrigger** | コリジョン検出（Coin、DamageSource、DeadZone、CheckPoint、CameraLockAreaなど） |
| **GameStateManager** | ゲーム状態管理、イベント発火・購読の中継 |
| **GameCameraManager** | カメラ設定の管理、TrackingSetting切り替え |
| **CharacterTracker** | カメラの回転・位置制御、lockCameraRotationの適用 |
| **GameInputManager** | 入力の集約、disableVerticalInputの適用 |
| **CameraLocker** | CameraLockArea用のTrackingSetting配列を保持 |

### イベント駆動設計の利点

1. **疎結合**: GameCharacterCollisionTriggerとGameCameraManagerは直接参照し合わない
2. **拡張性**: 他のコンポーネントも OnCameraLockAreaEnter/Exit を購読可能（例: サウンド、UI）
3. **一貫性**: CheckPoint、HighJumperなど既存のイベント駆動パターンと統一
4. **テスタビリティ**: イベントを直接発火させることで単体テストが容易

## 使用方法

1. Unityエディタで「CameraLockArea」タグを追加
2. 空のGameObjectを作成し、タグを「CameraLockArea」に設定
3. Box Colliderを追加し、「Is Trigger」を有効化
4. **GameCharacterCollisionTriggerがプレイヤーにアタッチされていることを確認**
5. CameraLockerコンポーネントを追加
6. TrackingSettingを作成し、以下を設定：
   - `lockCameraRotation = true`: カメラを固定
   - `disableVerticalInput = true`: 2Dゲーム風の操作
7. CameraLockerのTracking Settingsに割り当て
8. GameManagerのCameraManagerフィールドにGameCameraManagerを設定

これにより、プレイヤーがエリアに入ると自動的にカメラが固定され、2D横スクロールゲームのような操作性に切り替わります。エリア内で複数のTrackingSettingを設定した場合は、Zキーで切り替えができます。

## 動作フロー（更新版）

```
プレイヤーがCameraLockAreaに進入
  ↓
GameCharacterCollisionTrigger.OnTriggerEnter()
  ↓
CameraLockerコンポーネントからTrackingSetting[]を取得
  ↓
GameStateManager.EnterCameraLockArea()
  ↓
OnCameraLockAreaEnter.OnNext()（R3イベント発火）
  ↓
GameCameraManager.SubscribeCameraLockAreaEvents()でイベント受信
  ↓
GameCameraManager.SetTemporaryTrackingSettings()
  ↓
最初のTrackingSettingを適用（lockCameraRotation, disableVerticalInputも含む）
  ↓
【エリア内での操作】
- カメラ回転がロック（CharacterTracker.HandleCameraRotation()で入力無視）
- 上下移動が無効化（GameInputManager.OnMove()でinput.y = 0）
- Zキーでエリア専用のTrackingSettings間を切り替え
  ↓
プレイヤーがCameraLockAreaから退出
  ↓
GameCharacterCollisionTrigger.OnTriggerExit()
  ↓
GameStateManager.ExitCameraLockArea()
  ↓
OnCameraLockAreaExit.OnNext()（R3イベント発火）
  ↓
GameCameraManager.SubscribeCameraLockAreaEvents()でイベント受信
  ↓
GameCameraManager.ClearTemporaryTrackingSettings()
  ↓
元のカメラ設定に復帰（通常の3D操作に戻る）
```

## 技術的なポイント

### 1. イベント駆動設計パターン

R3のSubjectを使用したイベント駆動設計により、コンポーネント間の疎結合を実現しています：

```csharp
// GameStateManager: イベント発火
state.OnCameraLockAreaEnter.OnNext(new CameraLockAreaEnterInfo(trackingSettings, areaName, areaObject));

// GameCameraManager: イベント購読
cameraLockAreaEnterSubscription = gameManager.StateManager.State.OnCameraLockAreaEnter.Subscribe(info =>
{
    SetTemporaryTrackingSettings(info.TrackingSettings);
});
```

### 2. 一時的な設定の優先使用パターン

GameCameraManagerでは、`temporaryTrackingSettings`が存在する場合、常に通常の`togglableTrackingSettings`より優先されます:

```csharp
TrackingSetting[] activeSettings = temporaryTrackingSettings != null ? temporaryTrackingSettings : togglableTrackingSettings;
```

これにより、既存のカメラ切り替えロジックを変更せずに、エリアごとの設定切り替えを実現しています。

### 3. 元の設定へのスムーズな復帰

CameraLockArea退出時、`originalTrackingSettingIndex`を保存しているため、エリアに入る前のカメラ設定インデックスに正確に復帰できます。これによりプレイヤーの視点が突然変わることを防ぎます。

### 4. 入力無効化の実装場所

`disableVerticalInput`の判定はGameInputManager.OnMove()で行うことで、入力の最上流で無効化を実現しています。これにより、キャラクター制御ロジック側は入力無効化を意識する必要がありません。

## 使用方法

### CameraLockAreaの設定手順

1. **Unityエディタでタグを追加**
   - Tag Managerで「CameraLockArea」タグを追加

2. **カメラロックエリアの作成**
   - 空のGameObjectを作成し、名前を「CameraLockArea_XXX」などに設定
   - Tagを「CameraLockArea」に設定
   - Box Colliderなどのコリジョンを追加し、「Is Trigger」を有効化
   - CameraLockerコンポーネントを追加

3. **TrackingSettingの作成**
   - Project ウィンドウで右クリック → Create → Game → Camera → Tracking Setting
   - カメラ設定を調整:
     - `lockCameraRotation = true`: カメラ向きを固定
     - `disableVerticalInput = true`: 上下移動を無効化（2Dゲーム風）
   - 複数の設定を作成してZキー切り替えに対応可能

4. **CameraLockerに設定を割り当て**
   - CameraLockerコンポーネントのTracking Settingsに作成したTrackingSettingを割り当て
   - 複数設定することで、エリア内でZキーによる切り替えが可能

5. **GameManagerの設定**
   - GameManagerのCameraManagerフィールドにGameCameraManagerを割り当て

### 動作フロー

```
プレイヤーがCameraLockAreaに進入
  ↓
GameCharacterManager.OnTriggerEnter()
  ↓
CameraLockerコンポーネントからTrackingSetting[]を取得
  ↓
GameCameraManager.SetTemporaryTrackingSettings()
  ↓
最初のTrackingSettingを適用（lockCameraRotation, disableVerticalInputも含む）
  ↓
【エリア内での操作】
- カメラ回転がロック（CharacterTracker.HandleCameraRotation()で入力無視）
- 上下移動が無効化（GameInputManager.OnMove()でinput.y = 0）
- Zキーでエリア専用のTrackingSettings間を切り替え
  ↓
プレイヤーがCameraLockAreaから退出
  ↓
GameCharacterManager.OnTriggerExit()
  ↓
GameCameraManager.ClearTemporaryTrackingSettings()
  ↓
元のカメラ設定に復帰（通常の3D操作に戻る）
```

## 技術的なポイント

### 1. 一時的な設定の優先使用パターン

GameCameraManagerでは、`temporaryTrackingSettings`が存在する場合、常に通常の`togglableTrackingSettings`より優先されます:

```csharp
TrackingSetting[] activeSettings = temporaryTrackingSettings != null ? temporaryTrackingSettings : togglableTrackingSettings;
```

これにより、既存のカメラ切り替えロジックを変更せずに、エリアごとの設定切り替えを実現しています。

### 2. 元の設定へのスムーズな復帰

CameraLockArea退出時、`originalTrackingSettingIndex`を保存しているため、エリアに入る前のカメラ設定インデックスに正確に復帰できます。これによりプレイヤーの視点が突然変わることを防ぎます。

### 3. 入力無効化の実装場所

`disableVerticalInput`の判定はGameInputManager.OnMove()で行うことで、入力の最上流で無効化を実現しています。これにより、キャラクター制御ロジック側は入力無効化を意識する必要がありません。

## テスト項目

- [ ] CameraLockAreaに入った際、カメラ回転が固定されるか
- [ ] CameraLockAreaに入った際、上下移動入力が無効化されるか
- [ ] エリア内でZキーによるカメラ切り替えが動作するか
- [ ] CameraLockAreaから出た際、元のカメラ設定に復帰するか
- [ ] 複数のCameraLockAreaを連続して通過した際、正しく動作するか
- [ ] lockCameraRotation = false, disableVerticalInput = true の組み合わせが動作するか

## 今後の拡張案

- CameraLockAreaへの進入・退出時にイベント通知を追加し、UIやサウンド演出と連携
- エリア進入時のカメラトランジションアニメーションを追加
- エリアごとにプレイヤーの移動速度も制限できるように拡張
- エリア内でのジャンプ無効化など、さらなる操作制限オプションの追加
