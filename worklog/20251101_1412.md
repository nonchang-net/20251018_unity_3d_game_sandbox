# ワークログ: カメラ回転処理のバグ修正

作成日時: 2025-11-01 14:12

## 変更した内容の概要

- CharacterTracker.csのUpdateCameraPosition()メソッドで、lockCameraRotationの条件分岐が実装されていなかった問題を修正しました
- カメラ回転設定時に、lockCameraRotationがtrueの場合は固定角度を使用し、falseの場合はキャラクターを見る方向に回転するように修正しました
- これにより、カメラ固定機能実装後に発生していたキャラクターの挙動バグ（想定外の方向に向く、逆方向に移動する）を解消しました

## なぜそのように変更しようと考えたか

- 前回の作業（20251029_2334.md: カメラ固定機能とスムーズトランジション実装）で、lockCameraRotationに応じたカメラ回転処理の実装が記載されていましたが、実際のコードには反映されていませんでした
- カメラの位置計算ではlockCameraRotationの影響を受けるが、最終的な回転は常にLookAt（キャラクターを見る方向）になっていたため、位置と回転が矛盾していました
- この矛盾により、キャラクターを動かした際に想定外の方向に向いたり、逆方向に移動してカーソルを離すと移動前の向きに向き直る問題が発生していました

## 実装詳細

### CharacterTracker.cs の変更

#### UpdateCameraPosition()メソッドの修正（CharacterTracker.cs:225-239）

**修正前:**
```csharp
// カメラの位置と向きを設定
transform.position = currentCameraPosition;

// カメラの回転を設定（lockCameraRotation有効時でもキャラクターを見る）
// カメラの回転をスムージング（旧実装: transform.LookAt(targetPosition);）
Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
    Time.deltaTime * positionSmoothSpeed);
```

**修正後:**
```csharp
// カメラの位置と向きを設定
transform.position = currentCameraPosition;

// カメラの回転を設定
if (lockCameraRotation)
{
    // カメラ回転が固定されている場合、指定された角度を使用
    Quaternion targetRotation = Quaternion.Euler(lockedCameraRotation);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
else
{
    // カメラの回転をスムージング（旧実装: transform.LookAt(targetPosition);）
    Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
```

**変更点:**
- lockCameraRotationの値によってカメラ回転の計算方法を分岐
- lockCameraRotation == trueの場合、lockedCameraRotation（Vector3）から固定角度を取得し、Quaternion.Eulerで回転を作成
- lockCameraRotation == falseの場合、従来通りキャラクターを見る方向（LookAt）にカメラを回転

**動作:**
1. **lockCameraRotation == true**の場合
   - TrackingSettingに設定されたlockedCameraRotation（例: (30, 180, 0)）を使用
   - カメラは常にその固定角度を維持
   - キャラクターの移動に合わせて位置は変わるが、向きは固定

2. **lockCameraRotation == false**の場合
   - 従来通りの動作
   - カメラは常にキャラクターを見る方向に回転
   - プレイヤーの視点操作も有効

## 問題の原因

### カメラ位置と回転の矛盾

**UpdateCameraPosition()メソッドの処理フロー:**
1. lockCameraRotationの値に応じてカメラ位置を計算（137-150行目）
   - lockCameraRotation == trueの場合、lockedCameraRotationから角度を取得
   - lockCameraRotation == falseの場合、cameraYaw/cameraPitchから角度を取得
2. その角度を使ってカメラの理想的な位置（desiredPosition）を計算（152-162行目）
3. 障害物回避処理（166-212行目）
4. カメラ位置のスムージング（214-220行目）
5. **カメラの回転を設定（225-229行目）← ここで問題発生**

**問題の箇所:**
修正前は、カメラの回転を設定する際に常にLookAt（キャラクターを見る方向）を使用していました。
```csharp
// 常にキャラクターを見る方向に回転（lockCameraRotationの値に関係なく）
Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
```

**矛盾の発生:**
```
lockCameraRotation == true の場合:
  ↓
カメラ位置の計算: lockedCameraRotation (30, 180, 0) を使用
  → カメラは特定の固定位置に配置される
  ↓
カメラの回転の設定: LookAt（キャラクターを見る方向）を使用
  → カメラの向きは固定角度ではなく、キャラクターを見る方向になる
  ↓
結果: 位置と回転が矛盾し、想定外の挙動になる
```

**具体例:**
```
lockedCameraRotation = (30, 180, 0) の場合:
  ↓
位置計算: yaw=180°, pitch=30° でカメラ位置を計算
  → カメラはキャラクターの正面（北側）、やや上から配置
  ↓
回転設定: LookAtでキャラクターを見る方向に回転
  → カメラは南を向く（yaw=0°付近）
  ↓
結果: 位置は北側にあるのに、向きは南を向いている
  → キャラクターが画面外に出る、または変な向きで表示される
```

## 修正後の動作

### lockCameraRotation == true の場合

```
カメラ位置の計算: lockedCameraRotation (30, 180, 0) を使用
  → カメラはキャラクターの正面（北側）、やや上から配置
  ↓
カメラの回転の設定: Quaternion.Euler(lockedCameraRotation) を使用
  → カメラの向きも (30, 180, 0) に固定
  ↓
結果: 位置も回転も一貫して固定角度を使用
  → カメラは意図した固定位置・固定角度でキャラクターを撮影
```

### lockCameraRotation == false の場合

```
カメラ位置の計算: cameraYaw, cameraPitch を使用（プレイヤー入力）
  → カメラはプレイヤーの視点操作に応じた位置に配置
  ↓
カメラの回転の設定: LookAt（キャラクターを見る方向）を使用
  → カメラは常にキャラクターを見る
  ↓
結果: 従来通りの動作（3Dゲームの一般的なカメラ）
  → プレイヤーは自由に視点を操作できる
```

## データフロー

### 通常時（lockCameraRotation == false）

```
プレイヤーの視点入力（マウス移動）
  ↓
CharacterTracker.SetLookInput(Vector2)
  ↓
HandleCameraRotation()
  ├─ cameraYaw += lookInput.x
  └─ cameraPitch -= lookInput.y
  ↓
UpdateCameraPosition()
  ├─ yaw = cameraYaw
  ├─ pitch = cameraPitch
  ├─ カメラ位置を計算
  └─ カメラの回転 = LookAt（キャラクターを見る方向）
  ↓
結果: プレイヤーの入力に応じて自由にカメラ操作
```

### カメラ固定時（lockCameraRotation == true）

```
CameraLockAreaに進入
  ↓
GameStateManager.EnterCameraLockArea()
  ↓
GameCameraManager.SetTemporaryTrackingSettings()
  ↓
CharacterTracker.SetTrackingSetting(lockCameraRotation=true)
  ↓
HandleCameraRotation()
  └─ lockCameraRotationがtrueなのでreturn（入力無視）
  ↓
UpdateCameraPosition()
  ├─ yaw = lockedCameraRotation.y
  ├─ pitch = lockedCameraRotation.x
  ├─ カメラ位置を計算
  └─ カメラの回転 = Quaternion.Euler(lockedCameraRotation)
  ↓
結果: カメラは固定位置・固定角度でキャラクターを撮影
```

## 技術的なポイント

### 1. Quaternion.EulerとQuaternion.LookRotationの違い

**Quaternion.Euler(Vector3):**
```csharp
Quaternion targetRotation = Quaternion.Euler(lockedCameraRotation);
```
- Euler Angles（x, y, z）を直接指定して回転を作成
- 絶対的な角度を指定する場合に使用
- 例: (30, 180, 0) → X軸30°、Y軸180°、Z軸0°の回転

**Quaternion.LookRotation(Vector3):**
```csharp
Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
```
- 指定した方向ベクトルを「前方」とする回転を作成
- ターゲットを見る方向を計算する場合に使用
- 例: targetPosition - transform.position → カメラからキャラクターへのベクトル方向を向く回転

**使い分け:**
- 固定カメラ（lockCameraRotation == true）: Quaternion.Euler（絶対角度を指定）
- 追従カメラ（lockCameraRotation == false）: Quaternion.LookRotation（ターゲットを見る）

### 2. Quaternion.Slerpによるスムーズな回転

```csharp
transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
    Time.deltaTime * positionSmoothSpeed);
```

**Slerp（Spherical Linear Interpolation）:**
- 球面線形補間により、自然な回転を実現
- 現在の回転からターゲット回転へ徐々に変化
- Time.deltaTimeを使用してフレームレート非依存

**効果:**
- 一瞬でカメラが回転するのではなく、滑らかに回転
- CameraLockAreaへの進入・退出時のトランジションと組み合わせて、より自然な視点変化を実現

### 3. lockCameraRotationとカメラ位置計算の関係

```csharp
// カメラの角度を決定（ロック時は固定角度、通常時は入力ベース）
float yaw, pitch;
if (lockCameraRotation)
{
    // 固定カメラの場合、lockedCameraRotationから角度を取得
    yaw = lockedCameraRotation.y;
    pitch = lockedCameraRotation.x;
}
else
{
    // 通常の場合、入力ベースの角度を使用
    yaw = cameraYaw;
    pitch = cameraPitch;
}
```

**重要な点:**
- カメラの**位置計算**と**回転設定**の両方で、同じ角度を使用する必要がある
- 位置計算でlockCameraRotationを使い、回転設定でLookAtを使うと矛盾が発生
- 今回の修正により、位置と回転が一貫した角度を使用するようになった

## 検証方法

### テストケース1: 通常エリアでの動作確認

**前提条件:**
- lockCameraRotation == false の通常エリア

**手順:**
1. キャラクターを移動
2. マウスでカメラを回転

**期待結果:**
- カメラは従来通り動作
- プレイヤーの視点操作が正常に機能
- キャラクターが変な向きにならない

### テストケース2: CameraLockAreaでの動作確認

**前提条件:**
- lockCameraRotation == true
- lockedCameraRotation = (30, 180, 0) の CameraLockArea

**手順:**
1. CameraLockAreaに進入
2. キャラクターを移動
3. マウスでカメラを回転しようとする

**期待結果:**
- カメラは固定位置・固定角度でキャラクターを撮影
- マウス操作は無視される（HandleCameraRotation()でreturn）
- キャラクターが意図した方向に正しく表示される
- キャラクターを動かしても想定外の方向に向かない

### テストケース3: CameraLockArea退出時の動作確認

**前提条件:**
- CameraLockArea内にいる状態

**手順:**
1. CameraLockAreaから退出
2. キャラクターを移動

**期待結果:**
- カメラは通常の3D操作に戻る
- 移動前の向きに向き直ることはない（maintainYawOnUnlockがtrueの場合）
- プレイヤーの視点操作が正常に機能

## 修正前後の比較

### 修正前の問題

**症状1: 想定外の方向に向く**
```
CameraLockAreaに進入
  ↓
カメラ位置: lockedCameraRotation (30, 180, 0) で計算
カメラ回転: LookAt（キャラクターを見る方向）
  ↓
矛盾が発生
  ↓
キャラクターが画面外に出る、または変な向きで表示される
```

**症状2: 逆方向に移動してカーソルを離すと移動前の向きに向き直る**
```
キャラクターを移動
  ↓
カメラ位置: lockCameraRotationで計算（固定位置）
カメラ回転: LookAt（常にキャラクターを見る）
  ↓
移動中はカメラがキャラクターを追従して回転
  ↓
移動を止める
  ↓
カメラ回転がスムージングで元の角度に戻ろうとする
  ↓
キャラクターの向きが変わったように見える
```

### 修正後の動作

**症状1の解消:**
```
CameraLockAreaに進入
  ↓
カメラ位置: lockedCameraRotation (30, 180, 0) で計算
カメラ回転: Quaternion.Euler(lockedCameraRotation)
  ↓
位置と回転が一貫
  ↓
キャラクターが意図した位置・角度で正しく表示される
```

**症状2の解消:**
```
キャラクターを移動
  ↓
カメラ位置: lockCameraRotationで計算（固定位置）
カメラ回転: Quaternion.Euler(lockedCameraRotation)（固定角度）
  ↓
移動中も移動後もカメラの角度は固定
  ↓
キャラクターの向きが変わることはない
```

## 関連ファイル

- Assets/Scripts/Camera/CharacterTracker.cs (修正: UpdateCameraPosition()のカメラ回転処理)

## 今後の注意点

### 1. worklogと実装の整合性

**問題:**
- 今回、worklogには正しい実装が記載されていたが、実際のコードには反映されていなかった
- 実装漏れが発生した

**対策:**
- worklogに記載した実装内容を、必ず実際のコードに反映する
- 実装後、worklogと実際のコードを照合して確認する

### 2. カメラ回転処理の理解

**重要な原則:**
- カメラの**位置計算**と**回転設定**は、同じ角度ソース（lockCameraRotation or cameraYaw/cameraPitch）を使用する
- 位置と回転が矛盾すると、想定外の挙動が発生する

### 3. lockCameraRotationの設計思想

**固定カメラの目的:**
- 2Dゲーム風の演出
- カットシーン風の演出
- 謎解きエリアでの特定視点

**実装のポイント:**
- lockCameraRotation == trueの場合、入力は完全に無視（HandleCameraRotation()でreturn）
- カメラ位置も回転も、lockedCameraRotationのみを使用
- プレイヤーの操作は一切反映されない（意図的な設計）

## まとめ

今回の修正により、以下が実現されました：

1. **lockCameraRotationに応じた正しいカメラ回転処理**
   - lockCameraRotation == trueの場合、固定角度を使用
   - lockCameraRotation == falseの場合、LookAt（キャラクターを見る方向）を使用

2. **カメラ位置と回転の一貫性**
   - 位置計算と回転設定の両方で、同じ角度ソースを使用
   - 矛盾がなくなり、正しい動作を実現

3. **バグの解消**
   - キャラクターが想定外の方向に向く問題を解消
   - 逆方向に移動してカーソルを離すと移動前の向きに向き直る問題を解消

これにより、カメラ固定機能が正しく動作するようになり、プレイヤー体験が大幅に向上しました。
