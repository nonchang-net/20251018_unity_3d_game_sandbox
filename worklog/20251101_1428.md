# ワークログ: キャラクター回転処理の改善（ガクガク挙動の修正）

作成日時: 2025-11-01 14:28

## 変更した内容の概要

- GameCharacterManager.csのキャラクター回転処理を`Quaternion.Slerp`から`Quaternion.RotateTowards`に変更しました
- 回転速度の計算方法を「動的回転速度」から「固定回転速度（度/秒）」に変更しました
- rotationSpeedのデフォルト値を10fから360fに変更し、Tooltipで推奨値（180～720）を明記しました
- これにより、WASD移動後にキーを離した際にキャラの向きがおかしくなる問題と、移動中にキャラがガクガクする問題を解消しました

## なぜそのように変更しようと考えたか

- 前回の作業でカメラ固定機能のバグを修正しましたが、キャラクターの向き制御の問題は残っていました
- この問題は元々存在していたもので、以下の症状がありました：
  1. WASD移動後にキーを離した際にキャラの向きがおかしくなる
  2. 移動前に向いていた向きに戻ることがあるが毎回ではない
  3. 移動中にも変な方向を向こうとしてキャラの挙動がガクガクとする
- 原因は、`Quaternion.Slerp`の補間係数が小さく（0.16～0.32）、急激な方向転換時に回転が追いつかないことでした
- また、移動速度に応じて回転速度が変わる「動的回転速度」の仕組みが、予測しにくい挙動を生んでいました

## 実装詳細

### GameCharacterManager.cs の変更

#### rotationSpeedの設定変更（GameCharacterManager.cs:30-31）

**修正前:**
```csharp
[SerializeField] private float rotationSpeed = 10f;
```

**修正後:**
```csharp
[Tooltip("キャラクターの回転速度（度/秒）。推奨値: 180～720")]
[SerializeField] private float rotationSpeed = 360f;
```

**変更点:**
- デフォルト値を10fから360fに変更（36倍速く）
- Tooltipで「度/秒」の単位を明記
- 推奨値として180～720を記載

**理由:**
- `Quaternion.RotateTowards`では、rotationSpeedが「1秒あたり何度回転するか」を表す
- 10f = 1秒で10度回転 → 非常に遅い（18秒で180度）
- 360f = 1秒で360度回転 → 速い（0.5秒で180度）
- 180～720の範囲が適度な回転速度

#### HandleMovementCharacterController()の回転処理修正（GameCharacterManager.cs:350-358）

**修正前:**
```csharp
// キャラクターを移動方向に向ける
float targetAngle = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg;
Quaternion targetRotation = Quaternion.Euler(0f, targetAngle, 0f);
float dynamicRotationSpeed = rotationSpeed * Mathf.Max(1f, currentMoveSpeed / 5f);
targetCharacter.transform.rotation = Quaternion.Slerp(
    targetCharacter.transform.rotation,
    targetRotation,
    dynamicRotationSpeed * Time.deltaTime
);
```

**修正後:**
```csharp
// キャラクターを移動方向に向ける
float targetAngle = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg;
Quaternion targetRotation = Quaternion.Euler(0f, targetAngle, 0f);
// RotateTowardsを使用して、1秒あたりrotationSpeed度の速度で回転
// より直感的で安定した回転制御を実現
targetCharacter.transform.rotation = Quaternion.RotateTowards(
    targetCharacter.transform.rotation,
    targetRotation,
    rotationSpeed * Time.deltaTime
);
```

**変更点:**
1. `dynamicRotationSpeed`の計算を削除
2. `Quaternion.Slerp`を`Quaternion.RotateTowards`に変更
3. 第3引数を`rotationSpeed * Time.deltaTime`に変更（度/秒 → 度/フレーム）

#### HandleMovementRigidbody()の回転処理修正（GameCharacterManager.cs:439-447）

**CharacterController実装と同様の修正を適用**

## 問題の原因

### 1. Quaternion.Slerpの補間係数が小さい

**修正前の計算:**
```csharp
float dynamicRotationSpeed = rotationSpeed * Mathf.Max(1f, currentMoveSpeed / 5f);
// rotationSpeed = 10f, walkSpeed = 3f の場合:
// dynamicRotationSpeed = 10f * 1f = 10f
// Slerp第3引数 = 10f * 0.016 (60fps) = 0.16
```

**問題点:**
- Quaternion.Slerpの第3引数が0.16は、「現在の回転から目標回転への16%を補間」という意味
- 角度差が大きい場合（例: 180度）、1フレームで28.8度しか回転しない（180 * 0.16 = 28.8）
- 180度回転するには約6フレーム必要（60fps なら 0.1秒）
- しかし、移動中にカメラを回転させると、毎フレーム目標角度が変わるため、回転が追いつかない
- 結果として、キャラクターがガクガクする

### 2. 動的回転速度の予測困難性

**修正前の動的回転速度:**
```csharp
float dynamicRotationSpeed = rotationSpeed * Mathf.Max(1f, currentMoveSpeed / 5f);
```

**問題点:**
- walkSpeed = 3f → dynamicRotationSpeed = 10f * 1f = 10f
- runSpeed = 10f → dynamicRotationSpeed = 10f * 2f = 20f
- 移動速度に応じて回転速度が変わるため、プレイヤーの操作感が一定でない
- 歩行時は回転が遅く、走行時は回転が速いため、違和感がある

### 3. 急激な方向転換時の挙動

**症状:**
- カメラを回転させながら移動すると、moveDirectionが毎フレーム変わる
- キャラクターは常に新しい目標角度に向かって回転しようとする
- しかし、Quaternion.Slerpの補間が追いつかないため、常に「遅れている」状態になる
- 結果として、キャラクターがガクガクしたり、変な方向を向いたりする

## 修正後の動作

### Quaternion.RotateTowardsの特徴

**Quaternion.RotateTowards(from, to, maxDegreesDelta):**
- fromからtoへ、最大maxDegreesDelta度回転する
- maxDegreesDeltaを超えて回転することはない
- 「1秒あたり何度回転するか」を直感的に指定できる

**修正後の計算:**
```csharp
rotationSpeed = 360f（度/秒）
maxDegreesDelta = 360f * 0.016 (60fps) = 5.76度/フレーム

180度回転する場合:
180 / 5.76 = 31.25フレーム = 約0.52秒（60fpsの場合）
```

**利点:**
1. **一定の回転速度**: 移動速度に関係なく、常に360度/秒で回転
2. **予測可能**: プレイヤーの操作感が一定
3. **追従性向上**: 急激な方向転換時も、一定速度で確実に回転する
4. **ガクガクしない**: 回転が途中で止まることがなく、滑らかに回転

### rotationSpeedの推奨値

| 値 | 180度回転にかかる時間 | 用途 |
|----|----------------------|------|
| 180f | 1.0秒 | ゆっくり回転（アクションRPG風） |
| 360f | 0.5秒 | 適度な回転（推奨） |
| 540f | 0.33秒 | 速い回転（アクションゲーム風） |
| 720f | 0.25秒 | 非常に速い回転（格闘ゲーム風） |

**推奨値: 360f**
- 0.5秒で180度回転するため、プレイヤーの操作に追従しやすい
- 速すぎず遅すぎず、自然な回転速度
- カメラを回転させながら移動しても、ガクガクしない

## データフロー

### 移動中のキャラクター回転フロー（修正後）

```
プレイヤーがWASDを入力
  ↓
GameInputManager.OnMove(Vector2 input)
  ↓
GameCharacterManager.SetMovementInput(input)
  ↓
HandleMovementRigidbody() または HandleMovementCharacterController()
  ↓
カメラの向きを基準に移動方向を計算
  ├─ cameraForward = CharacterTracker.GetCameraForward()
  ├─ cameraRight = CharacterTracker.GetCameraRight()
  └─ moveDirection = (cameraForward * inputZ + cameraRight * inputX).normalized
  ↓
移動方向からターゲット角度を計算
  ├─ targetAngle = Atan2(moveDirection.x, moveDirection.z) * Rad2Deg
  └─ targetRotation = Quaternion.Euler(0f, targetAngle, 0f)
  ↓
Quaternion.RotateTowardsで回転
  ├─ maxDegreesDelta = rotationSpeed * Time.deltaTime
  ├─ 例: 360f * 0.016 = 5.76度/フレーム
  └─ transform.rotation = RotateTowards(current, target, 5.76度)
  ↓
結果: 毎フレーム最大5.76度ずつ回転
  → 一定速度で滑らかに回転
  → ガクガクしない
```

### カメラ回転中の挙動（修正後）

```
プレイヤーがマウスでカメラを回転
  ↓
CharacterTracker.HandleCameraRotation()
  ├─ cameraYaw += lookInput.x
  └─ cameraPitch -= lookInput.y
  ↓
CharacterTracker.GetCameraForward()の値が変化
  ↓
GameCharacterManager.HandleMovement*()
  ↓
moveDirectionが新しい値に更新（毎フレーム変わる）
  ↓
targetRotationが新しい値に更新（毎フレーム変わる）
  ↓
Quaternion.RotateTowardsで回転
  ├─ 毎フレーム最大5.76度ずつ回転
  └─ 目標角度が変わっても、一定速度で追従
  ↓
結果: カメラを回転させながら移動しても、滑らかに回転
  → ガクガクしない
  → 常に移動方向を向く
```

## 技術的なポイント

### 1. Quaternion.SlerpとQuaternion.RotateTowardsの違い

**Quaternion.Slerp(from, to, t):**
- 球面線形補間
- `t`は補間係数（0.0 ～ 1.0）
- `t = 0.5`の場合、fromとtoの中間角度になる
- 角度差に応じて回転速度が変わる（角度差が小さいと遅く、大きいと速い）

**Quaternion.RotateTowards(from, to, maxDegreesDelta):**
- 最大角度制限付き回転
- `maxDegreesDelta`は最大回転角度（度）
- 角度差に関係なく、常に一定速度で回転
- `maxDegreesDelta = 5.76`の場合、毎フレーム最大5.76度回転

**使い分け:**
- **Slerp**: アニメーション補間、カメラの滑らかな移動など
- **RotateTowards**: キャラクターの向き制御、砲台の回転など

### 2. 回転速度の計算

**修正前（Slerp）:**
```csharp
dynamicRotationSpeed = rotationSpeed * Mathf.Max(1f, currentMoveSpeed / 5f);
slerpT = dynamicRotationSpeed * Time.deltaTime;
// rotationSpeed = 10f, walkSpeed = 3f, Time.deltaTime = 0.016 の場合:
// slerpT = 10f * 1f * 0.016 = 0.16
// 意味: 現在の回転から目標回転への16%を補間
```

**修正後（RotateTowards）:**
```csharp
maxDegreesDelta = rotationSpeed * Time.deltaTime;
// rotationSpeed = 360f, Time.deltaTime = 0.016 の場合:
// maxDegreesDelta = 360f * 0.016 = 5.76度
// 意味: 毎フレーム最大5.76度回転
```

**より直感的:**
- Slerpの場合、「16%補間」と言われてもピンとこない
- RotateTowardsの場合、「毎フレーム5.76度回転」は直感的に理解しやすい
- 「1秒で360度回転」も直感的

### 3. フレームレート非依存

**どちらもTime.deltaTimeを使用しているため、フレームレート非依存:**

**60fps（Time.deltaTime = 0.016）:**
- maxDegreesDelta = 360f * 0.016 = 5.76度/フレーム
- 180度回転 = 31.25フレーム = 0.52秒

**30fps（Time.deltaTime = 0.033）:**
- maxDegreesDelta = 360f * 0.033 = 11.88度/フレーム
- 180度回転 = 15.15フレーム = 0.50秒

**結果:**
- フレームレートが変わっても、回転にかかる時間は約0.5秒で一定
- ゲームの品質が一定

### 4. Rigidbody.freezeRotationとの関係

**233行目:**
```csharp
characterRigidbody.freezeRotation = true; // 回転を凍結
```

**意味:**
- 物理エンジンによる回転を無効化
- 衝突時に回転しない
- transform.rotationを直接変更することは可能

**今回の修正:**
- transform.rotationを直接変更する実装は変更なし
- Quaternion.RotateTowardsに変更しても、transform.rotationを直接変更している
- freezeRotation = trueの場合、この方法が正しい

**注意点:**
- Rigidbody.MoveRotation()はfreezeRotation = trueの場合、効果がない
- transform.rotationを直接変更するのが正しいアプローチ

## 検証方法

### テストケース1: 通常移動時の回転

**手順:**
1. キャラクターを前進（W）
2. 右に移動（D）
3. 後退（S）
4. 左に移動（A）

**期待結果:**
- キャラクターは移動方向に滑らかに回転する
- ガクガクしない
- 一定の速度で回転する

### テストケース2: カメラ回転中の移動

**手順:**
1. キャラクターを前進（W）しながらマウスでカメラを回転

**期待結果:**
- キャラクターは常にカメラの前方向（移動方向）を向く
- カメラを回転させても、キャラクターが滑らかに回転する
- ガクガクしない

### テストケース3: 急激な方向転換

**手順:**
1. 前進（W）
2. 即座に後退（S）に切り替え

**期待結果:**
- キャラクターは180度回転する
- 回転にかかる時間は約0.5秒（rotationSpeed = 360fの場合）
- 滑らかに回転し、途中で止まらない

### テストケース4: 移動停止時

**手順:**
1. 前進（W）
2. キーを離す

**期待結果:**
- キャラクターは現在の向きを維持する
- 移動前の向きに戻らない
- 停止後も向きがおかしくならない

## 修正前後の比較

### 修正前の問題

**症状1: 移動後にキーを離すと向きがおかしくなる**
```
前進（W）→ キャラは前を向く
  ↓
キーを離す → 回転処理が実行されない（停止時はelseブロック）
  ↓
再度前進（W）→ 前回のmoveDirectionが残っている可能性
  ↓
Slerp補間が追いつかず、ガクガクする
```

**症状2: 移動中にガクガクする**
```
カメラを回転させながら移動
  ↓
moveDirectionが毎フレーム変わる
  ↓
Slerp補間が追いつかない（補間係数0.16は遅い）
  ↓
キャラクターが常に「遅れている」状態
  ↓
ガクガクする
```

### 修正後の動作

**症状1の解消:**
```
前進（W）→ キャラは前を向く（360度/秒で回転）
  ↓
キーを離す → 現在の向きを維持
  ↓
再度前進（W）→ 新しいmoveDirectionに向かって360度/秒で回転
  ↓
0.5秒で180度回転（速い）
  ↓
滑らかに回転、ガクガクしない
```

**症状2の解消:**
```
カメラを回転させながら移動
  ↓
moveDirectionが毎フレーム変わる
  ↓
RotateTowardsで一定速度で追従（360度/秒）
  ↓
目標角度が変わっても、確実に追従
  ↓
滑らかに回転、ガクガクしない
```

## 利点

### 1. 操作感の向上

**修正前:**
- 回転が遅く、操作に対する反応が鈍い
- カメラを回転させながら移動すると、キャラがガクガクする
- 予測しにくい動き

**修正後:**
- 回転が速く、操作に対する反応が良い
- カメラを回転させても、滑らかに追従
- 予測可能で一定の動き

### 2. コードの可読性向上

**修正前:**
```csharp
float dynamicRotationSpeed = rotationSpeed * Mathf.Max(1f, currentMoveSpeed / 5f);
targetCharacter.transform.rotation = Quaternion.Slerp(
    targetCharacter.transform.rotation,
    targetRotation,
    dynamicRotationSpeed * Time.deltaTime
);
```
- dynamicRotationSpeedの計算が複雑
- Slerpの第3引数が何を意味するか分かりにくい

**修正後:**
```csharp
targetCharacter.transform.rotation = Quaternion.RotateTowards(
    targetCharacter.transform.rotation,
    targetRotation,
    rotationSpeed * Time.deltaTime
);
```
- シンプルで分かりやすい
- rotationSpeed * Time.deltaTime = 度/フレーム（直感的）

### 3. パラメータ調整の容易性

**修正前:**
- rotationSpeed = 10f がどの程度の速度か分かりにくい
- 動的回転速度の計算式を理解する必要がある

**修正後:**
- rotationSpeed = 360f = 1秒で360度回転（直感的）
- Inspector上で簡単に調整可能
- Tooltipで推奨値を提示

## 注意点

### 1. 既存のrotationSpeed設定値

**問題:**
- 既存のプロジェクトでrotationSpeed = 10fに設定されている場合、修正後は非常に遅くなる
- 10f = 1秒で10度回転（18秒で180度）

**対策:**
- デフォルト値を360fに変更
- Tooltipで推奨値（180～720）を記載
- Unity Inspectorで手動で調整可能

### 2. Rigidbody実装の回転制御

**現状:**
- Update()でtransform.rotationを直接変更
- freezeRotation = trueなので、これが正しいアプローチ

**より良いアプローチ:**
- FixedUpdate()でRigidbody.MoveRotation()を使用（ただし、freezeRotation = falseの場合のみ）
- 現状はfreezeRotation = trueなので、transform.rotation直接変更が正しい

**今後の改善案:**
- Rigidbody実装の場合、回転処理をFixedUpdate()に移動
- ただし、大幅な変更になるため、今回は対応しない

### 3. 停止時の回転処理

**現状:**
- 停止時（inputDirection.magnitude < 0.1f）は回転処理を実行しない
- キャラクターの向きは停止時に固定される

**問題:**
- カメラを回転させても、キャラクターは回転しない
- これは意図した仕様

**今後の改善案:**
- 停止時もカメラの向きに合わせてキャラクターを回転させる
- ただし、これは仕様変更になるため、今回は対応しない

## 関連ファイル

- Assets/Scripts/GameManager/GameCharacterManager.cs (修正: 回転処理をQuaternion.RotateTowardsに変更、rotationSpeed調整)

## 今後の改善案

### 1. Rigidbody回転処理のFixedUpdate移動

**現状の問題:**
- Rigidbody実装の場合、Update()で回転処理を実行している
- 移動処理（linearVelocity設定）もUpdate()で実行している
- 本来はFixedUpdate()で実行すべき

**改善案:**
```csharp
// 目標回転角度をUpdate()で計算
private Quaternion targetRotation;

void Update()
{
    // 入力から目標回転角度を計算
    if (inputDirection.magnitude >= 0.1f)
    {
        float targetAngle = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg;
        targetRotation = Quaternion.Euler(0f, targetAngle, 0f);
    }
}

void FixedUpdate()
{
    // Rigidbodyの回転を適用
    if (implementationType == CharacterImplementationType.RigidbodyAndCollider)
    {
        targetCharacter.transform.rotation = Quaternion.RotateTowards(
            targetCharacter.transform.rotation,
            targetRotation,
            rotationSpeed * Time.fixedDeltaTime
        );
    }
}
```

**利点:**
- 物理エンジンとの同期が正確になる
- より安定した挙動

**注意:**
- 大幅な変更になる
- CharacterController実装はUpdate()のまま

### 2. 停止時のカメラ追従回転

**現状:**
- 停止時は回転処理を実行しない
- キャラクターの向きは固定される

**改善案:**
```csharp
else
{
    // 停止時の処理
    isCrouched = false;
    playerSpeed = Mathf.Lerp(playerSpeed, 0f, Time.deltaTime * 10f);

    // オプション: 停止時もカメラの向きに合わせて回転
    if (enableRotateTowardsCameraWhenIdle)
    {
        Vector3 cameraForward = gameManager.CharacterTracker.GetCameraForward();
        float targetAngle = Mathf.Atan2(cameraForward.x, cameraForward.z) * Mathf.Rad2Deg;
        Quaternion targetRotation = Quaternion.Euler(0f, targetAngle, 0f);
        targetCharacter.transform.rotation = Quaternion.RotateTowards(
            targetCharacter.transform.rotation,
            targetRotation,
            rotationSpeed * 0.5f * Time.deltaTime // 停止時は半分の速度
        );
    }
}
```

**利点:**
- 停止時もカメラの向きに合わせてキャラクターが回転
- より自然な挙動

**注意:**
- 仕様変更になる
- ユーザーの好みに合わせてオン/オフ可能にする

### 3. 回転速度のアニメーション連携

**改善案:**
```csharp
// アニメーターに回転速度を渡す
if (animator != null)
{
    float rotationVelocity = Quaternion.Angle(lastRotation, targetCharacter.transform.rotation) / Time.deltaTime;
    animator.SetFloat("RotationSpeed", rotationVelocity);
}
lastRotation = targetCharacter.transform.rotation;
```

**利点:**
- 回転速度に応じてアニメーションを調整可能
- 急激な方向転換時に専用のアニメーションを再生

## まとめ

今回の修正により、以下が実現されました：

1. **キャラクター回転処理の改善**
   - `Quaternion.Slerp`から`Quaternion.RotateTowards`に変更
   - より直感的で安定した回転制御を実現

2. **回転速度の最適化**
   - デフォルト値を10fから360fに変更（36倍速く）
   - 推奨値（180～720）をTooltipに記載

3. **バグの解消**
   - WASD移動後にキーを離した際にキャラの向きがおかしくなる問題を解消
   - 移動中にキャラがガクガクする問題を解消
   - カメラを回転させながら移動しても、滑らかに追従

4. **操作感の向上**
   - 一定の回転速度で予測可能な動き
   - カメラ操作に対する反応が良い
   - より自然なキャラクター制御

これにより、プレイヤー体験が大幅に向上しました。
