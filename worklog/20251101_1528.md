# ワークログ: カメラ方向計算の根本的な修正（カニ歩き・画面外問題の解消）

作成日時: 2025-11-01 15:28

## 変更した内容の概要

- CharacterTrackerの`GetCameraForward()`と`GetCameraRight()`を、カメラの実際の回転（`transform.forward/right`）ではなく、`cameraYaw`から直接計算するように変更しました
- CharacterTrackerの通常時（`lockCameraRotation == false`）のカメラ回転処理で、`Quaternion.Slerp`による遅延を廃止し、即座に回転するように変更しました
- これにより、前回の修正（`Quaternion.RotateTowards`導入）で発生したカニ歩き、意図した方向を向かない、カメラズーム距離で何も映らなくなる問題を解消しました

## なぜそのように変更しようと考えたか

- 前回の修正（`Quaternion.RotateTowards`導入）後、カニ歩きや意図した方向を向かないという問題が発生しました
- 原因を調査したところ、以下の問題が判明しました：
  1. **カメラの回転遅延**: `Quaternion.Slerp`でカメラの回転を遅延させていた
  2. **移動方向計算の不正確性**: `GetCameraForward()`が遅延した`transform.forward`を返していた
  3. **位置と回転の不整合**: カメラ位置は`cameraYaw`から計算、回転は遅延した`transform.rotation`を使用
- これらの問題により、キャラクターの移動方向計算が不正確になり、カニ歩きや画面外問題が発生していました

## 実装詳細

### CharacterTracker.cs の変更

#### GetCameraForward()の修正（CharacterTracker.cs:242-256）

**修正前:**
```csharp
public Vector3 GetCameraForward()
{
    Vector3 forward = transform.forward;
    forward.y = 0f;
    return forward.normalized;
}
```

**修正後:**
```csharp
/// <summary>
/// カメラの前方向ベクトルを取得（Y成分を除く）
/// カメラの実際の回転ではなく、cameraYawから直接計算することで、
/// カメラ回転の遅延に影響されない正確な移動方向を提供
/// </summary>
public Vector3 GetCameraForward()
{
    // lockCameraRotationの場合は固定角度、通常時はcameraYawを使用
    float yaw = lockCameraRotation ? lockedCameraRotation.y : cameraYaw;

    // yaw角度から前方向ベクトルを計算
    float yawRad = yaw * Mathf.Deg2Rad;
    Vector3 forward = new Vector3(Mathf.Sin(yawRad), 0f, Mathf.Cos(yawRad));
    return forward.normalized;
}
```

**変更点:**
1. `transform.forward`を使用する代わりに、`cameraYaw`（または`lockedCameraRotation.y`）から直接計算
2. 三角関数を使用して、yaw角度から前方向ベクトルを計算
   - X成分: `Mathf.Sin(yawRad)`（東西方向）
   - Z成分: `Mathf.Cos(yawRad)`（南北方向）
3. `lockCameraRotation`の状態に応じて、適切な角度ソースを選択

**数学的な根拠:**
- yaw角度0度 = 北向き（Z+方向）
- yaw角度90度 = 東向き（X+方向）
- 前方向ベクトル = (sin(yaw), 0, cos(yaw))
- これはUnityの座標系における標準的な角度→方向ベクトル変換

#### GetCameraRight()の修正（CharacterTracker.cs:258-272）

**修正前:**
```csharp
public Vector3 GetCameraRight()
{
    Vector3 right = transform.right;
    right.y = 0f;
    return right.normalized;
}
```

**修正後:**
```csharp
/// <summary>
/// カメラの右方向ベクトルを取得（Y成分を除く）
/// カメラの実際の回転ではなく、cameraYawから直接計算することで、
/// カメラ回転の遅延に影響されない正確な移動方向を提供
/// </summary>
public Vector3 GetCameraRight()
{
    // lockCameraRotationの場合は固定角度、通常時はcameraYawを使用
    float yaw = lockCameraRotation ? lockedCameraRotation.y : cameraYaw;

    // yaw角度から右方向ベクトルを計算
    float yawRad = yaw * Mathf.Deg2Rad;
    Vector3 right = new Vector3(Mathf.Cos(yawRad), 0f, -Mathf.Sin(yawRad));
    return right.normalized;
}
```

**変更点:**
1. `transform.right`を使用する代わりに、`cameraYaw`から直接計算
2. 右方向ベクトル = 前方向ベクトルを90度右に回転
   - X成分: `Mathf.Cos(yawRad)`
   - Z成分: `-Mathf.Sin(yawRad)`

**数学的な根拠:**
- 右方向 = 前方向を90度右（時計回り）に回転
- 前方向が(sin(yaw), 0, cos(yaw))の場合
- 右方向は(cos(yaw), 0, -sin(yaw))

#### UpdateCameraPosition()のカメラ回転処理修正（CharacterTracker.cs:225-240）

**修正前:**
```csharp
// カメラの回転を設定
if (lockCameraRotation)
{
    // カメラ回転が固定されている場合、指定された角度を使用
    Quaternion targetRotation = Quaternion.Euler(lockedCameraRotation);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
else
{
    // カメラの回転をスムージング（旧実装: transform.LookAt(targetPosition);）
    Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
```

**修正後:**
```csharp
// カメラの回転を設定
if (lockCameraRotation)
{
    // カメラ回転が固定されている場合、指定された角度を使用してスムーズに回転
    Quaternion targetRotation = Quaternion.Euler(lockedCameraRotation);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
else
{
    // 通常時は即座にキャラクターを見る方向に回転（遅延なし）
    // Slerpで遅延させるとキャラクターの移動方向計算が不正確になり、
    // カメラ距離が大きい場合にキャラクターが画面外になる問題が発生する
    Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
    transform.rotation = targetRotation;
}
```

**変更点:**
1. `lockCameraRotation == false`の場合、`Quaternion.Slerp`を使用せず、即座に`targetRotation`を設定
2. これにより、カメラは常に正確にキャラクターを見る方向を向く
3. `lockCameraRotation == true`の場合は、引き続き`Quaternion.Slerp`でスムーズに回転（演出のため）

**理由:**
- 通常時のカメラは、プレイヤーの視点操作に即座に反応すべき
- Slerpで遅延させると、カメラの向きがずれ、キャラクターが画面外になる
- 特にカメラ距離が大きい場合、わずかな角度のずれでも大きな位置のずれになる

## 問題の原因（詳細分析）

### 問題1: カニ歩きの発生メカニズム

**処理フロー（修正前）:**
```
1. プレイヤーがマウスでカメラを回転
   ↓
2. cameraYaw が即座に更新（例: 0° → 90°）
   ↓
3. UpdateCameraPosition()でカメラ位置を計算
   - yaw = cameraYaw = 90°
   - カメラ位置を計算（90度の位置）
   ↓
4. カメラの回転をSlerpで遅延設定
   - targetRotation = LookRotation(...)
   - transform.rotation = Slerp(current, target, 0.24)
   - 実際の回転: 0° → 21.6°（90°の24%）
   ↓
5. GetCameraForward()が呼ばれる
   - return transform.forward（21.6度方向）
   ↓
6. GameCharacterManagerで移動方向を計算
   - moveDirection = (cameraForward * inputZ + cameraRight * inputX)
   - cameraForwardは21.6度方向（本来は90度であるべき）
   ↓
7. キャラクターが21.6度方向を向いて移動
   - プレイヤーの意図: 90度方向（真東）
   - 実際の移動: 21.6度方向（北東）
   ↓
8. カニ歩き発生！
```

**根本原因:**
- カメラの位置計算は`cameraYaw = 90°`を使用
- カメラの回転は遅延して`21.6°`
- `GetCameraForward()`は遅延した回転から計算
- キャラクターの移動方向が不正確

### 問題2: カメラズーム距離で何も映らなくなる

**処理フロー（修正前）:**
```
1. カメラ距離を大きく設定（例: cameraDistance = 20）
   ↓
2. カメラ位置を計算
   - offset = (sin(yaw), sin(pitch), cos(yaw)) * 20
   - カメラはキャラクターから20m離れた位置
   ↓
3. カメラの回転をSlerpで遅延設定
   - targetRotation = LookRotation(targetPosition - cameraPosition)
   - transform.rotation = Slerp(current, target, 0.24)
   ↓
4. カメラが完全にキャラクターを向いていない
   - わずかな角度のずれ（例: 5度）でも、20m離れた位置では大きなずれ
   - tan(5°) * 20m = 1.75m のずれ
   ↓
5. キャラクターが画面外になる
```

**根本原因:**
- カメラ距離が大きいと、わずかな角度のずれでも大きな位置のずれになる
- Slerpによる遅延で、カメラがキャラクターを完全に向いていない

## 修正後の動作

### 修正後の処理フロー

```
1. プレイヤーがマウスでカメラを回転
   ↓
2. cameraYaw が即座に更新（例: 0° → 90°）
   ↓
3. UpdateCameraPosition()でカメラ位置を計算
   - yaw = cameraYaw = 90°
   - カメラ位置を計算（90度の位置）
   ↓
4. カメラの回転を即座に設定（Slerpなし）
   - targetRotation = LookRotation(...)
   - transform.rotation = targetRotation（遅延なし）
   ↓
5. GetCameraForward()が呼ばれる
   - yaw = cameraYaw = 90°（lockCameraRotationに応じて選択）
   - return (sin(90°), 0, cos(90°)) = (1, 0, 0)（真東）
   ↓
6. GameCharacterManagerで移動方向を計算
   - moveDirection = (cameraForward * inputZ + cameraRight * inputX)
   - cameraForwardは90度方向（正確）
   ↓
7. キャラクターが90度方向を向いて移動
   - プレイヤーの意図: 90度方向（真東）
   - 実際の移動: 90度方向（真東）
   ↓
8. 正常動作！
```

**改善点:**
1. **GetCameraForward()がcameraYawから直接計算**
   - カメラの実際の回転に影響されない
   - 常に正確な移動方向を提供

2. **カメラの回転が即座に設定**
   - カメラは常にキャラクターを正確に見る
   - カメラ距離が大きくても画面外にならない

### lockCameraRotation時の動作

```
CameraLockAreaに進入（lockCameraRotation = true）
  ↓
GetCameraForward()が呼ばれる
  ↓
yaw = lockedCameraRotation.y（固定角度）
  ↓
return (sin(yaw), 0, cos(yaw))
  ↓
キャラクターは固定角度を基準に移動
  ↓
カメラもQuaternion.Slerpでスムーズに固定角度に回転
```

**lockCameraRotation時の特徴:**
- GetCameraForward()は`lockedCameraRotation.y`から計算
- カメラの回転はSlerpでスムーズに遷移（演出のため）
- 移動方向は固定角度を基準に正確に計算される

## データフロー図

### 通常時（lockCameraRotation == false）

**修正前:**
```
プレイヤーのマウス操作
  ↓
cameraYaw更新（即座）
  ↓
┌─────────────────┐
│ カメラ位置計算  │ ← cameraYaw使用
└─────────────────┘
  ↓
┌─────────────────┐
│ カメラ回転設定  │ ← Slerp（遅延）
└─────────────────┘
  ↓ transform.rotation（遅延）
┌─────────────────┐
│GetCameraForward │ ← transform.forward使用
└─────────────────┘
  ↓ 不正確な方向ベクトル
┌─────────────────┐
│移動方向計算     │
└─────────────────┘
  ↓
カニ歩き発生！
```

**修正後:**
```
プレイヤーのマウス操作
  ↓
cameraYaw更新（即座）
  ↓
┌─────────────────┐
│ カメラ位置計算  │ ← cameraYaw使用
└─────────────────┘
  ↓
┌─────────────────┐
│ カメラ回転設定  │ ← 即座に設定（遅延なし）
└─────────────────┘
  ↓ cameraYaw（常に正確）
┌─────────────────┐
│GetCameraForward │ ← cameraYawから直接計算
└─────────────────┘
  ↓ 正確な方向ベクトル
┌─────────────────┐
│移動方向計算     │
└─────────────────┘
  ↓
正常動作！
```

## 技術的なポイント

### 1. 三角関数による方向ベクトル計算

**前方向ベクトル:**
```csharp
float yawRad = yaw * Mathf.Deg2Rad;
Vector3 forward = new Vector3(Mathf.Sin(yawRad), 0f, Mathf.Cos(yawRad));
```

**数学的な意味:**
- Unityの座標系: X軸=東西、Z軸=南北、Y軸=上下
- yaw = 0°: 北向き (0, 0, 1)
- yaw = 90°: 東向き (1, 0, 0)
- yaw = 180°: 南向き (0, 0, -1)
- yaw = 270°: 西向き (-1, 0, 0)

**一般式:**
- X成分 = sin(yaw): 東西方向の成分
- Z成分 = cos(yaw): 南北方向の成分

**右方向ベクトル:**
```csharp
Vector3 right = new Vector3(Mathf.Cos(yawRad), 0f, -Mathf.Sin(yawRad));
```

**導出:**
- 右方向 = 前方向を90度右（時計回り）に回転
- 回転行列を適用:
  - X' = cos(90°) * X - sin(90°) * Z = 0 * sin(yaw) - 1 * cos(yaw) = -cos(yaw)
  - Z' = sin(90°) * X + cos(90°) * Z = 1 * sin(yaw) + 0 * cos(yaw) = sin(yaw)
- しかし、Unityの座標系では右方向は時計回りなので、Zの符号を反転
- 結果: (cos(yaw), 0, -sin(yaw))

### 2. カメラ回転の即座設定 vs Slerp遅延

**即座設定（修正後）:**
```csharp
transform.rotation = targetRotation;
```

**利点:**
- プレイヤーの視点操作に即座に反応
- カメラは常にキャラクターを正確に見る
- カメラ距離が大きくても画面外にならない

**欠点:**
- カメラの回転が急激に変化する場合、若干カクつく可能性
- しかし、カメラの位置はスムージングされているため、実際にはそれほど目立たない

**Slerp遅延（修正前）:**
```csharp
transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * positionSmoothSpeed);
```

**利点:**
- カメラの回転が滑らかに変化
- 視覚的に柔らかい印象

**欠点:**
- カメラの向きがずれる
- GetCameraForward()が不正確な値を返す
- キャラクターの移動方向が不正確になる
- カメラ距離が大きい場合、キャラクターが画面外になる

**結論:**
- 通常時は即座設定が適切
- lockCameraRotation時はSlerp遅延で演出を強調

### 3. lockCameraRotationの判定

```csharp
float yaw = lockCameraRotation ? lockedCameraRotation.y : cameraYaw;
```

**理由:**
- lockCameraRotation == trueの場合、cameraYawは更新されない（HandleCameraRotation()でreturn）
- したがって、lockedCameraRotation.yを使用する必要がある
- lockCameraRotation == falseの場合、cameraYawが正しく更新されている

**重要性:**
- GetCameraForward()とGetCameraRight()で一貫した角度ソースを使用
- UpdateCameraPosition()のカメラ位置計算と同じ角度を使用
- これにより、カメラの位置と移動方向が一貫する

## 検証方法

### テストケース1: 通常移動（カニ歩き防止）

**手順:**
1. キャラクターを前進（W）
2. マウスでカメラを90度右に回転
3. そのまま前進（W）

**期待結果（修正後）:**
- キャラクターは常にカメラの前方向（回転後の方向）を向く
- カニ歩きしない
- 移動方向とキャラクターの向きが一致

### テストケース2: カメラズーム距離

**手順:**
1. Tracking SettingでcameraDistanceを大きく設定（例: 20）
2. キャラクターを移動

**期待結果（修正後）:**
- キャラクターが画面に映る
- カメラは常にキャラクターを見ている
- カメラ距離が大きくても正常動作

### テストケース3: CameraLockArea

**手順:**
1. CameraLockAreaに進入（lockCameraRotation = true）
2. キャラクターを移動

**期待結果（修正後）:**
- GetCameraForward()はlockedCameraRotation.yから計算
- キャラクターは固定角度を基準に移動
- カメラはスムーズに固定角度に回転

### テストケース4: カメラ回転中の移動

**手順:**
1. 前進（W）しながらマウスでカメラを連続的に回転

**期待結果（修正後）:**
- キャラクターは常にカメラの前方向を向く
- 移動方向が正確
- ガクガクしない

## 修正前後の比較

### 修正前の問題

| 問題 | 原因 | 症状 |
|------|------|------|
| カニ歩き | GetCameraForward()が遅延したtransform.forwardを返す | キャラクターの移動方向とカメラの向きが一致しない |
| 意図した方向を向かない | カメラ回転の遅延により、移動方向計算が不正確 | 720や360に設定しても改善しない |
| カメラズーム距離で何も映らない | カメラの回転がSlerpで遅延し、キャラクターを正確に見ていない | カメラ距離が大きいと顕著 |

### 修正後の改善

| 項目 | 改善内容 | 効果 |
|------|---------|------|
| GetCameraForward() | cameraYawから直接計算 | 常に正確な移動方向を提供 |
| GetCameraRight() | cameraYawから直接計算 | 常に正確な移動方向を提供 |
| カメラ回転（通常時） | 即座に設定（Slerpなし） | キャラクターを常に正確に見る |
| カメラ回転（ロック時） | Slerpでスムーズに回転 | 演出を維持 |

## 利点

### 1. 正確な移動方向計算

- GetCameraForward()とGetCameraRight()がcameraYawから直接計算されるため、カメラの実際の回転に影響されない
- キャラクターは常にプレイヤーの意図した方向に移動

### 2. カメラ距離に依存しない動作

- カメラの回転を即座に設定することで、カメラは常にキャラクターを正確に見る
- カメラ距離が大きくても、キャラクターが画面外にならない

### 3. lockCameraRotation時の一貫性

- GetCameraForward()がlockedCameraRotation.yから計算されるため、固定角度を基準とした正確な移動方向を提供
- カメラの回転はSlerpでスムーズに遷移し、視覚的な演出を維持

### 4. コードの一貫性

- カメラの位置計算とGetCameraForward()で同じ角度ソース（cameraYawまたはlockedCameraRotation.y）を使用
- 処理の一貫性が向上

## 注意点

### 1. カメラ回転の視覚的な滑らかさ

**問題:**
- 通常時のカメラ回転が即座に設定されるため、急激な視点変更時に若干カクつく可能性

**対策:**
- カメラの位置はスムージングされているため、実際にはそれほど目立たない
- プレイヤーの視点操作に即座に反応することが優先

### 2. GetCameraForward()の計算方法の変更

**互換性:**
- 既存のコードで`transform.forward`に依存している箇所があれば、影響を受ける
- しかし、GetCameraForward()とGetCameraRight()は主にGameCharacterManagerで使用されているため、影響は限定的

### 3. lockCameraRotation時の処理

**重要:**
- lockCameraRotation == trueの場合、GetCameraForward()はlockedCameraRotation.yから計算
- lockCameraRotation == falseの場合、GetCameraForward()はcameraYawから計算
- この分岐は、UpdateCameraPosition()のカメラ位置計算と一致している

## 関連ファイル

- Assets/Scripts/Camera/CharacterTracker.cs (修正: GetCameraForward()、GetCameraRight()、UpdateCameraPosition())
- Assets/Scripts/GameManager/GameCharacterManager.cs (前回修正: Quaternion.RotateTowards導入)

## 今後の改善案

### 1. カメラ回転のスムージングオプション

**現状:**
- 通常時: 即座に回転
- ロック時: Slerpで回転

**改善案:**
```csharp
[Header("カメラ回転スムージング設定")]
[SerializeField] private bool enableRotationSmoothing = false;
[SerializeField] private float rotationSmoothSpeed = 20f;

// カメラの回転を設定
if (lockCameraRotation)
{
    // ロック時はスムーズに回転
    Quaternion targetRotation = Quaternion.Euler(lockedCameraRotation);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * positionSmoothSpeed);
}
else if (enableRotationSmoothing)
{
    // オプション: 通常時もスムーズに回転
    Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation,
        Time.deltaTime * rotationSmoothSpeed);
}
else
{
    // デフォルト: 即座に回転
    Quaternion targetRotation = Quaternion.LookRotation(targetPosition - transform.position);
    transform.rotation = targetRotation;
}
```

**利点:**
- ユーザーの好みに応じてカメラ回転のスムージングを有効/無効にできる
- rotationSmoothSpeedを十分大きくすれば、ほぼ即座に回転させることも可能

### 2. GetCameraForward()のキャッシング

**現状:**
- 毎フレームsin/cosを計算

**改善案:**
```csharp
private Vector3 cachedCameraForward;
private Vector3 cachedCameraRight;
private float cachedYaw = float.NaN;

public Vector3 GetCameraForward()
{
    float yaw = lockCameraRotation ? lockedCameraRotation.y : cameraYaw;

    // キャッシュが有効な場合はそれを返す
    if (Mathf.Approximately(yaw, cachedYaw))
    {
        return cachedCameraForward;
    }

    // 計算してキャッシュ
    float yawRad = yaw * Mathf.Deg2Rad;
    cachedCameraForward = new Vector3(Mathf.Sin(yawRad), 0f, Mathf.Cos(yawRad)).normalized;
    cachedYaw = yaw;

    return cachedCameraForward;
}
```

**利点:**
- 同じフレーム内で複数回呼ばれても、計算は1回だけ
- パフォーマンス向上

**注意:**
- マイクロ最適化なので、実際の効果は小さい可能性

## まとめ

今回の修正により、以下が実現されました：

1. **GetCameraForward()とGetCameraRight()の根本的な改善**
   - transform.forward/rightから計算する代わりに、cameraYawから直接計算
   - カメラの回転遅延に影響されない正確な移動方向を提供

2. **カメラ回転処理の最適化**
   - 通常時: 即座に回転（Slerpなし）
   - ロック時: Slerpでスムーズに回転（演出維持）

3. **バグの解消**
   - カニ歩きの解消
   - 意図した方向を向かない問題の解消
   - カメラズーム距離で何も映らなくなる問題の解消

4. **処理の一貫性向上**
   - カメラの位置計算とGetCameraForward()で同じ角度ソース（cameraYaw）を使用
   - lockCameraRotation時も一貫した動作

これにより、前回の修正（Quaternion.RotateTowards導入）と組み合わせて、キャラクターの移動とカメラ制御が正常に動作するようになりました。
