# 作業ログ - 20251102_2102

## 変更内容の概要

- ゲーム初期化ロジックを再編成し、ローディング画面を表示してから各種初期化処理を実行するように変更しました。
- 初期化完了イベント（InitializeFinished）を実装し、入力制御とBGM再生をこのイベントと連動させました。
- UniTaskを活用して非同期初期化処理を実装し、コルーチンベースからasync/awaitベースに移行しました。

## 変更理由

- 稀にゲーム再生時にポーズメニューが半端にフェードした状態で固まる問題が発生していました。
- Unityの再生ショートカット（cmd+P）とポーズトグルのキーバインド（P）が抵触している可能性がありました。
- 初期化が完了する前に入力が有効化されることで、意図しないタイミングでポーズメニューが開いてしまう可能性がありました。
- BGMもゲーム開始直後に再生開始されており、ローディング画面表示中に音が鳴る違和感がありました。

## 実装詳細

### 1. GameStateManager - InitializeFinishedイベントの追加

**GameState.cs**
```csharp
public Subject<Unit> OnInitializeFinished { get; private set; }

// コンストラクタ内
OnInitializeFinished = new Subject<Unit>();
```

**GameStateManager.cs**
```csharp
public void NotifyInitializeFinished()
{
    state.OnInitializeFinished.OnNext(Unit.Default);
}
```

初期化完了を通知するための専用イベントを追加しました。R3のSubjectを使用して、購読者に初期化完了を通知できるようになりました。

### 2. GameUIManager - LoadingView関連の参照追加

```csharp
using NaughtyAttributes;

[Header("Loading View")]
[Required("ローディング画面のGameObjectが必要です")]
[SerializeField] private GameObject loadingView;
public GameObject LoadingView => loadingView;

[Required("ローディング画面のCanvasGroupが必要です")]
[SerializeField] private CanvasGroup loadingViewCanvasGroup;
public CanvasGroup LoadingViewCanvasGroup => loadingViewCanvasGroup;
```

ローディング画面のGameObjectとCanvasGroupへの参照を追加しました。Naughty AttributesのRequiredアトリビュートを使用して、設定漏れを防止しています。

### 3. GameManager - 初期化処理のUniTask化

**Initialize()メソッド**
```csharp
private async UniTask Initialize()
{
    // ローディング画面を表示
    gameUIManager.LoadingView.SetActive(true);
    gameUIManager.LoadingViewCanvasGroup.alpha = 1.0f;

    // キャラクター初期化
    await InitializeCharacterAsync();

    // マネージャー初期化
    await InitializeManagersAsync();

    // 1秒待機
    await UniTask.Delay(TimeSpan.FromSeconds(1));

    // ローディング画面をフェードアウト
    await FadeOutLoadingView();

    // 初期化完了を通知
    stateManager.NotifyInitializeFinished();
}
```

従来のコルーチンベースから、UniTaskのasync/awaitを使用した非同期処理に変更しました。処理の流れが明確になり、可読性が向上しています。

**FadeOutLoadingView()メソッド**
```csharp
private async UniTask FadeOutLoadingView()
{
    float fadeDuration = 0.5f;
    float elapsed = 0f;

    while (elapsed < fadeDuration)
    {
        elapsed += Time.deltaTime;
        float alpha = Mathf.Lerp(1.0f, 0f, elapsed / fadeDuration);
        gameUIManager.LoadingViewCanvasGroup.alpha = alpha;
        await UniTask.Yield();
    }

    gameUIManager.LoadingViewCanvasGroup.alpha = 0f;
    gameUIManager.LoadingView.SetActive(false);
}
```

ローディング画面を0.5秒かけてフェードアウトさせる処理を実装しました。

**InitializeCharacterAsync()とInitializeManagersAsync()**

既存のコルーチン（InitializeCharacter()、InitializeManagers()）をUniTask化しました：
- `yield return null` → `await UniTask.Yield()`
- `IEnumerator` → `async UniTask`

### 4. GameInputManager - 初期化完了まで入力を無効化

```csharp
using R3;
using NaughtyAttributes;

private bool isInitialized = false;
private IDisposable initializeFinishedSubscription;

void Awake()
{
    // Input Actionsを初期化
    inputSystemActions = new InputSystem_Actions();
    inputSystemActionMap = inputSystemActions.Player;
    inputSystemActionMap.AddCallbacks(this);

    // 初期化完了まで入力を無効化
    inputSystemActions?.Disable();
}

void OnEnable()
{
    // 初期化完了後のみ入力を有効化
    if (isInitialized)
    {
        inputSystemActions?.Enable();
    }
}

void Start()
{
    // ... 既存の参照チェック

    // 初期化完了イベントを購読
    initializeFinishedSubscription = gameManager.StateManager.State.OnInitializeFinished.Subscribe(_ =>
    {
        isInitialized = true;
        inputSystemActions?.Enable();
        Debug.Log("GameInputManager: ゲーム初期化完了。入力を有効化しました。");
    });
}

void OnDestroy()
{
    inputSystemActions?.Dispose();
    initializeFinishedSubscription?.Dispose();
}
```

**ポイント:**
- Awake()でInput Actionsを無効化し、初期化完了まで入力を受け付けないようにしました
- OnInitializeFinishedイベントを購読し、初期化完了時に入力を有効化します
- これにより、ローディング中にcmd+Pやその他のキー入力が誤って処理されることを防ぎます

### 5. GameSoundManager - BGM再生タイミングの修正

```csharp
using NaughtyAttributes;

[Required("GameManagerの参照が必要です")]
[SerializeField] private GameManager gameManager;

private IDisposable initializeFinishedSubscription;

private void Awake()
{
    // BGM用AudioSource設定
    bgmAudioSource = gameObject.AddComponent<AudioSource>();
    bgmAudioSource.loop = true;
    bgmAudioSource.volume = bgmVolume * masterVolume;
    RegisterAudioSource(bgmAudioSource, SoundCategory.BGM);

    // BGMクリップを設定（再生はInitializeFinishedイベントで開始）
    if (bgms != null && bgms.Length > 0)
    {
        bgmAudioSource.clip = bgms[0];
    }
    // Play()は呼ばない
}

private void Start()
{
    // ... 既存のイベント購読

    // 初期化完了イベントを購読してBGM再生を開始
    initializeFinishedSubscription = gameManager.StateManager.State.OnInitializeFinished.Subscribe(_ =>
    {
        if (bgmAudioSource != null && bgmAudioSource.clip != null)
        {
            bgmAudioSource.Play();
            Debug.Log("GameSoundManager: ゲーム初期化完了。BGMを再生開始しました。");
        }
    });
}

private void OnDestroy()
{
    // ... 既存の購読解放
    initializeFinishedSubscription?.Dispose();
}
```

**変更内容:**
- Awake()でBGMクリップの設定のみを行い、再生は開始しません
- OnInitializeFinishedイベントを購読し、初期化完了後にBGM再生を開始します
- これにより、ローディング画面表示中にBGMが流れることがなくなります

## 効果

### 初期化シーケンスの明確化

1. **ローディング画面表示**: alpha 1.0で表示
2. **キャラクター初期化**: PlayableCharacterRepositoryの初期化完了を待機
3. **マネージャー初期化**: DebugSheet、CameraManagerなどを初期化
4. **1秒待機**: ユーザーにローディング画面を見せる最小時間を確保
5. **フェードアウト**: 0.5秒かけて滑らかにフェードアウト
6. **初期化完了通知**: OnInitializeFinishedイベントを発火
7. **入力有効化**: GameInputManagerが入力を受け付け開始
8. **BGM再生開始**: GameSoundManagerがBGMを再生開始

### 問題の解決

- **ポーズメニューの固まり問題**: 初期化完了前の入力を無効化することで、意図しないポーズメニュー表示を防止
- **キーバインド抵触**: ローディング中は全ての入力を無効化するため、cmd+Pが誤検出される可能性を排除
- **BGMの違和感**: ローディング完了後にBGMを再生することで、自然なゲーム開始体験を提供

## 技術的なポイント

### UniTaskのasync/await

従来のコルーチンよりも直感的で可読性の高いコードになりました：
- `yield return null` → `await UniTask.Yield()` - 1フレーム待機
- `yield return new WaitForSeconds()` → `await UniTask.Delay()` - 時間待機
- エラーハンドリングがtry-catchで記述可能

### R3のSubjectパターン

InitializeFinishedイベントをR3のSubjectで実装することで：
- 複数の購読者（GameInputManager、GameSoundManager）が独立してイベントを受け取れる
- イベント発行側と購読側の疎結合を実現
- IDisposableによる確実なリソース解放

### Naughty Attributesの活用

- `Required`: 必須参照の設定漏れを防止
- エディタ上で赤く警告表示され、設定ミスを早期発見

## 今後の展開

- ローディング画面の表示時間やフェード時間は調整可能な設定として外部化することも検討できます
- 初期化処理が重くなった場合、プログレスバーの表示も追加できる設計になっています
- OnInitializeFinishedイベントを購読する他のコンポーネントも追加可能です
