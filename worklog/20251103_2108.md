# 作業ログ - 20251103_2108

## 変更内容の概要

- WebGLビルドでのVRM読み込み機能が正常動作しない問題を修正しました。
- VRMUtilityにWebGL対応の`RuntimeOnlyNoThreadAwaitCaller`を実装しました。
- バイトデータから直接VRMを読み込む`LoadVrmFromBytesAsync()`メソッドを追加しました。
- 詳細なデバッグログを追加してWebGLでの問題を特定しやすくしました。

## 変更理由

- Editorでは正常動作するVRM読み込み機能が、WebGLビルドでは動作しない問題が報告されました。
- ファイル選択ダイアログは開くが、VRM選択後に「SendMessage VrmLoadManager OnFileSelected」というログが出るのみで処理が進まない状態でした。
- VRM10Viewerサンプルを調査した結果、WebGL固有の対応が必要であることが判明しました。

## 実装詳細

### 1. VRMUtility - WebGL対応の実装

#### 問題点
従来の実装では以下の問題がありました：

1. **Task.Run()の使用**: WebGLはシングルスレッドのため`Task.Run()`が動作しない
2. **AwaitCallerの不適切な選択**: `ImmediateCaller()`を使用していたが、WebGLでは`RuntimeOnlyNoThreadAwaitCaller()`が必要
3. **一時ファイル保存の無駄**: バイトデータを一度ファイルに保存してから読み込んでいた

#### 修正内容

**LoadVrmAsync()の修正（Assets/Scripts/Utilities/VRMUtility.cs:181-202）**
```csharp
public static async Task<GameObject> LoadVrmAsync(string path)
{
    try
    {
        // VRMファイルをバイト配列として読み込み
        byte[] vrmBytes;
#if UNITY_WEBGL && !UNITY_EDITOR
        // WebGLではTask.Runが使えないため、同期的に読み込む
        vrmBytes = File.ReadAllBytes(path);
#else
        vrmBytes = await Task.Run(() => File.ReadAllBytes(path));
#endif

        return await LoadVrmFromBytesAsync(vrmBytes, Path.GetFileName(path));
    }
    catch (System.Exception e)
    {
        Debug.LogError($"VRMUtility: VRM読み込みエラー: {e.Message}\n{e.StackTrace}");
    }

    return null;
}
```

**LoadVrmFromBytesAsync()の追加（Assets/Scripts/Utilities/VRMUtility.cs:204-276）**
```csharp
public static async Task<GameObject> LoadVrmFromBytesAsync(byte[] vrmBytes, string fileName)
{
    try
    {
        // WebGL対応のAwaitCallerを選択
        IAwaitCaller awaitCaller;
#if UNITY_WEBGL && !UNITY_EDITOR
        // WebGLではスレッドが使えないため、RuntimeOnlyNoThreadAwaitCallerを使用
        awaitCaller = new RuntimeOnlyNoThreadAwaitCaller();
        if (EnableVerboseLog)
        {
            Debug.Log("VRMUtility: WebGLモード - RuntimeOnlyNoThreadAwaitCallerを使用");
        }
#else
        // その他のプラットフォームではRuntimeOnlyAwaitCallerを使用
        awaitCaller = new RuntimeOnlyAwaitCaller();
        if (EnableVerboseLog)
        {
            Debug.Log("VRMUtility: 通常モード - RuntimeOnlyAwaitCallerを使用");
        }
#endif

        // VRM10をインポート
        Vrm10Instance vrm10Instance = await Vrm10.LoadBytesAsync(
            vrmBytes,
            canLoadVrm0X: true,
            showMeshes: false,
            awaitCaller: awaitCaller
        );

        // ... 以下、メッシュ表示とURP変換処理
    }
    // ...
}
```

**重要な変更点:**
- WebGLプラットフォームでは`RuntimeOnlyNoThreadAwaitCaller()`を使用
- 他のプラットフォームでは`RuntimeOnlyAwaitCaller()`を使用
- バイトデータから直接VRMを読み込み、一時ファイル保存を削除

**LoadAndSetupVrmFromBytes()の修正（Assets/Scripts/Utilities/VRMUtility.cs:95-152）**

従来は一時ファイルに保存してから`LoadAndSetupVrmFromPath()`を呼び出していましたが、新しい`LoadVrmFromBytesAsync()`を直接呼び出すように変更しました。

```csharp
public static IEnumerator LoadAndSetupVrmFromBytes(
    byte[] vrmData,
    string fileName,
    // ...
)
{
    // VRMを非同期で読み込み
    Task<GameObject> loadTask = LoadVrmFromBytesAsync(vrmData, fileName);

    // Taskが完了するまで待機
    while (!loadTask.IsCompleted)
    {
        yield return null;
    }
    // ... エラーハンドリングとセットアップ処理
}
```

### 2. VRMLoadManager - デバッグログの追加

WebGLでの問題特定のため、各処理段階で詳細なログを出力するようにしました。

**OnFileSelected()の修正（Assets/Scripts/Utilities/VRMLoadManager.cs:201-216）**
```csharp
public void OnFileSelected(string url)
{
    Debug.Log($"VRMLoadManager: OnFileSelected呼び出し: url={url}, isLoadingVrm={isLoadingVrm}");

    if (string.IsNullOrEmpty(url))
    {
        Debug.Log("VRMLoadManager: ファイル選択がキャンセルされました（URLが空）。");
        isLoadingVrm = false;
        return;
    }

    Debug.Log($"VRMLoadManager: WebGLファイル選択成功。URLからVRMをダウンロード開始: {url}");

    // コルーチンでファイルをダウンロードして読み込む
    StartCoroutine(LoadVrmFromUrl(url));
}
```

**LoadVrmFromUrl()の修正（Assets/Scripts/Utilities/VRMLoadManager.cs:222-312）**

各処理段階で詳細なログを出力：
- UnityWebRequest送信開始
- UnityWebRequest完了・結果確認
- ダウンロードデータサイズ確認
- VRMUtilityの詳細ログ有効化（WebGLでは常に有効）
- スポーン位置・AnimatorController・PhysicsMaterialの取得状況
- VRMUtility.LoadAndSetupVrmFromBytes呼び出し開始/完了
- コールバック（onComplete/onError）の呼び出し

```csharp
// VRMUtilityの詳細ログを設定（WebGLでのデバッグのため常に有効化）
VRMUtility.EnableVerboseLog = true;
Debug.Log("VRMLoadManager: VRMUtility.EnableVerboseLog = true に設定しました");

// ... スポーン位置、AnimatorController、PhysicsMaterialの取得と確認ログ

Debug.Log("VRMLoadManager: VRMUtility.LoadAndSetupVrmFromBytes呼び出し開始");

yield return VRMUtility.LoadAndSetupVrmFromBytes(
    vrmData,
    "WebGL.vrm",
    spawnPosition,
    animatorController,
    physicsMaterial,
    onComplete: (vrmCharacter) =>
    {
        Debug.Log($"VRMLoadManager: VRM読み込み完了コールバック: {vrmCharacter?.name ?? "null"}");
        OnVrmLoaded(vrmCharacter);
        isLoadingVrm = false;
    },
    onError: (errorMessage) =>
    {
        Debug.LogError($"VRMLoadManager: VRM読み込みエラーコールバック: {errorMessage}");
        isLoadingVrm = false;
    }
);

Debug.Log("VRMLoadManager: LoadVrmFromUrl完了");
```

### 3. 参考にしたVRM10ViewerControllerの実装

VRM-1.0/0.130.1/VRM10Viewer/VRM10ViewerController.csから以下を参考にしました：

**GetIAwaitCaller()メソッド（267-284行）**
```csharp
IAwaitCaller GetIAwaitCaller(bool useAsync)
{
    if (useAsync)
    {
        if (Application.platform == RuntimePlatform.WebGLPlayer)
        {
            return new RuntimeOnlyNoThreadAwaitCaller();
        }
        else
        {
            return new RuntimeOnlyAwaitCaller();
        }
    }
    else
    {
        return new ImmediateCaller();
    }
}
```

この実装から、WebGLでは`RuntimeOnlyNoThreadAwaitCaller()`を使用する必要があることを学びました。

## 技術的なポイント

### WebGLとTask.Run()の互換性

WebGLはシングルスレッド環境のため、`Task.Run()`は動作しません。ファイル読み込みなどのI/O処理は以下のように条件分岐が必要です：

```csharp
#if UNITY_WEBGL && !UNITY_EDITOR
    vrmBytes = File.ReadAllBytes(path);  // 同期読み込み
#else
    vrmBytes = await Task.Run(() => File.ReadAllBytes(path));  // 非同期読み込み
#endif
```

### IAwaitCallerの選択

UniVRM10の`Vrm10.LoadBytesAsync()`では、プラットフォームに応じた適切な`IAwaitCaller`を渡す必要があります：

- **WebGL**: `RuntimeOnlyNoThreadAwaitCaller()` - スレッドなしで非同期処理を実現
- **その他**: `RuntimeOnlyAwaitCaller()` - マルチスレッド対応の非同期処理
- **同期処理**: `ImmediateCaller()` - 即座に完了（非推奨）

### バイトデータからの直接読み込み

従来の実装では、WebGLで受け取ったバイトデータを一度ファイルに保存してから読み込んでいましたが、これは無駄な処理です。`LoadVrmFromBytesAsync()`を実装することで、バイトデータから直接VRMを読み込めるようになりました。

## 効果

- **WebGL対応**: WebGLビルドでVRM読み込み機能が正常動作するようになります
- **デバッグ性向上**: 詳細なログにより、問題が発生した場合の原因特定が容易になります
- **パフォーマンス改善**: 一時ファイル保存を削除することで、読み込み速度が向上します
- **コードの明確化**: WebGL固有の処理が明示的になり、保守性が向上します

## 今後の展開

実際にWebGLビルドで動作確認を行い、以下を確認する必要があります：
1. ファイル選択ダイアログが正常に開くか
2. VRMファイルを選択後、ダウンロードが正常に行われるか
3. VRM読み込みとセットアップが正常に完了するか
4. デバッグログが期待通り出力されているか

問題が発生した場合は、デバッグログを確認して原因を特定できます。
