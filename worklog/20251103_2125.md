# 作業ログ - 20251103_2125

## 変更内容の概要

- VRM読み込み中にローディングパネルを表示し、ゲームを停止状態にする機能を実装しました。
- R3のReactivePropertyを使用してローディング状態を管理し、UIと時間制御を自動的に同期させます。
- ローディング中はポーズメニュー表示時と同様に時間が停止し、キャラクター操作ができないようになります。

## 変更理由

- EditorでもWebビルドでも、VRM読み込み完了して操作キャラが移動できるまでの間、元のキャラ操作が可能な状態で状況が分かりにくい問題がありました。
- ローディングパネルを表示して視覚的に分かりやすくし、操作を無効化することでユーザー体験を向上させる必要がありました。
- イベント駆動アーキテクチャにより、ローディング状態の管理を一元化し、各コンポーネントが自動的に反応するようにしました。

## 実装詳細

### 1. GameStateManager - ローディング状態の追加

**GameState.cs（GameStateManager.cs内に定義）**

ローディング状態を管理するReactivePropertyを追加：

```csharp
/// <summary>
/// ローディング中かどうか（VRM読み込みなど）
/// </summary>
public ReactiveProperty<bool> IsLoading { get; private set; }

// コンストラクタ内
IsLoading = new ReactiveProperty<bool>(false);
```

**GameStateManager.cs**

ローディング開始/終了を通知するメソッドを追加：

```csharp
/// <summary>
/// ローディング開始を通知する
/// VRM読み込みなど、時間のかかる処理の開始時に呼び出す
/// </summary>
public void StartLoading()
{
    state.IsLoading.Value = true;
}

/// <summary>
/// ローディング終了を通知する
/// VRM読み込みなど、時間のかかる処理の完了時に呼び出す
/// </summary>
public void EndLoading()
{
    state.IsLoading.Value = false;
}
```

### 2. GameUIManager - ローディングパネル表示制御

**ローディングパネルの初期化**

Start()メソッド内で初期状態を非表示に設定：

```csharp
// VRMローディングパネルを初期状態で非表示
if (loadingView != null)
{
    loadingView.SetActive(false);
}
if (loadingViewCanvasGroup != null)
{
    loadingViewCanvasGroup.alpha = 0f;
}
```

**IsLoadingの購読**

R3のSubscribeを使用してローディング状態を監視：

```csharp
// ローディング状態変動購読（ローディングパネル表示制御）
var loadingSubscriber = gameManager.StateManager.State.IsLoading.Subscribe(isLoading =>
{
    if (isLoading)
    {
        ShowLoadingPanel();
    }
    else
    {
        HideLoadingPanel();
    }
});

// disposable登録に追加
disposable = Disposable.Combine(
    coinSubscriber,
    totalCoinSubscriber,
    hitpointSubscriber,
    damageSubscriber,
    pauseSubscriber,
    loadingSubscriber  // 追加
);
```

**表示/非表示メソッド**

```csharp
/// <summary>
/// ローディングパネルを表示する
/// </summary>
private void ShowLoadingPanel()
{
    if (loadingView == null || loadingViewCanvasGroup == null)
    {
        Debug.LogWarning("GameUIManager: loadingViewまたはloadingViewCanvasGroupが設定されていません。");
        return;
    }

    // ローディングパネルを即座に表示
    loadingView.SetActive(true);
    loadingViewCanvasGroup.alpha = 1f;
}

/// <summary>
/// ローディングパネルを非表示にする
/// </summary>
private void HideLoadingPanel()
{
    if (loadingView == null || loadingViewCanvasGroup == null)
    {
        return;
    }

    // ローディングパネルを即座に非表示
    loadingViewCanvasGroup.alpha = 0f;
    loadingView.SetActive(false);
}
```

**実装のポイント:**
- ポーズメニューと異なり、フェード処理を行わず即座に表示/非表示
- LoadingView（GameObject）は既にGameManagerの初期化ローディングで使用されていたものを再利用

### 3. VRMLoadManager - ローディングイベントの発火

**FinishLoading()ヘルパーメソッドの追加**

isLoadingVrmフラグのリセットとローディング終了通知を一元化：

```csharp
/// <summary>
/// ローディングを終了する（フラグリセットとイベント通知）
/// </summary>
private void FinishLoading()
{
    isLoadingVrm = false;

    // ローディング終了を通知
    if (gameManager != null && gameManager.StateManager != null)
    {
        gameManager.StateManager.EndLoading();
    }
}
```

**LoadVrmFromFileDialog()の修正**

ローディング開始時にStartLoading()を呼び出し：

```csharp
public IEnumerator LoadVrmFromFileDialog()
{
    if (isLoadingVrm)
    {
        Debug.LogWarning("VRMLoadManager: 既にVRMロード中です。");
        yield break;
    }

    isLoadingVrm = true;

    // ローディング開始を通知
    if (gameManager != null && gameManager.StateManager != null)
    {
        gameManager.StateManager.StartLoading();
    }

    // ファイル選択ダイアログを開く
    string vrmPath = OpenFileDialog();

    // ... 以降の処理
}
```

**全てのisLoadingVrm = falseをFinishLoading()に置き換え**

- LoadVrmFromFileDialog()のエラー処理・キャンセル処理
- OnFileSelected()のキャンセル処理
- LoadVrmFromUrl()のエラー処理
- LoadVrmFromPath()の開始処理とLoadVrmFromPathCoroutine()の終了処理
- VRMUtility.LoadAndSetupVrmFromPath/Bytesのコールバック（onComplete/onError）

**例：VRMUtility呼び出しのコールバック**
```csharp
yield return VRMUtility.LoadAndSetupVrmFromPath(
    vrmPath,
    spawnPosition,
    animatorController,
    physicsMaterial,
    onComplete: (vrmCharacter) =>
    {
        OnVrmLoaded(vrmCharacter);
        FinishLoading();  // 完了時にローディング終了
    },
    onError: (errorMessage) =>
    {
        Debug.LogError($"VRMLoadManager: {errorMessage}");
        FinishLoading();  // エラー時もローディング終了
    }
);
```

### 4. GameTimeManager - ローディング中の時間停止

**IsLoadingの購読**

Start()メソッド内でローディング状態を監視：

```csharp
// ローディング状態の購読
var loadingSubscription = gameManager.StateManager.State.IsLoading.Subscribe(isLoading =>
{
    OnLoadingChanged(isLoading);
});

// disposable登録に追加
disposable = Disposable.Combine(
    pauseSubscription,
    loadingSubscription,  // 追加
    timeScaleSubscription
);
```

**OnLoadingChanged()メソッドの追加**

ポーズと同様の処理でゲームを停止：

```csharp
/// <summary>
/// ローディング状態が変化したときの処理
/// </summary>
void OnLoadingChanged(bool isLoading)
{
    if (isLoading)
    {
        // ローディング前のタイムスケールを保存
        timeScaleBeforePause = Time.timeScale;

        // ローディング時はゲームを停止
        Time.timeScale = pausedTimeScale;
        gameManager.StateManager.SetTimeScale(pausedTimeScale);

        if (EnableVerboseLog)
        {
            Debug.Log($"GameTimeManager: ローディング開始。ゲームを停止しました。TimeScale: {Time.timeScale}");
        }
    }
    else
    {
        // ローディング解除時は保存していたタイムスケールを復元
        Time.timeScale = timeScaleBeforePause;
        gameManager.StateManager.SetTimeScale(timeScaleBeforePause);

        if (EnableVerboseLog)
        {
            Debug.Log($"GameTimeManager: ローディング完了。ゲームを再開しました。TimeScale: {Time.timeScale}");
        }
    }
}
```

**OnTimeScaleChanged()の修正**

ローディング中もタイムスケール変更を無視するように修正：

```csharp
void OnTimeScaleChanged(float timeScale)
{
    // ポーズ中またはローディング中はタイムスケールを変更しない
    if (gameManager.StateManager.State.IsPaused.CurrentValue ||
        gameManager.StateManager.State.IsLoading.CurrentValue)
    {
        return;
    }

    // タイムスケールを適用
    Time.timeScale = timeScale;
}
```

## 技術的なポイント

### R3のReactivePropertyによる状態管理

- `IsLoading`をReactivePropertyとして定義することで、値が変更されると自動的に購読者に通知されます
- UIManagerとTimeManagerが独立してIsLoadingを購読し、それぞれ表示制御と時間制御を行います
- イベント駆動アーキテクチャにより、ローディング状態の変更箇所（VRMLoadManager）とそれに反応する箇所（UI/Time）を疎結合に保つことができます

### ポーズとローディングの統一的な扱い

- ポーズメニュー表示時とローディング中で、同じ`pausedTimeScale`を使用してゲームを停止
- `timeScaleBeforePause`変数を共有することで、どちらの状態からでも元のタイムスケールに戻せます
- OnTimeScaleChanged()でポーズとローディングの両方をチェックすることで、停止中の意図しないタイムスケール変更を防止

### FinishLoading()パターン

従来の`isLoadingVrm = false`を`FinishLoading()`メソッドに統一することで：
- ローディング終了時の処理（フラグリセット + イベント通知）を一箇所で管理
- 処理の漏れを防止
- 将来的にローディング終了時の処理を追加する場合も、1箇所の修正で済む

## 効果

- **視覚的なフィードバック**: VRM読み込み中にローディングパネルが表示され、何が起きているか明確になります
- **操作の無効化**: ローディング中は時間が停止し、キャラクター操作ができなくなります（ポーズメニューと同じ状態）
- **統一的な体験**: Editor・WebGLビルド両方で同じローディング体験を提供します
- **保守性の向上**: イベント駆動アーキテクチャにより、ローディング状態の管理が一元化され、各コンポーネントが自動的に同期します

## 今後の展開

- ローディングパネルにプログレスバーを追加して進捗を表示
- ローディング中のテキストメッセージを動的に変更（"VRMをダウンロード中..."、"セットアップ中..."など）
- フェードイン/フェードアウトの追加（現在は即座に表示/非表示）
- 他の時間のかかる処理（レベルロードなど）でも同じローディングシステムを活用

## 変更ファイル

- `Assets/Scripts/GameManager/GameStateManager.cs`
  - IsLoadingプロパティの追加
  - StartLoading()/EndLoading()メソッドの追加
- `Assets/Scripts/GameManager/GameUIManager.cs`
  - IsLoadingの購読
  - ShowLoadingPanel()/HideLoadingPanel()メソッドの追加
- `Assets/Scripts/Utilities/VRMLoadManager.cs`
  - FinishLoading()ヘルパーメソッドの追加
  - 全ての読み込み処理でStartLoading()/FinishLoading()を呼び出し
- `Assets/Scripts/GameManager/GameTimeManager.cs`
  - IsLoadingの購読
  - OnLoadingChanged()メソッドの追加
  - OnTimeScaleChanged()でローディング中もチェック
